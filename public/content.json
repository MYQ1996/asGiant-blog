{"meta":{"title":"AsGiant-bolg","subtitle":null,"description":null,"author":"Mason Mei","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"个人简历","slug":"resume","date":"2019-06-05T03:19:04.000Z","updated":"2019-06-06T09:23:01.000Z","comments":true,"path":"2019/06/05/resume/","link":"","permalink":"http://yoursite.com/2019/06/05/resume/","excerpt":"","text":"梅衍青 男 ︳ 23岁 ︳大专 ︳ 2年工作经验 ︳ 上海 17621515830 ︳954663633@qq.com 上海工商职业技术学院 移动互联网方向 技能 前端：HTML、CSS、JavaScript前端框架: vue、webpack、cordova、react-native，微信小程序后端：php、node后端框架: thinkphp、express、koa2、egg数据库:mysql、mongodb、redis 版本控制：git、svn 工作经历 上海子杰软件有限公司 2017.01-2018-06 快睿登信息科技(上海)有限公司 2018.06-至今** 项目经验 一、风驰后台v0.2&amp;小通分期v0.2 2019.2-至今项目内容:风驰后台、小通分期(汇宝通)作为第二期项目的迭代。小通分期，增加分期功能。技术栈:avuex、vue全家桶、cordva、webpack、less项目类型:网页、app项目经验:技术点调用cordva插件，获取手机通讯录、GPS、联系人、电量、极光推送等原生功能。同时迭代风驰后台的页面系统，用户量也大量增加后发现并且处理一些关于手机适配的问题(主要是因为cordva是调用手机中的内核浏览器，出现了css3不兼容的问题)二、重构风驰后台v0.1 2018年12 – 2019-2项目内容:计划迭代汇宝通后台中，我提出了以下问题。1.前后端有绑定关系，发布后，前后端的这种依赖。2.ui的局限，后台都是使用敏捷开发，那么意味着很多组件是根据技术选型的时候就确定了的。我们现有的框架无法做到ui升级。选择迁回老风驰工程量也会很大(这里的重写包括语法结构都需要重写),选择强行在先有ui框架上修改，工程量无法估计。3.需求其实不是很明确的，只能参照老风驰的样子做，新老风驰经手的人都比较多，都是有什么需求直接加什么需求，但是具体权限和细节根据时间的推移，没有任何文档可以参照，所以建议重构。技术栈:avuex、vue全家桶项目类型:网页项目经验：当时遇到了一个问题，就是这套后台必须兼容手机端的问题，element-ui的缺点也提现出来的，那就是对于手机端的适配，很多插件都会有问题，第二个问题就是前端人手紧缺，原来使用的架构，人手上无法维护。加上时间比较紧张，经过调研，采用了avuex的框架方案，该方案的优势在于json驱动ui的思想理念。以最快的速度，重构了风驰后台。 三、黑卡 2018.11-2018-12项目内容:根据个人资质情况，可以进行不同次数的征信洗白，享有最高100，000的额度利率低至银行利率，介绍老铁洗白征信，长期有效，连续签到一年，1000元大奖，三星级会员五星级酒店。技术栈: vue、cordva、webpack、less项目类型：app、网页项目经验：针对于先有公司项目的沉淀，公司决定开启黑卡项目业务，对于vue技术的了解和逐步深入后，公司也对于原生和动态交互提出了更高的要求，针对于目前项目的组件规划和开发。 四、汇宝通-后台 2018.08-2018-10项目内容: vue后台贷款系统，引流，贷款模块，用户模块，商品模块，进件模块，风控模块技术栈:vue、webpack、element-ui项目类型：网页项目经验:正对于现在走向组件化的趋势，配合公司领导，进行了后台组件的开发。将原先的贷款系统，引流，贷款模块，用户模块，商品模块，进件模块，风控模块拆分为各个模块，方便与后台页面随时的重构组装，服务与公司将部分模块卖给第三方公司的构想。 五、汇宝通-app 2018.07-2018-09项目内容: p2p的线上贷款系统，引流，贷款模块，用户模块，商品模块，进件模块，风控模块为一体的app项目。技术栈:vue、cordva、webpack、less项目类型：app、网页项目经验：离开上一家公司后，我开始了新的征程，这第一次对于node技术进行了了解。前端做到工程和模块的话处理，将人力减少到最小数的敏捷开发。对于项目负责人的架构进行了学习和梳理。了解了关于cordva的插件。对于三个端(网页，安卓，ios)的兼容性，达到最快的试错。对于webpack的改造项目工程目录，达到了，一份代码能兼容三个端，并且还能够调用原生的底层权限。 六、梯子网小程序 2018.01-2018-06项目内容: 梯子网为教育局和大型社会培训机构提供一站式多机构管理，其中主要涉及两个难点，一是多机构的管理，不同机构可以定制自己模块下的内容，只有本机构下的人可以看到。二是定制化产生页面，不同的机构可以定制自己的页面栏目，根据自己的需要展示对应的内容，这还涉及到了不同机构、角色的权限问题。项目类型: 微信小程序技术栈: wxml、wxss、js项目经验：冬去春来，公司决定实现一个小程序的工作规划，对于项目探索工作交给了我。对于视频的学习，可能因为有着react-native项目经验，对于新起的mvvm这样的设计思路有着充分的了解。所以上手写小程序，反而觉得比较简单。对于微信组件和api进行了了解和使用。对于wx.request进行了封装，和关于一些常用函数的封装，针对一些常用组件的封装。例如wx.getStorage、清空缓存、分享、弹窗等等。方便对于其他协作的伙伴调用和使用。 七、上海天马Portal系统 2017.11-2017.12项目内容: 上海天马Portal管理系统是为了在公司内部整合所有业务系统，规范统一入口，消息通知，业务处理，是业务统一入口，用户无需牢记各个应用系统的地址，降低用户使用时的困难，避免用户来回切换业务系统，提升用户工作效率。项目类型: 网页技术栈:layui、jquery、html项目经验:第一次带2个实习生一起工作，心里美滋滋啊(不排除项目比较简单)，关于前端我才用了layui框架，使用过bootstrap后，总觉得layui的页面的美观程度还是比bootstrap框架要优雅很多的。也让我开始了解代码的书写规范，按照美工的设计与后台的配合，完成了项目的进度。 八、英语学习-EnglishOnlie 2017.08-2017.10项目内容: 软件分学生端和教师端，学生端主要实现学习功能，学习进度通过闯关和教师操作控制，教师端主要实现管理功能，管理学生帐户，学习资源管理，学习进度管理。项目类型:app、网页、微信网页技术栈：react-native、html、jquery项目经验:这个公司遗留下的一个比较老的项目，不少组件使用的是react-android，不兼容ios的组件，这个工作的主要任务，就是将ios的兼容问题彻底的解决、并且兼容网页与微信网页。这个项目最大的特色应该就是学生读英语的功能，可以经过讯飞系统的语言识别，来判断学生的读音，从而给予评分。第一次了解了网页的录音和微信网页的录音调用是不同的，微信的调用，是不同的，微信有着自己独有的api。 九、玖龙移动销售 2017.05-2017.07项目内容: 在前端、管理查看集团的产品、订单、销售统计信息。项目类型:app技术栈:react-native项目经验:经过之前三个月的学习，加入了新的项目组，对于这个项目而言，并没有参加项目的原始的开发计划。当时公司其他的项目比较紧张，与项目组长两个人直接飞往东莞珑石集团技术部门，进行了bug的修复，刚刚参加项目的时候，主要是对于ios的适配问题进行了修复工作(因为我是mac),了解了关于ios的info.list。第一次对于ios白名单有所认识，了解了关于前端调用原生的，最大的问题，是关于一些原生的权限问题。 十、中国国际珠宝交易平台 2017.01-2017.04 项目内容: “中国国际珠宝交易平台” APP 具有产品搜索/浏览、商品购买、评价、退换货等功能项目类型:app技术栈:react-native项目经验:这个项目是加入前端组织行列的第一个项目，你知道在2017年，这个react-native在大环境下，其实我认为还不算很成熟，当时项目组没有什么这方面的技术，就自发的组织学习这项技术。几个通宵后的学习，学了基本上的flex布局，对于react-natve的特殊的css处理方法进行了了解，了解了fetch的网络请求方案，让工作的环境中还算能够使用这项技术，因为那时候刚刚入行，代码的稚嫩，如今看来还是有很大的问题。 开源项目 **https://github.com/MYQ1996/asGiant-admin.git项目内容: 基于egg架构的自动生成接口的框架 你可以这么理解这个框架，就是在你配置完数据后，就生成了增删改查接口，也同时生成了相关的栏目。 这样即使你是一个不懂后端的同学，你也可以直接调用接口给前端使用 _在这个项目中，我希望能解决，前端对于后端的不熟悉和了解，但是对于调用接口比较熟悉的业务现状。完成了以下模块。对于表的增删改查操作、增删改字段的信息、短信管理(只需配置短信的key)、邮箱管理(需配置邮箱的key)、人员注册(手机号、用户名、邮箱)、针对于字段添加了人员权限。之后的规划想做个cms，针对于seo的网站排名调优。对于增加之后，直接生成相对应的前端页面，使用node写了一个微信机器人，符合时代需求，达到人工智能，和机器人聊天的过程中，直接操作平台，完成接口的操作。希望之后，技术提升之后，能够够写出一套兼容性比较高的组件，直接配合平台的使用，有考虑过taro，但是感觉对于原生的调用不足，还在思考这部分的工作。最后达到敏捷开发的效果。(因为加班的缘故，所以一直没有做完)。 掘金博客 https://juejin.im/user/5b4e88986fb9a04fba6e752b 自我描述 对于技术出生，还是个大专。还是受到不少的压力的，现在毕竟都觉得本科生比较好培养嘛。我是15年进的大专。第一年被选中参加了，学校的比赛班，主要就是负责学校对外的比赛参加。大二开始不参加日常课程直接进入培训，大三进入校企合作上班。对于技术不断追求，热衷学习研究新技术，实践在项目中。对于前后端有着一定的理解，希望能达到技术一个新的高度。ps: 希望能和贵公司有着合作的机会，也希望能成为你的同事。","categories":[],"tags":[]},{"title":"11.函数基础","slug":"JavaScript基础入门/11 函数基础","date":"2019-04-10T08:10:04.000Z","updated":"2019-06-06T15:51:28.000Z","comments":true,"path":"2019/04/10/JavaScript基础入门/11 函数基础/","link":"","permalink":"http://yoursite.com/2019/04/10/JavaScript基础入门/11 函数基础/","excerpt":"","text":"函数是指一段在一起的、可以做某一件事儿的程序。也叫做子程序、(OOP中)方法 函数实现某一个功能的方法 创建函数1234functoin [函数名]()&#123; // =&gt; [函数体] // 实现功能的具体js代码&#125; 执行函数12函数名(); // 创建的函数执行，而且这个函数可以执行很多次函数名(); 每一次执行都相当于把函数体重实现功能的js代码重复执行了一遍 在真实的项目中，我们一般都会把实现一个具体功能的代码封装到函数中 如果当前这个功能需要在页面中执行多次，不封装成为函数，每一次实现这个功能，都需要重新吧代码写一遍，浪费时间；而封装在一个函数中，以后想实现多次这个功能，我们就没有必要在重新写代码，只需要把函数重新的执行即可，提高了开发效率 封装在一个函数，页面中就基本上很难重复一样的代码了，减少了页面中代码的冗余度，提高了代码的重复利用率: 低耦合高内聚 我们把以上的特点成为函数封装 (OOP面向对象编程思想，需要我们掌握的就是类的继承、封装、多态) JS中函数的核心原理 函数作为js中引用数据类型中的一种，也是按照引用地址操作的 123456function sum()&#123; var total = 1+1; total *= 20; console.log(total.toFixed(2));&#125;sum(); 创建函数 首先会在当前作用中声明一个函数名(声明的函数和使用var声明变量是一样的操作:var sum;function cum;这两个名字算重复了) 浏览器首先会开辟一个新的内存空间(奉陪一个16进制地址)，把函数体重写好的代码当做普通字符串存储在这个内存空间(创建一个函数如果不执行，函数没有意义) 把内存空间的地址赋值给之前声明的那个函数名 函数执行 目的:把之前存储的实现具体功能的js代码执行 函数执行，浏览器首先会为其开辟新的私有作用域(只能执行函数中之前编写的js代码) 形参赋值 私有作用中的变量升级 把之前穿件时间存储的那些js代码字符串，拿到自由作用域中，然后把题目变成js表达式从上到下执行 私有作用域是否销毁的问题 ![image.png](https://cdn.nlark.com/yuque/0/2019/png/271124/1553076800854-5e22d4eb-aa50-40a1-a8de-6abbd5cf8939.png#align=left&display=inline&height=203&name=image.png&originHeight=406&originWidth=986&size=115231&status=done&width=493) 闭包 函数执行会形成一个私有的作用域，让里面的私有变量和外界互不影响(相互干扰、外面的无法直接获取里面的变量值)，此时我们可以理解为私有作用域把私有变量保护起来，我们把这种保护机制称为为闭包 栈内存 作用域(全局作用域/私有作用域):提供一个供js代码执行的环境 堆内存 所有的引用数据类型，他们需要存储的内容都是堆内存中(相当于一个仓库，目的是存储信息) 对象会吧键值队存储起来 函数会把代码当做字符串存储起来 函数中形参和实参 形参:相当于生成洗衣机的时候提供的入口，需要用户执行函数的时候把需要的值传递进来，形参是个变量，用来春初和接口那些值 实参:用户执行的时候传递给形参的具体指 1234567891011// 随便求出两个数的和function sum(num1,num2)&#123; //num1/num2就是形参变量(类似于var了一下) var total = num1 + num2; total*=10; total=total.toFixed(2); console.log(total);&#125;sum(10,20);//10/20是实参 num1=10 num2=20sum(10); // num1=10 num2=undefined 定义了形参但是执行的时候，没有传递实参，默认实参就是undefined arguments实参集合 当我们不知道用户具体要传递几个值的时候(传递几个值都行)，此时我们无法设置形参的个数:遇到此类需要，需要使用函数内置的实参集合：arguments argument 只有函数才有 不管执行函数的时候是否传递实参，arguments天生就纯在，没有传递实参ARG是个空的集合传递了ARG中包含了所有传递的实参值 不管是否设置了形参，ARG中始终存储了所有的实参信息 1234function sum()&#123; console.log(arguments)&#125;sum(10,20,'wjh',&#123;name:'wjw'&#125;); arguments 是个类数组集合 以数字作为索引(属性名)，从0开始 arguments[0] 第一个实参信息 arguments[2] 第三个实参信息 arguments[n] 第n+1个实参信息 有一个length的属性，存储的是当前几个的长度(当前传递实参的个数) arguments.length arguments[‘length’] arguments.calle 存储的是当前函数本身 arguments.calle.caller 存储的是当前函数只在哪执行的(宿主函数)，在全局作用域下执行的，结果是null 1234567function sum()&#123; console.log(arguments.callee.caller);//f&#125;function fn()&#123; sum(10,20,'wjh',&#123;name:'wjw'&#125;);&#125;fn(); // arguments.call或者arguments.call.caller一般真正项目中很少使用，因为是在严格js模式下不允许我们直接使用这两个属性，然而现有项目大部分都是基于严格模式来的 123456789101112131415161718// 任意数求和function sum()&#123; var total = null; for(var i =0;i&lt;arguments.length;i++)&#123; var cur = Number(arguments[i]); !isNaN(cur)?total += cur : null &#125; consloe.log(total); return total; // return 后面跟着的都是值(返回的都是值):此处不少TOTAL变量返回，而是吧total存储到值返回而已 // return 60;&#125;sum(10,20,20);sum();sum(10,20,30,'wjw')// console.log(total); //=&gt;Uncaught ReferenceError: total is not defined 闭包的保护机制导致作用域会保护里面的私有变量 JS中的返回值return 返回值是函数提供的一个出口:我们如果想在外面使用函数私有的一些信息，那么就需要通过return，把这些信息返回出来供外面使用 sum:代表的是函数本身sum() 让函数先执行，代表的是当前函数返回的结果(return)后面是啥，相当于函数返回的是啥 123456function sum()&#123; var total = 0; renturn&#125;console.log(sum());// 如果函数中没有return或者return后面啥也没有，默认返回的结果是undefined 123456function sum()&#123; var total = 0; renturn; console.log(sum()); // 函数体重遇到return后，return后面的代码都不在执行了&#125; js中匿名函数 没有名字的函数 函数表达式 自执行函数 1234oBox.onclick = function()&#123; // 把一个码云名字的函数(有名字的也无所谓)作为值赋值给一个变量或者一个元素的某一个事件等,函数表达式&#125; 12345678910(function(n)&#123; // 创建函数和执行函数放在一起，穿件完成立马之执行:自执行函数 // n 形参 n=10&#125;)(10)// 以下都是自执行函数，符号只有控制语法规范~function()&#123;&#125;(10)-function()&#123;&#125;(10)+function()&#123;&#125;(10)!function()&#123;&#125;(10)","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"10.数组的函数","slug":"JavaScript基础入门/10 数组的函数","date":"2019-04-10T07:10:04.000Z","updated":"2019-06-06T15:50:01.000Z","comments":true,"path":"2019/04/10/JavaScript基础入门/10 数组的函数/","link":"","permalink":"http://yoursite.com/2019/04/10/JavaScript基础入门/10 数组的函数/","excerpt":"","text":"数组的基础结构 数组也是对象数据类型 typeof [] -&gt; ‘object’ 数组也是属性名，只不过属性名是数字，我们把数字属性名称之为它的索引:数组是以数字为索引，索引从零开始，有一个length属性代表数组的长度 类数组：类似于数组，但是不是数组 通过getElementsByTageName 获取的元素集合是类数组 函数中的实参集合argument也是类数组 123456789101112// for 循环操作for(var i =0;i&lt;ary.length;i++)&#123; console.log(ary[i])&#125;// for in 循环操作for(var key in ary)&#123; // key:属性名(数组中的属性名是索引) console.log(ary[key]);&#125;// for 循环只能遍历到数组私有的一些属性，而for in 循环可以吧一些自定义的公共属性也能遍历到 数组中的常用方法 数组中有很多方法 1console.dir(Array.prototype) 方法的意义和作用 方法的形参 方法的返回值 通过此方法，原来的数组是否发生了改变 实现数组的增加、修改、删除 增加push : 向数组的末尾追加新内容参数:一到多个，任何数据类型都可以，想要给数组末尾追加什么，直接传递到push方法中极客，传递多个逗号隔开返回值:新增后数组的长度原有数组改变了 unshift:向数组开头追加新内容参数:需要追加的内容(可以是多个任何数据类型的值)返回值:新增后 数组的长度原来数组改变了 把数组当做一个普通的对象，使用对象键值对的操作，给其设置新的属性(索引)ary[ary.length]=xxx 向数组的末尾追加了新的内容 删除pop 删除数组最后一项参数:无返回值:被删除的那一项内容原有数组改变了 shift:删除数组第一项参数:无返回值:被删除那一项的内容原有数组改变了使用shift删除第一项之后，后面每一项的索引都要向前进一位(导致后面项的索引发生了改变) 把数组当做一个普通对象操作delete删除:delete ary[索引]删除指定索引这一项(当前项被删除后),原有数组其它项的索引不会改变:当前数组的length也不会改变 ary.length–:删除数组最后一项 splice:数组中内置的方法，可以实现数组的增加、修改、删除splice实现删除splice(n,m):从索引n开始删除m个(m不写是个删除列数组的末尾，n也不写)返回值:被删除的内容(以一个新数组保存)原有数组改变了splice(0) 清空数组splice() 一项都不删除，返回一个新的空数组splice(0,1)删除第一项 splice实现修改splice(n,m,x):在原有删除的基础上，用x代替删除的内容 splice实现增加splice(n,0,x):在修改的基础上，我们一项都不删除，把x插入到索引n的前面ary.splice(0,0,x) 向数组末尾追加新元素 数组的查询 slice 数组的查询 参数:slice(n,m) 从索引n开始找到索引m处(不包含m) 返回值:吧找到的部分已一个新数组返回 原来的数组不变 slice(n) 从索引n开始找到末尾slice(0) /slice() 数组克隆，克隆一份和原来数组一模一样的的新数组slice支持负载索引，如果传递的索引为负数，浏览器解析的时候是按照总长度+负数索引 来处理的 将两个数组进行拼接concat:将多个数组拼接在一起 参数:要拼接的内容(把内容放在原数组的后面)，可以是一个数组 返回:拼接后的新数组 原有数组不变 数组的查询slice: 数组的查询参数: slice(n,m) 从索引n开始找到索引为m处(不包含m)返回值:把找到的部分已一个新数组返回原来的数组不变 123slice(n) 从索引n开始找到末尾slice(0) / slice() 数组克隆，克隆一份和原来数组一模一样的新数组slice 支持负数索引，如果传递的索引为负数，浏览器解析的时候是按照，总长度+负数索引 来处理的 数组的拼接concat:将多个数组拼接在一起参数:要拼接的内容(把内容放在原数组的后面),可以是一个数组，也可以是一些数据值返回:拼接后的新数组原有的数组不变 12let arr = [0,100]arr.concat([100,200],[200,300],12) concat() 什么都没有拼接，相当于吧原有数组克隆一份一模一样的出来 数组转字符串toString 实现吧数组转化为字符串(转换后的字符串逗号分隔每一项) 参数:无返回值:转换的字符串原有数组不变 join 把数组按照指定的分隔符转换为字符串，和字符串中的split相对应 参数:指定的链接符号 返回值:转换后的字符串 原有数组不变 已知数组的每一项都是数字，想事先数组求和，我们如何实现？ 循环实现 1234var total = null;for(var i=0;i&lt;ary.length;i++)&#123; total+=ary[i];&#125; 利用join 1var total = eval(ary.join('+')) // evel:把字符串变为js表达式执行 实现数组中每一项的排序和排列reverse 把数组中每一项倒过来排序 参数:无返回值:排序后的数组原有数组改变 sort 实现数组的排序 参数:无或者回调函数返回值:排序后的数组原有数组改变 不传递参数的情况下:可以给10以内的数字进行升序排列，但是超过10的就无法处理(多位数值识别第一位) 1234ary.sort(function(a,b)&#123; return a-b; //升序 return b-a; //降序&#125;) 验证数组中是否包含某一项indexOf / lastindexOf 获取当前现在数组中第一次或者最后一次出现的位置索引 数组的这两个方法在IE6-IE8下不兼容 字符串的这两个方法兼容所有的浏览器 123if(ary.indexOf(12)&gt;-1)&#123; // 数组中包含12&#125; 原理12345678910Array.prototype.myIndexOf = function myIndexOf(value)&#123; var result = -1; for(var i =0;i&lt;this.length;i++)&#123; if(value===this[i])&#123; result = i; break; &#125; &#125; return result;&#125; 遍历数组每一项的方法 以下方法ie6-8下都不兼容 forEach 遍历数组中的每一项 12345ary.forEach(function(value,index)&#123; /* 数组中有多少项，当前回调函数执行多少次，妹妹一次传进来的value就是当前遍历数组这一项的值，index 就是遍历这一项的索引 */&#125;) map 遍历数组中的每一项，在forEach的基础上，可以修改每一项的值 1234567ary.map(function(value,index)&#123; /* 数组中有多少项，当前回调函数执行多少次，妹妹一次传进来的value就是当前遍历数组这一项的值，index 就是遍历这一项的索引 */ return xxx; // return 后面返回的结果就是当前遍历的这一项修改为xxx&#125;) filterfindreduceevery… 数组去重 var ary = [1,2,3,4,5,6,7,1,3,4,5]; 方案一 最简单数组去重法遍历数组的每一项，拿每一项和它后面的项依次比较,如果相同了，则把相同的这一项在原来数组中删除即可 12345678910111213141516/** 新建一新数组，遍历传入数组，值不在新数组就push进该新数组中* IE8以下不支持数组的indexOf方法* */function uniq(array)&#123; var temp = []; //一个新的临时数组 for(var i = 0; i &lt; array.length; i++)&#123; if(temp.indexOf(array[i]) == -1)&#123; temp.push(array[i]); &#125; &#125; return temp;&#125;var aa = [1,2,2,4,9,6,7,5,2,3,5,6,5];console.log(uniq(aa)); 方案二 对象键值法去重123456789101112131415161718192021222324252627/** 速度最快， 占空间最多（空间换时间）** 该方法执行的速度比其他任何方法都快， 就是占用的内存大一些。* 现思路：新建一js对象以及新数组，遍历传入数组时，判断值是否为js对象的键，* 不是的话给对象新增该键并放入新数组。* 注意点：判断是否为js对象键时，会自动对传入的键执行“toString()”，* 不同的键可能会被误认为一样，例如n[val]-- n[1]、n[\"1\"]；* 解决上述问题还是得调用“indexOf”。*/function uniq(array)&#123; var temp = &#123;&#125;, r = [], len = array.length, val, type; for (var i = 0; i &lt; len; i++) &#123; val = array[i]; type = typeof val; if (!temp[val]) &#123; temp[val] = [type]; r.push(val); &#125; else if (temp[val].indexOf(type) &lt; 0) &#123; temp[val].push(type); r.push(val); &#125; &#125; return r;&#125;var aa = [1,2,\"2\",4,9,\"a\",\"a\",2,3,5,6,5];console.log(uniq(aa)); 方案三 排序后相邻去除法123456789101112131415161718/** 给传入数组排序，排序后相同值相邻，* 然后遍历时,新数组只加入不与前一值重复的值。* 会打乱原来数组的顺序* */function uniq(array)&#123; array.sort(); var temp=[array[0]]; for(var i = 1; i &lt; array.length; i++)&#123; if( array[i] !== temp[temp.length-1])&#123; temp.push(array[i]); &#125; &#125; return temp;&#125;var aa = [1,2,\"2\",4,9,\"a\",\"a\",2,3,5,6,5];console.log(uniq(aa)); 方案四 数组下标法12345678910111213141516171819/*** 还是得调用“indexOf”性能跟方法1差不多，* 实现思路：如果当前数组的第i项在当前数组中第一次出现的位置不是i，* 那么表示第i项是重复的，忽略掉。否则存入结果数组。* */function uniq(array)&#123; var temp = []; for(var i = 0; i &lt; array.length; i++) &#123; //如果当前数组的第i项在当前数组中第一次出现的位置是i，才存入数组；否则代表是重复的 if(array.indexOf(array[i]) == i)&#123; temp.push(array[i]) &#125; &#125; return temp;&#125;var aa = [1,2,\"2\",4,9,\"a\",\"a\",2,3,5,6,5];console.log(uniq(aa)); 方案五 优化遍历数组法123456789101112131415161718192021222324252627// 思路：获取没重复的最右一值放入新数组/** 推荐的方法** 方法的实现代码相当酷炫，* 实现思路：获取没重复的最右一值放入新数组。* （检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）*/function uniq(array)&#123; var temp = []; var index = []; var l = array.length; for(var i = 0; i &lt; l; i++) &#123; for(var j = i + 1; j &lt; l; j++)&#123; if (array[i] === array[j])&#123; i++; j = i; &#125; &#125; temp.push(array[i]); index.push(i); &#125; console.log(index); return temp;&#125;var aa = [1,2,2,3,5,3,6,5];console.log(uniq(aa));","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"9.Date的基础知识","slug":"JavaScript基础入门/9 Date的基础知识","date":"2019-04-10T06:10:04.000Z","updated":"2019-06-06T15:46:06.000Z","comments":true,"path":"2019/04/10/JavaScript基础入门/9 Date的基础知识/","link":"","permalink":"http://yoursite.com/2019/04/10/JavaScript基础入门/9 Date的基础知识/","excerpt":"","text":"Data 是日期类 通过它可以对时间进行处理 1234567891011121314151617var time = new Date();// 获取当前客户端本机时间(当前获取的时间不能作为重要的参考依据)// 获取结果是一个日期格式的对象// Wed Mar 20 2019 17:37:16 GMT+0800 (中国标准时间)typeof new Date() -&gt; objecttime.getFullYear() 获取四位数整年time.getMonth() 获取月份time.getDate() 获取日time.getDay() 获取星期(0-6代表周日-周六)time.getHours() 获取小时time.getMinutes() 获取分钟time.getSeconds() 获取秒time.getMilliseconds() 获取毫秒time.getTime() 获取当前日期距离'1970-01-01 00:00:00'的毫秒差 123var time = new Date('2017-10-22'); // 当new Date 中传递一个时间格式的字符串，相当于把这个字符串换位标准时间对象// (转换完成后，就可以调取上面我们讲的那些方法) // 时间格式的字符串‘2017-10-22’ (IE下识别不了)‘2017/10/22 16:15:34’‘1508659621314’(如果传递的是距离1970年那个毫秒查，也可以识别转换的,但是只能是数字，不能是字符串)","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"8.字符串及常用的方法","slug":"JavaScript基础入门/8 字符串及常用的方法","date":"2019-04-10T05:10:04.000Z","updated":"2019-06-06T15:45:14.000Z","comments":true,"path":"2019/04/10/JavaScript基础入门/8 字符串及常用的方法/","link":"","permalink":"http://yoursite.com/2019/04/10/JavaScript基础入门/8 字符串及常用的方法/","excerpt":"","text":"在js中用单(双)引号包裹起来的都是字符串 1var str = &apos;welcome to credan!&apos; 字符串就是由零到多个字符串组成的 第一个字符索引0第二个字符索引1…有length的属性，存储的是当前字符串中字符的个数(字符串的长度) 以数字作为索引，从零开始的 str[0] -&gt; ‘w’ 第一个字符strlength-&gt; 46str[str.length-1] -&gt; ‘!’ 最后一个字符str[100] -&gt; undefined 如果指定的索引不存在获取的结果是undefined 真实项目中，我们经常操作字符串，此时我们需要掌握常用的一些字符床操作方法 console.dir(String.prototype) charAt &amp;&amp; charCodeAt str.charCodeAt(索引)在charAt 基础上，把获取的字符变为Unicode编码值(对应ASCll码表) 48-57 0-9 65-90 A-Z 97-122 a-z … String.fromCharCode(十进制的Unicode值)，把值按照ascll码表中的信息，转为原有字符，charCodeAt正好对应 substr &amp;&amp; substring &amp;&amp; slice 实现字符串截取的三个办法 str.substr(n.m) : 从索引n开始，截取m个字符 str.substring(n,m):从索引n开始，截取到索引为m处(包含m)，把找到的部分截取 str.slice(n,m):和substring语法意义，区别在于slice支持一负数做索引 当索引是负数的时候，浏览器在处理的时候，是用字符串的总长度加上负数索引，然后按照正数处理操作 细节: 如果只传递了n(str.substr(n)/str.substring(n)),相当于索引n开始的一直截取到字符串的末尾 如果传递的索引超出最大限制，也是吧能截取的部分截取掉即可 如果一个参数都不传递:相当于吧证书字符串都截取(字符串的克隆) indexOf &amp;&amp; lastIndexOf str.indexOf 获取当前字符在字符串中第一次出现位置的索引 str.lastIndexOf 获取的是最后一次出现位置的索引 如果当前字符在字符串中没有出现过，结果是-1:我们根据这个规律可言验证一下当前字符串中是否包含某个字符 1234567if(str.indexOf(&apos;?&apos;)===-1)&#123; // =&gt; 没有出现过&#125;if(str.indexOf(&apos;?&apos;)&gt;=-1)&#123; // =&gt; 出现过&#125; split str.split 按照某个字符串分成数组中的某一项，和数组中的join方法是对应 replace str.replace 实现字符的替换执行一次replace 只能替换一次，如果有好几个都需要替换，在不适用正则的情况下，我们需要执行很多次replace 有些需求及时执行很多次repalce也实现不了，此时需要使用正则处理，真实项目中replace一般都是和正则搭配使用的 trim &amp;&amp; trimLeft &amp;&amp; trimRight str.trimLeft : 去除字符串开始的口空格 str.trimRight : 去除字符串结尾的口空格 str.trim 去除字符串首位的空格 获取地址栏的值 123456789101112131415function queryURLPrameter(url)&#123; // =&gt; url 传递的参数 var quesIndex = url.indexOf('?'), obj = &#123;&#125; if(quesIndex === -1)&#123; // url中没有问号传参 直接返回空 retrun obj; &#125; url = url.substr(quesIndex + 1); var ary = url.split('&amp;'); for(var i =0;i&lt;ary.length;i++)&#123; var curAry = ary[i].split('='); obj[curAry[0]] = curAry[i]; &#125; return obj&#125; 123456789101112String.prototype.myQueryURLParameter = function myQueryURLParamter()&#123; var obj = /([^=?&amp;]+)=([^=?&amp;]+)/g; this.replace(reg,function()&#123; var arg = argments; obj[arg[1]] = arg[2] &#125;) return obj;&#125;var str = 'https://www/baidu.com/s?wd=1233213&amp;issp=1';console.log(str.myQueryURLParameter());","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"7.Math的常用方法","slug":"JavaScript基础入门/7 Math的常用方法","date":"2019-04-10T03:10:04.000Z","updated":"2019-06-06T15:42:55.000Z","comments":true,"path":"2019/04/10/JavaScript基础入门/7 Math的常用方法/","link":"","permalink":"http://yoursite.com/2019/04/10/JavaScript基础入门/7 Math的常用方法/","excerpt":"","text":"数学函数 但是他是对象数据类型的 ‘object’ Math对象中给我们提供了很多常用操作数字的方法 console.dir(Math) // 查看所有方法 abs Math.abs 取绝对值 cell / floor cell: 向上取整floor: 向下取整 round round: 四舍五入 random random: 获取一个[0,1]之间的一个随机小数 max/minx max 获取一组值中的最大值minx 获取一组值中的最小值 PI Math.PI 获取圆周率 pow / sqrt pow 获取一个值的多少幂sqrt 获取一个值的开平方","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"6.JS的DOM获取节点","slug":"JavaScript基础入门/6 JS的DOM获取节点","date":"2019-04-09T09:10:04.000Z","updated":"2019-06-06T15:40:50.000Z","comments":true,"path":"2019/04/09/JavaScript基础入门/6 JS的DOM获取节点/","link":"","permalink":"http://yoursite.com/2019/04/09/JavaScript基础入门/6 JS的DOM获取节点/","excerpt":"","text":"DOM:document object model 文档对象模型，提供一些属性和方法可以让我们去操作DOM元素 节点介绍 node 节点，浏览器默认在一个html页面中的所有内容都是节点(包括标签、注解、文字文本等) 元素节点:HTML标签 文本节点:文字内容(大部分浏览器会把空格和换行也当做文本节点) 注解节点 document文档节点 元素节点 nodeType:1 属性含有某个节点的名称 nodeName: 大写标签名(在部分浏览器的怪异模式下，我们写的标签名是小写，它获取的就是小写…) 对于元素节点，因为本身不直接包含文本，所以nodeValue是不可用的。当然你也可以在示例中自己写试试看有什么结果出现。 对于文本节点，nodeValue=文本值 对于属性节点，nodeValue=属性值 nodeValue:null 对于元素节点，nodeType=1 对于文本节点，nodeType=3 对于属性节点，nodeType=2 对于注释元素，nodeType=8 对于文档元素，nodeType=9 [curEle].tagName:获取当前元素的标签名(获取的标签名一般都是大写) 文本节点 nodeType:3nodeName:#textnodeValue:文本内容 注释节点 nodeType:8nodeName:#commentnodeValue:注释内容 文档节点 nodeType:9nodeName:#documentnodeValue:null 1234567891011&lt;-- div#box&gt;(ul&gt;li&#123;0$&#125;*3)+div&#123;内容$&#125;*3--&gt;&lt;div id=\"box\"&gt; &lt;ul&gt; &lt;li&gt;01&lt;/li&gt; &lt;li&gt;02&lt;/li&gt; &lt;li&gt;03&lt;/li&gt; &lt;/ul&gt; &lt;div&gt;内容1&lt;/div&gt; &lt;div&gt;内容2&lt;/div&gt; &lt;div&gt;内容3&lt;/div&gt; &lt;/div&gt; 获取dom元素document.getElementById 一个元素 此方法的上下文只能document 一个html页面中元素的id理论上是不能重复的,如果页面中ID重复了，我们获得结果第一个id对应的元素对象 在ie7更低的版本浏览器中，会把表单元素的name值当做id来识别使用(项目中尽量不要让表单的name和其他元素的id相同) 如果我们把js放在结构的下面，我们可以直接使用id值获取这个元素(不需要通过getElementById获取)，而且这种方式会把页面中所有id是他的元素都获取到(元素对象，或者集合) =&gt; 不推荐 1234&lt;div id=\"box1\"&gt;&lt;/div&gt;&lt;div id=\"box2\"&gt;&lt;/div&gt;&lt;div id=\"box1\"&gt;&lt;/div&gt;&lt;script&gt; console.log(box1) // -&gt; [div#box1, div#box1, box1: div#box1]&lt;/script&gt; 1234&lt;input id=\"myInput\" type=\"text\" size=\"20\"/&gt;&lt;br /&gt;&lt;script&gt; var x=document.getElementsByName(\"myInput\");&lt;/script&gt; document.getElementClassName 元素集合 上下文是可以自己来指定 获取到的结果是一个元素集合(类数组集合) 获取的结果是集合，哪怕集合中只有一项，我们想要操作的是这一项(元素对象)，需要先从集合中获取出来，然后再操作 但是真实的项目中我们经常会通过样式类名获取元素，getElementClassName这个方法在ie6-8不兼容的 1234567&lt;input name=\"myInput\" type=\"text\" size=\"20\"/&gt;&lt;br /&gt;&lt;script&gt; var x=document.getElementsByName(\"input\");&lt;/script&gt;var bodyBox = document.getElementsByTagName('body');bodyBox[0].getElementsByTagName('div'); document.getElementsTagName 元素集合1234&lt;input name=\"myInput\" type=\"text\" size=\"20\"/&gt;&lt;br /&gt;&lt;script&gt; var x=document.getElementsByName(\"input\");&lt;/script&gt; document.getElementsByName 节点集合 通过元素的NAME属性值获取一组元素（类数组：节点集合NodeList）他的上下文只能是document IE浏览器只能识别表单元素的name属性值，所以我们这个方法一般都用来操作表单元素的 获取html获得body的元素对象1234&lt;input name=\"myInput\" type=\"text\" size=\"20\"/&gt;&lt;br /&gt;&lt;script&gt; var x=document.getElementsByName(\"myInput\");&lt;/script&gt; domcument.domcumentElement 获取整个html的对象123document.documentElement.clientWidth||document.body.clientWidth// 获取当前浏览器可视区域的宽度(当前页面一个屏幕的宽度)// =&gt;clientHieght 获取高度 domcument.body 获取body对象domcument.head 获取整个head对象[context]querySelector 一个元素对象 / [context]querySelectorAll 获取元素集合 ie6-8不兼容，而且没有特别好的办法处理他的兼容，所以这两个方法一般多用于移动端开发使用 querySelector 获取一个元素对象querySelectorAll 获取的一个元素集合只要css支持的选择器，这里大部分都支持 12345document.querySelector('#box1');document.querySelectorAll('.box1');document.querySelectorAll('div');document.querySelectorAll('body&gt;div');document.querySelectorAll('#box1 li'); 节点关系属性 节点是用来描述页面中每一部门之间关系的,只要我可以获取页面中的一个页面，那么我就可以通过相关的属性和方法获取页面中所有的节点 childNodes 获取当前元素所有的子节点(节点集合:类数组)注:不仅仅是元素子节点，文本、注释等都会包含在内:子节点说明只是在儿子辈分中查找 children 获取所有的元素子节点(元素集合)在IE6-8下获取的结果和标准浏览器中有区别(IE6-8中会把注释点当做元素节点获取到) pareNode 获取当前元素的父节点(元素对象) previousibing 获取当前节点的上一个各个节点上一个哥哥节点(不一定是元素节点也可能是文本或者注释) nextibling 获取当前节点的下一个弟弟节点 previousElementbling 获取当前节点的上一个哥哥元素节点 nextElementsIbling 获取当前节点下一个弟弟元素节点IE6-8不兼容 firstChild 当前元素所有子节点中的第一个(也不一定是元素节点，可能是文本和注释) lastChild 当前元素多有子节点中的最后一个fistElementChild lastElementChild(IE6-8兼容) 创建和增加DOM元素 真实项目中，我们偶尔会在js中动态创建html标签，然后把其增加到页面中 document.createElement 在js中动态创建一个html标签 appendChild 容器.appendChild(新元素)把当前创建的新元素添加到容器的末尾位置 inserBefore 容器.inserBefore(新元素、老元素)在当前容器中，把新创建的元素增加到老元素之前 12345678// 创建var oDiv = document.createElement('div');oDiv.id='div1';oDiv.className = 'box';// 添加到页面中document.body.appendChild(oDiv);document.body.inserBefore(oDiv,box2); 123456789var link = document.createElement('a');link.href = 'http://www.baidu.com?name=1&amp;age=2#haha'consloe.dir(link);// hash:存储饿哈希值 '#haha'// hostname:域名 'www.baidu.com'// pathname:路径 '/stu/'// protocol:协议 'http:'// search:问号传递参数值 '?nname=1&amp;age=2' 真实项目中很多需要通过动态创建元素来完成的，其中有一个需求:解析一个url地址每一部分的信息(包括问号传值的参数值) 纯字符串拆分截取 编写强大的正则，捕获到需要的结果 通过动态创建一个a标签，利用a标签的一些内置属性来分别获取每一部分的内容 12345678910111213141516function queryURLParameter(url)&#123; var link = document.createElement('a'); link.href=url; var search = link.search, obj = &#123;&#125;' if(search.length===0) return; search = search.substr(1).split(/&amp;|=/g); for(var i=0;i&lt;search.length;i+=2)&#123; var key = search[i], value = search[i+1]; obj[key]=value; &#125; link = null; return obj;&#125; 修改删除克隆DOM元素removeChild 容器.removeChild(元素) 在当前容器中把每一个元素移出掉 replaceChild 容器.removeChild(新元素，老元素) 把原有的元素克隆一份一模一样的，false:只克隆当前元素本身，true:深度克隆，吧当前元素本身以及元素的所有后代都进行克隆[set/get/remove]Attribute 1234给当前元素设置/获取/移出属性的(一般操作的都是它的自定义属性)box.setAttribute('myIndex',0)box.getAttribute('myIndex')box.removeAttribute('myIndex') 使用xxx.index=0 和xxx.setAttribute(‘index’,0)这两种设置自定义属性的区别 xxx.index : 是吧当前操作的元素当做一个普通对象，为其设置一个属性名xxx.setAttribute:把元素当做特殊的元素对象来处理，设置的自定义属性是和页面结构中的DOM元素映射在一起的 JS中获取的元素对象，我们可以把他理解为两种角色: 与页面HTML结构无关的普通对象 与页面HTML结构存在映射关系的元素对象 元素对象中的内置属性，大部分都和页面的标签存在映射关系:xxx.style.backgroundColor = ‘xxx’ 此时不仅把js中对象对应的属性值改变了，而且也会映射到页面的html标签上(标签中有一个style行内样式，元素的样式改变了)xxx.className = ‘xxx’此时不仅是吧js对象中的属性值改变了，而且页面中的标签增加了class样式类(可以看见的) 元素对象中的自定义属性: xxx.index=0仅仅是吧js对象中增加了一个属性名(自定义的)，和页面中的html没啥关系(在结构上看不见) xxx.setAttribute:通过这种方式设置的自定义属性和之前提到的内置属性差不多，都是和html结构存在映射关系的(设置的自定属性可以呈现在结构上) 6.6 面试题 把当前页面中所有id叫做box1的都获取到 1234567var allList = document.getElementsByTagName(*);var result = []for(var i=0;i&lt;allList.length;i++)&#123; var item = allList[i]; item.id === 'box1'?result.push(item)&#125;console.log(result) 获取当前元素的上一个哥哥元素节点(兼容所有的浏览器)curEle:current element 123456789101112131415161718// 首先获取当前元素的上一个哥哥节点，判断当前获取的节点是否为元素节点(nodeType===1)// 如果不是基于当前获取的节点，找他的上一个哥哥节点..(找几次不知道)一直到找到的节点是元素节点为止// 如果在查找过程中，发现没有上一个哥哥节点，找到头了，则不再继续查找function prev(curEle)&#123; var p = curEle.previousSibling; // 属性返回同一树层级中指定节点的前一个节点。 while(p&amp;&amp;p.nodeType!==1)&#123; //p:p!=null p = p.previousSibling; &#125; return p;&#125;// 扩展// next: 获取下一个弟弟元素节点// prevAll:获取所有的哥哥元素节点// nextAll:获取所有的弟弟元素节点// siblings:获取所有的兄弟元素节点// index:获取当前元素的兄弟中排名索引","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"5.JS中常见的操作的语句","slug":"JavaScript基础入门/5 JS中常见的操作的语句","date":"2019-04-09T08:10:04.000Z","updated":"2019-06-06T15:36:09.000Z","comments":true,"path":"2019/04/09/JavaScript基础入门/5 JS中常见的操作的语句/","link":"","permalink":"http://yoursite.com/2019/04/09/JavaScript基础入门/5 JS中常见的操作的语句/","excerpt":"","text":"if、else if 、else 判断操作语句 123456789if(条件1)&#123; //=&gt;条件1成立执行的操作&#125;else if(条件2)&#123; //=&gt;上面条件不成立，条件2成立，执行的操作&#125;...else&#123; // =&gt; 以上条件都不成立执行的操作&#125; 如果好几个条件都成立了，只吧第一个成立的条件执行，后面成立的条件忽略不管条件: 123456789A==B、A!=B、A&gt;B、A&lt;Bif(A)&#123;&#125; // 先把A转换为布尔类型，判断真假以此来决定是否成立//否成立if(A&gt;B&amp;&amp;A&lt;10)&#123;&#125; //只有两个小条件都是真，整体条件为真if(A&gt;B||A&lt;10)&#123;&#125; // 只要其中一个小条件成立，整体条件是真 BAT 面试题 12345678910var num = parseFloat('width:12.5px');if(num==12.5)&#123; // =&gt;NaN alert(12.5);&#125;else if(num==NaN)&#123; // NaN!=NaN alert(NaN);&#125;else if(typeof num=='number')&#123; // alert(0)&#125;else&#123; alert(\"啥也不是\")&#125; 三元运算符 条件？条件成立执行：条件不成立执行 if(条件){}else : 三元运算符就是这种简单if..else..的另一种写法 123456789var num = 10;if(num&gt;5&amp;&amp;num&lt;10)&#123; num++;//累加1&#125;else&#123; num--;&#125;// 修改成为三元运算符,如果条件成立或者不成立的某一种情况并不需要什么处理// 我们空着语法不符合，我们使用null、undefined、void 0(就是undefined)占位就可以num&gt;5&amp;&amp;num&lt;10?num++:num--; 123456789var num = 10;if(num&gt;5 &amp;&amp; num&lt;10)&#123; num++; break;/continue;/return;&#125;// =&gt; 修改成为三元运算符// 在三元运算符的操作中不能出现break、continue、return这样的关键词，所以我们无法用三目代替if、elsenum&gt;5 &amp;&amp; num&lt;10?(num++,return):null; swith case swith case应用于if、else中一个变量在不同值情况下的不同操作 123456789101112131415var num =10;switch(num)&#123; //switch后面小括号中存放的是一个值(一般我们都写变量;把变量存储的值拿来用，有时候也可能是一个计算) case 1: // case后面放的都是值，目的验证switch后面的值和哪一种case后面的值相等，相等的进行对应的处理 ... break; // 每一种case借宿后都要加break借宿当前的判断 case 10: ... break; default: // switch后面的值和每一种case情况对应的值都不相等，执行最后的default，类似于false ...&#125; 案例分析 123456789101112var num = 5;switch(num%2)&#123;//=&gt;先把取余操作进行运算，拿运算结果case比较 case 0: num++; break; //不加break，不管后面的条件是够成立，都会继续向下执行，知道遇到break为止 // 不加break，就可以实现||这样的操作 case: 2-1: //case后面也应该是值，此处先把2-1计算，把计算的结果和switch值比较 num--; // 最后一项可以不加break，不加也能跳出判断 break;&#125;num%2:让num存储的值除以2去余数(0或者1) swich case 中的比较实用的”===” =:赋值，等号左边是变量，右边是值 ==:比较，如果左边两边的类型不一样，浏览器默认转换为一样的然后再进行比较 ‘6’==6 =&gt; 6==6 =&gt;true ===:绝对相等，不仅要求值一样，并且类型也要完全一样 循环操作语句 循环，重复做一件事情 123for(设置循环起始值；设置循环执行的条件；步长累加)&#123; // 循环体:重复做的事情都是在循环体重&#125; 设置初始值 验证条件 条件成立，执行循环体:不成立，循环借宿 步长累加 12345for(;i&lt;5;;)&#123; consloe.log(i); //没有步长累加，我们的i永远是0，循环条件永远成立“死循环”; //项目中不能出现死循环，一旦出现,循环下面的事情都做不了&#125; continue 结束本轮循环，继续执行下一轮:循环体重continue后面的代码都不会在执行，它会直接的去执行步长，然后进行下一轮 1234for(var i=0;i&lt;5;i+=2)&#123; console.log(i) continue;&#125; break 结束整个循环:循环体重一旦遇到break首先后面代码不执行了，而且步长累加也不执行了，循环都结束了 1234for(var i=0;i&lt;5;i+=2)&#123; console.log(i) break;&#125; BAT面试题 1234567891011for(var i=1;i&lt;10;i+=2)&#123; if(i&lt;5)&#123; i++; continue; &#125;else&#123; i+=3; break; &#125; console.log(i)&#125;console.log(i) // =&gt;10 for in 用来遍历(循环)对象键值对的 var key;var attr(attribute); 对象中有多少键值对，我们的for in 循环遍历多少次(多少次) 第一次循环key这个遍历存储的都是当前循环这个组键值队的属性名 key存储的值都是字符串格式的(不管属性名是否为数字) 在for in 循环的遍历时候，大部分浏览器都是先把对象中的键值对进行排序(把数字属性的排在前面，并且排列的时候安卓数字由小达大排列),其次在把非数字的属性名按照之前编写的顺序，循环的时候按照重新排列循序一次遍历(小数算作字母不要做数字) 123456789101112131415var obj = &#123;name:wjw,age:8,0:'wjh',3:'ylp',1:'cx'&#125;for(var key in obj)&#123; console.log('ok') // key 属性名 string console.log(obj.key) //获取obj中key这个属性对应的值 -&gt;undefined &lt;=&gt; obj['key'] console.log(obj[key]); //-&gt;每一次循环把key变脸存储的值(当前遍历的属性名)获取到放在中括号中，获取obj对应的属性值&#125;for(var key in obj)&#123; if(obj.hasOwnProperty(key))&#123; &#125; &#125;","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"4.JS数据类型","slug":"JavaScript基础入门/4 JS数据类型","date":"2019-04-09T08:10:04.000Z","updated":"2019-06-06T15:33:16.000Z","comments":true,"path":"2019/04/09/JavaScript基础入门/4 JS数据类型/","link":"","permalink":"http://yoursite.com/2019/04/09/JavaScript基础入门/4 JS数据类型/","excerpt":"","text":"数据类型基本数据类型（值类型） Number 数字 String 字符串 单引号包裹起来的都是字符串(单双号没有区别) Boolean 布尔 true false =&gt; 布尔值只有两个值 null 空对象指针 undefined 未定义 引用数据类型 {} 普通对象 [] 数组 /^$/ 正则 … function数据类型 funciotn fn (){} 数据类型检查 typeof 用来检测数据类型的运算符 instanceod 检测某个实例是否属于这个类 constructor 获取当前实例的构造器 Object prototype.toSting.call() 获取当前实例的所属类信息 typeof操作符typeof 是用来检测给定变量的数据类型的操作符。对一个值使用 typeof 操作符可能返回下列某个字符串： 12345\"undefined\"\"boolean\"\"string\"\"number\"\"object\" // 如果这个值是对象或者null \"function\" 布尔值 Boolean() 把其他数据类型的值转化为布尔类型 只有0、Nan、null、undefined这五个数据值转换为布尔类型的false，其余的都会变成true 叹号在JS中海油一个作用：取反，先把值转换为布尔类型，然后再去取反 !! 在叹号取反的基础上取反，取反两次相当于没有操作，但是却已经其他类型值转化为布尔类型了，和Boolean是相同的效果 字符串 在JS中单引号和双引号包起来的都是字符串 12312 - &gt; number'12' -&gt; string'[12,23]' -&gt; string toString()第一种是使用几乎每个值都有的 toString()方法。多数情况下，调用 toString() 方法不必传递参数，但在调用数值的 toString()方法时，可以传递一个参数：输出数值的基数。默认情况下，toString() 方法以十进制格式返回数值的字符串表示。而通过传递基数，toString() 可以输出二进制、八进制、十六进制等。 123456var num = 10;alert(num.toString()); // \"10\"alert(num.toString(2)); // \"1010\"alert(num.toString(8)); // \"12\"alert(num.toString(10)); // \"10\"alert(num.toString(16)); // \"A\" 常用方法 number数字 0 12-22 12.5 js中多增加了一个number类型的数据NaN typeof NaN -&gt; Number 12345var intNum = 55; // 十进制整数 var octalNum1 = 070; // 八进制的56var octalNum1 = 079; // 无效的八进制数值——解析为79 var octalNum1 = 08; // 无效的八进制数值——解析为8 var hexNum1 = 0xA; // 十六进制的10var hexNum2 = 0x1F; // 十六进制的31 注意，八进制字面量在严格模式下是无效的，会导致抛出错误。 数值范围ECMAScript 能够表示的最小数值保存在 Number.MIN_VALUE 中——在多数浏览器中，这个值是 5e-324；能够 Number.MAX_VALUE 中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果某次计算的结果得到了一个超过JavaScript 数值范围的值，那么这个数值将会自动转换为 Infinity 值，如果这个数值是负数，则会转换成 -Infinity（负无穷），如果这个数值是正数，则会转换成Infinity（正无穷）。要确定一个数值是不是有穷的，可以使用 isFinite() 函数。 NaN not a numer : 不是一个数，但是属于number类型 NaN == NaN ： false , NaN 和任何其他值都不相等 isNaN() 用来检测当前这个值是否是非有效数字，如果不是有效数字，检测的结果是true , 反之是有效数字则为false 12isNaN(0) // -&gt;falseisNaN(NaN) // -&gt;true 当我们使用isNaN检测值的时候，检测的值不是number类型的，浏览器默认的吧值先转换为number类型，任何再去检测 1isNaN('12') //-&gt;false Number() 把其他数据类型值转化成number类型的值 12345678Number('12') // -&gt; 12Number('12px') // -&gt;NaN// 在使用Number转换的时候只要字符串中出现任何一个非有效数字字符，最后的结果都是NaNNumber(true) //-&gt; 1 Number(false) //-&gt; 0Number(null) // -&gt; 0Number(undefined) //-&gt;NaN 把引用数据类型转换成number，首先需要吧引用数据类型转为字符串（toString)，在把字符串转换为number即可 12345Number([]) // -&gt; \"\"Number([12]) // -&gt; 12Number([12,13]) // -&gt; 12,13 (,是非有效字符) -&gt; NaNNumber(&#123;age:12&#125;) // -&gt;NaNNumber(&#123;&#125;) // -&gt; NaN pareInt 也是吧其他数据类型值转换为number，和Number方法在处理字符串的时候有所区别 12Number('12px') // -&gt; NaNparseInt('12px') // -&gt; 12 提取规则：从左到右依次查找有效数字字符，知道遇到非有效数字字符为止（不管后端是否还有，都不找了） 1parseInt('12px13') // -&gt; 12 数值转换处理整数最常用的还是 parseInt() ，它会忽略字符前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt() 就会返回 NaN；也就是说，用 parseInt() 转换空字符串会返回 NaN 。如果第一个字符是数字字符， parseInt() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。如果字符以“0x”开头且后面跟数字字符，会被解析为 16 进制整数；以“0”开头且后面跟数字字符，会被解析为 8 进制整数。下面给出一些例子： 123456var num1 = parseInt(\"1234blue\"); // 1234var num2 = parseInt(\"\"); // NaNvar num3 = parseInt(\"0xA\"); // 10(十六进制)var num4 = parseInt(22.5); // 22var num5 = parseInt(\"70\"); // 70var num6 = parseInt(\"0xf\"); // 15(十六进制) pareFloat 在pareInt的基础上可以识别小数点 12pareInt('12.5px') -&gt; 12pareFloat('12.5px') -&gt; 12.5 null 和undefined null : 空，没有 undefined ：未定义，没有 “” : 空字符串，没有 0: 也可以理解为没有 空字符串和null的区别 都是去去种树 空字符串属于去挖了个坑，但是没有种任何东西 null属于连坑都没挖 空字符串相对于null来说开辟了内存地址，消耗了那么一丢丢的性能 null和undefined的区别 null一般都是暂时没有，预期中以后会有的(可能以后也没有达到预期)，在js中null都是手动先赋值为null，后期我们在给其赋具体值 undefined:完全没有预料之内的 Object 对象 ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性和（或）方法，就可以创建自定义对象，如下所示： 1var o = new Object(); 每一个对象都是由零到多组 属性名（key键）：属性值(value值) 组成的,或者说有多组键值对组成的，每一组键值对中间用逗号分隔 属性 描述这个对象特点特征的 1var obj =&#123;name:'wjw',age:8&#125;; 获取 某个属性名对应的属性值或者数字格式的 12obj.nameobj['name'] 存储 属性值可以是任何数据类型 对象名.属性名：忽略属性名的单双引号 对象名[属性名]：不能忽略单双引号 123// 如果属性名是数字如何操作obj.0 语法不支持obj[0] / obj['0'] 两种都支持 如果操作的属性名在对象中不存在，获取的结果是undefined 1obj.sex // -&gt;undefined 设置/修改 一个对象的属性名是不能重复的（唯一性），如果之前存在就是修改属性值的操作，反之不存在就是新的设置属性的操作 12obj.sex = '男';obj['age'] = 9; 删除假删除:让其属性赋值为null，但是属性还是对象1obj.sex = null; 真删除:把整个属性都在对象中暴力移出1delete obj.sex 基本数据类型 和 引用数据类型的区别 JS是运行在浏览器中的(内核引擎)，浏览器会为JS提供赖以生存的环境（提供给js代码执行的环境）=&gt; 全局作用域window(global) 123456789var a = 12;var b = a; // 把A变量存储的值赋值给Bb = 13;console.log(a);var n =&#123;name:'wjh'&#125;;var m = n;m.name = 'wjw'console.log(n.name) 基本数据类型是按值操作的：基本数据类型的赋值的时候，是直接把值赋值给变量即可 引用数据类型是按照空间地址（引用地址）来操作的: var n = {name:’wjw’} 先创建一个变量n 浏览器首先会吧开辟一个新的存储控件（内存控件），目的是吧对象中需要存储的内容（键值对）分别的存储在这个空间中，为了方便后期找到这个空间，浏览器给空间设定一个地址（16进制） 把空间的地址赋值给了变量 4.9 function数据类型 函数数据类型也要按照引用地址来操作的 函数:具备一定功能的方法 123456// =&gt; 创建函数:function 函数名()&#123; //=&gt; 函数体:实现某一个功能的具体JS代码&#125;// =&gt; 执行函数:相当于使用洗衣机洗衣服(如果函数只创建了，但是没有去执行，函数没有任何的意义)// 函数名() 12345function fn()&#123; console.log(1+1);&#125;fn; // =&gt; 输出函数本身fn(); // =&gt; 把函数执行（吧函数体重实现功能的代码执行） 形参：形式参数(变量)，函数的入口当我们创建一个函数想要实现个功能的时候，发现有一些材料不清楚，只有当函数运行的时候，别人传递给我，我才知道，此时我们就需要设定入口,让用户执行的时候通过入口把值把我们 123456function fn(num1,num2)&#123; console.log(num1+num2)&#125;// 实参:函数执行传递给函数的具体值就是实参fn(1,2);fn(10,20); 数据类型转换把其他数据类型转换为number类型-&gt; isNaN、Number、pareInt、parseFloat-&gt; 在进行数据加减乘除数学运算的时候 1234567891011// true -&gt; 1 false-&gt;0// ''-&gt;0 '12'-&gt;12 '12px'-&gt;NaN/12// '小伙子'-&gt;NaN// null -&gt; 0 // undefined-&gt; NaN&#123;&#125; /^$/ function() -&gt;NaN[][12]-&gt;'12'-&gt;12['12,13']-&gt;'12,23'-&gt;NaN// =&gt; 引用数据类型转换为数字// 通过toString方法把数组转换为字符串，然后在调用Number转换为数字 JS中的数据运算 +、-、*、/加减乘除 除了加法有特殊性，其余的运算符都是数学运算，也是遇到非数字类型，需要把其转换为number再运算 12341-&apos;1&apos; -&gt; 010*null -&gt; 010/undefined -&gt; NaN10*[10]-&gt;100 加法的特殊性: 在遇到字符串的时候，+不是数学运算，而是字符串拼接，只要不遇到字符串就是数学运算 121+&apos;1&apos; -&gt; &apos;11&apos;null+&apos;1&apos; -&gt; ‘null1’ 字符串拼接:是把其它的值转换为字符串然后再拼接(toString) 其它数据类型的toString是直接的把值用单(双)引号包起来极客，只有对象的特殊性，对象的有特殊性，对象.toStirng===’[Object Object] 将其它数据类型转换为布尔类型 Boolean、！、！！ 在条件判断的时候、也是转换为布尔类型，然后验证条件的真假 只有0、NaN、空字符串、null、undefined五个转换为false、其余的都是转换为true 12345678910111213[] -&gt; true-1 -&gt; trueif(box)&#123; // =&gt; 首先把box变量存储的值获取到，转化为布尔类型，如果为true条件成立，反之不成立&#125;if(3+&apos;3px&apos;)&#123; // 条件成立: 3 + &apos;3px&apos; = &apos;33px&apos; &#125;if(3-&apos;3px&apos;)&#123; // 条件不成立: 3-&apos;3px&apos; = NaN&#125; 在使用==进行比较的时候 在使用==进行比较的时候，如果左右两边的数据不相同，浏览器默认转换为相同的类型，然后在比较(‘===’不会这样操作) 12345// 对象和对象: 应用数据类型比较的空间地址不一样，不是一个空间[] == [] -&gt; falsevar a =&#123;&#125;var b = a;a==b -&gt; true 对象和数字:吧对象转换成数字123[]== 0 -&gt; true(&#123;&#125;)=== NaN -&gt; falseNaN和自己不相等和其它任何值都不相等 对象和字符串:把两边都转换为数字比较的1[]===&apos;&apos; -&gt; true 对象和布尔值:把两边都转换成数字1234[]==true -&gt; 0==1 -&gt;false[]==false -&gt; 0==0 -&gt;true![]==false -&gt; ![] -&gt;把数组变成为布尔在取反=falsefalse=false -&gt; true 字符串和数字:字符串转换为数字字符串和布尔:都转为数字布尔和数字:布尔转换为数字 规律:两个等于号比较，左右两边数字值的类型不一样，浏览器会吧两边的类型都转换为数字然后再比较，但是null和undefined除外null==undefined -&gt; truenull===undefined -&gt; falsenull 和 undefined 和其它任何都不相等null==0 -&gt; false null以及undefined和其它任何值都不相等","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"3.JS定义值","slug":"JavaScript基础入门/3 JS定义值","date":"2019-04-09T07:10:04.000Z","updated":"2019-06-06T15:27:25.000Z","comments":true,"path":"2019/04/09/JavaScript基础入门/3 JS定义值/","link":"","permalink":"http://yoursite.com/2019/04/09/JavaScript基础入门/3 JS定义值/","excerpt":"","text":"语法ECMAScript 的语法大量借鉴了 C 及其他类 C 语言（如 Perl 和 Java）的语法。区分大小写 注释123456// 单行注释/** 这是一个多行* （块级）注释*/ 严格模式严格模式ES5 引入了严格模式的概念，在严格模式下，ES3 中的一些不确定行为将得到处理，而且队某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码：这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的JavaScript引擎切换到严格模式。在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行: 123function doSomething()&#123; \"use strict\"; //函数体&#125; 变量、常量 变量是可以变得常量是不可变的 变量 变量其实只是一个无意义的名字，它所代表的意义都是其存储的那个值 让原有的num变量存储的值修改为13（变量只能代表一值） js定义变量的方法 1234// var 变量名 = 值;var num = 12;var name = 'wjw' 常量 任何一个具体的数据都是常量，例如12是个常量 和变量累死，我们设置一个常量（也就是一个名字），给其存储一个值，但是这个存储的值不能修改 1const num = 12; JS中命名规范 JS中严格区分大小写 1234var test = 'wjw';var Test = 'wjh';console.log(test);// 输出test 遵循国际命名规则”驼峰命名法” 第一个单词首字母小写，其余每一个有意义单词首字母大写 123456789101112var studentInfo; // 学生信息// 所见即所得// 例子:/** info : information 信息* init : initlization 初始化* add/insert/create 增加插入创建* remove/rm/clear/del/delete 删除* update 修改* get/query/select : 查询获取*/ 命名的时候可以使用$、_、数字、字母，但是数字不能作为名字的第一位 123var student_info;var $xxx; //=&gt; 一般都是应用jq获得到的值var _xxx; //=&gt; 一般这样的情况代表变量是一个局或者公共的变量 JS中很多字都是有特殊含义的，我们这些词，叫做关键词；现在没有特殊含义，以后可能会作为关键的，我们叫做保留字；二关键词和保留字不可以随便用来命名；","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"2.JS常用的输出方式","slug":"JavaScript基础入门/2 JS常用的输出方式","date":"2019-04-09T06:10:04.000Z","updated":"2019-06-06T15:26:37.000Z","comments":true,"path":"2019/04/09/JavaScript基础入门/2 JS常用的输出方式/","link":"","permalink":"http://yoursite.com/2019/04/09/JavaScript基础入门/2 JS常用的输出方式/","excerpt":"","text":"弹窗输出alert 在浏览器中弹出一个提示框(提供确定按钮，点击确定弹窗消失) 使用alert弹窗信息，提示的内容最后都会转换成字符串(调用了toSring这个方法)123alert(1)alert(&#123;name:'wjw'&#125;) //=&gt; '[object Object]'alert([13,14]) //=&gt; '12,13' confirm 在alert基础上增加了让用户选择的操作(提供两个按钮:确定和取消) 当用户点击确定按钮的时候，我们接收到的结果是true，点击是取消按钮我们接受到的结果是false，此后我们可以根据结果来处理即可 12var wjw = confirm(\"are you sure\");alert(wjw); prompt 在confirm 基础上增加让用户增加输入的效果 用户点击取消按钮，我们获取到的结果是null,如果用户点击是确定按钮，我们将获取用户输入的信息 在真实的项目中，一般性会使用二次封装的弹窗，不会使用这种弹窗 123var flag = prompt(\"are you sure\");alert(flag) 控制台输出 控制台输出，方便开发调试 console 在控制台输出，优势不会转换数据类型，输出什么格式的数据都可以 1234console.log(&#123;name:'wjw'&#125;);console.dir() //比log输出更加详细一些console.table //把json数据展示成一个表格","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"1.导入JS","slug":"JavaScript基础入门/1 导入JS","date":"2019-04-09T05:10:04.000Z","updated":"2019-06-06T15:26:09.000Z","comments":true,"path":"2019/04/09/JavaScript基础入门/1 导入JS/","link":"","permalink":"http://yoursite.com/2019/04/09/JavaScript基础入门/1 导入JS/","excerpt":"","text":"三种常见导入行内导入JS(慎重：不安全)1&lt;div onclick=\"alert('hello world')\"&gt;&lt;/div&gt; 内嵌式123&lt;script&gt; alert('hello world')&lt;/script&gt; 外链式123456// 新建一个js文件&lt;script src=\"./js/demo.js\"&gt;&lt;/script&gt;// or&lt;script src=\"./js/demo.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 内嵌与外链不能同时操作 内嵌导入和外链导入不能合并在一起，如果当前是外链导入的，那么在script脚本块找那个编写的所有代码都不会被执行。 123&lt;script src=\"./js/demo.js\"&gt; alert('hello world')&lt;/script&gt; 位置编写位置 我们一般性会把css放在body的上面，把js放在body末尾(约定速成的规范) 但是如果放在了标签前面那么将如何处理? 页面加载完所有资源之后执行操作 在js中 123window.onload=function()&#123;&#125; 在jq中 12345678910$(document).ready(function()&#123;&#125;)window.addEventListener('load',function()&#123;&#125;,false);// ie8以下window.attachEvent('onreadystatechange',function()&#123;&#125;)","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"0.介绍","slug":"JavaScript基础入门/0 介绍","date":"2019-04-09T03:10:04.000Z","updated":"2019-06-06T15:21:28.000Z","comments":true,"path":"2019/04/09/JavaScript基础入门/0 介绍/","link":"","permalink":"http://yoursite.com/2019/04/09/JavaScript基础入门/0 介绍/","excerpt":"","text":"ECMAScriptECMA-262 的第 5 版是 JS 的第一个稳定版本，得到了各浏览器厂商的支持。 语法 类型 语句 关键词 保留字 操作符 对象 DOM 文档对象模型是针对 XML 但经过扩展用于 HTML 的 API 。DOM 把整个页面映射为一个多层次节点结构。HTML 或 XML 页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。document object model 文档对象模型，里面提供了一些属性和方法，可以让我们操作页面的元素 BOM 原则上讲，BOM只处理浏览器窗口和框架，但下面一些针对浏览器的 JS 扩展也被看做是BOM的一部分。browser object model 浏览器对象模型，里面提供了一些属性和方法，可以让我们操作浏览器。","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"3. 内容编码和加密解密方法","slug":"http与ajax入门笔记/3. 内容编码和加密解密方法","date":"2019-04-08T06:10:04.000Z","updated":"2019-06-06T14:55:06.000Z","comments":true,"path":"2019/04/08/http与ajax入门笔记/3. 内容编码和加密解密方法/","link":"","permalink":"http://yoursite.com/2019/04/08/http与ajax入门笔记/3. 内容编码和加密解密方法/","excerpt":"","text":"正常的编码解码(非加密)escape/uescape 主要就是把中文汉字进行编码的(一般只有js语言支持,也经常应用于前端页面通讯时间的中文汉字编码) encodeURL/decodeURL 基本上所有的编码语言都支持 encodeURlComponent/decodeURIComponent 和第二种方法非常的累死，区别在于 需求:我们url问号传递参数的时候，我们传递的参数值还是一个url或者包含很多特殊字符，此时为了不影响住要的url，我们需要把传递的参数值进行编码，使用encodeURLComponent处理 12345678910111213let str = 'http://www.baidu.com/?', obj=&#123; name:'wjw', age:9, url:'http://www.sogou.com/?x=1' &#125;// =&gt; 把obj中的每一项属性名和属性值拼接到url的末尾(问号传参的方式)for(let key in obj)&#123; str +=`$&#123;key&#125;=$&#123;obj[key]&#125;`; // =&gt; 不能使用encodeURL必须使用encodeURlComponent,原因是encodeURL不能编码&#125;console.log(str.replace(/&amp;$/g,'')); 也可以通过加密的方法进行编码解码1、可逆转加密(一般都是团队自己玩的规则)2、不可逆加密(一般都是基于MD5加密完成的，可能会把md5加密后的结果二次加密) 12345&lt;script src='js/md5.min.js'&gt;&lt;/script&gt;&lt;script&gt; hex_md5('0000') // \"c6f057b86584942e415435ffb1fa93d4\"&lt;/script&gt;","categories":[{"name":"http与ajax入门笔记","slug":"http与ajax入门笔记","permalink":"http://yoursite.com/categories/http与ajax入门笔记/"}],"tags":[{"name":"http与ajax入门笔记","slug":"http与ajax入门笔记","permalink":"http://yoursite.com/tags/http与ajax入门笔记/"}]},{"title":"2. AJAX","slug":"http与ajax入门笔记/2. AJAX","date":"2019-04-08T05:10:04.000Z","updated":"2019-06-06T15:16:43.000Z","comments":true,"path":"2019/04/08/http与ajax入门笔记/2. AJAX/","link":"","permalink":"http://yoursite.com/2019/04/08/http与ajax入门笔记/2. AJAX/","excerpt":"","text":"什么是ajax？async javastctip and xml,异步的js和xml xml:可扩展的标记语言 作用是通过存储数据的(通过自己扩展的标记名称清晰的展示出来数据结构) ajax值所以称为异步的js和xml,主要原因是:当初最开始用ajax实现客户端和服务器端数据通信的时候，传输的数据格式一般都是xml格式的数据，我们把他们称为异步js和xml(现在一般都是基于json格式进行数据传输) 123456789101112&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;root&gt; &lt;student&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;25&lt;/age&gt; &lt;score&gt; &lt;english&gt;90&lt;/english&gt; &lt;math&gt;90&lt;/math&gt; &lt;chinese&gt;90&lt;/chinese&gt; &lt;/score&gt; &lt;/student&gt;&lt;/root&gt; 异步的js 这里的异步不是ajax只能基于异步进行请求(虽然建议都是使用异步变成)，这里的异步特指的是局部刷新 局部刷新 vs 全局刷新 在非完全前后端分离项目中，前端开发只需要完成页面的制作，并且把一些基础的人机交互效果使用js完成即可，页面中需要动态呈现内容的部分，都是交给后台开发工程师做数据绑定和基于服务器进行渲染的(服务器端渲染) [优势] 动态展示的数据在页面的原代码中可以看见，有利于seo优化推广(有利于搜索引擎的收录和抓取) 从服务器获取的结构就已经是最后要呈现的结果了，不需要客户端做额外的事情，所以也没加速快(前提是服务器端处理的速度够快，能够处理过来)，所以类似于京东、淘宝这些网站，首屏数据一般都是由服务器渲染的 [弊端] 实时更新的数据，每一次想要展示最新的数据，页面都要重新的刷新一次，这样肯定不行 都交给服务器端做数据渲染，服务器端的压力太大，如果服务器处理不过来，页面呈现的速度更慢(所以京东、淘宝这类网站,除了首屏是服务器端渲染的，其他屏一般都是客户端做数据渲染绑定) 这种模式不利于开发(开发效率低) 目前市场上大部分项目都是前后端完全分离的项目(也有非完全前后端分离的) 前后端完全分离前后端完全分离的项目，页面中需要动态绑定的数据是交给客户端完全渲染的 想服务器端发送ajax请求 把从服务器端获取的数据解析处理，拼接成为我们需要展示的html字符串 把拼接好的字符串替换页面中某一部分的内容(局部刷新),页面整体不需要重新加载，局部渲染极客 [优势] 我们可以根据需求，任意修改页面中某一部分的内容(例如实时刷新),整体页面不刷新，性能好，体验好(所有表单验证，需要实时刷新的等需求都要基于ajax实现) 有利于开发，提高开发的效率 前后端的完全分离，后台不需要考虑前端如何实现，前端也不需要考虑后台用什么技术，真正意义上实现了技术的划分 可以同时进行开发:项目开发开始，首先制定前后端数据交互的结构文档(文档中包含了，调用哪个接口或者那些数据等协议规范),后台吧接口线写好(目前很多公司也需要前端自己拿node来模拟这些接口)，客户端按照接口调取极客，后端再去实现接口功能极客 [弊端] 不利于seo优化:第一次从服务器端获取的内容不包含需要动态绑定的数据，所以也没的原代码中没有这些内容，不利于seo收录，后期听过js添加到页面中的内容，并不会写在页面的源代码中(是源代码不是页面结构) 交由客户端渲染，首先需要把页面呈现，然后通过js的异步ajax请求获取数据，然后数据绑定，浏览器在动态增加部分重新渲染，无形中浪费了一些时间，没有服务器端渲染页面呈现速度快 ajax请求12345678910111213141516let xhr = new XMLHttpRequest();// 不兼容ie6以及更低版本的浏览器(ie6 activeXobject)// 打开请求地址(可以理解为一些基础配置，但是并没有发送请求呢)xhr.open([method],[url],[async],[username],[user password]);// 监听ajax改变，获取响应信息(获取响应头信息，获取响应主体信息)xhr.onreadystatechange=()=&gt;&#123; if(xhr.readyState===4 &amp;&amp; xhr.readyState===200)&#123; let result = xhr.responseText;// 获取响应主体中的内容 &#125;&#125;// 发送ajax请求(括号中传递的信息内容是请求主体的内容)xhr.send(null) 分析第二部分的细节点 1xhr.open([method],[url],[async],[username],[user password]); ajax请求方式（method） get系列的请求 get delete head … post系列的请求(推送) post put:想服务器中增加指定的资源文件 … 不管哪一种请求方式,客户端可以吧信息传递给服务器，服务器也可以吧信息返回给客户端，只要get系列一般以获取为主(给的少) 我们想获取一些动态展示的信息，一般使用GET请求，因为只需要向服务器发送请求，告诉服务器端想要什么，服务器端就会把需要的数据返回 在实现注册功的时候，我们需要把客户端输入信息发送给服务器进行存储，服务器一般返回成功是成功等状态，此时我们一般都基于post请求完成 …. get系列请求和post系列请求，在项目是在中存在很多的区别 get请求传递给服务器的内容一般贸易post请求传递给服务器的内容多 原因:get请求传递给服务器内容一般都是基于url地址问号传递参数 来实现的，而实现的，而post请求一般都是基于设置请求主体来实现的。浏览器都已自己的关于url的最大长度限制(谷歌:8kb、火狐:7kb、ie:2kb)超过限制长度的部分，浏览器会自动截取掉，导致传递给服务器的数据缺失 理论上post请求通过主体传递是没有大小限制，真实项目中为了保证传输的速度，我们会限制大小(例如:上传的资料或者图片我们会做大小的限制) get请求容易出现缓存(这个缓存不可控:一般我们都不需要)，而post不会出现缓存(除非自己做特殊处理) 原因:get是通过url问号传参传递给服务器信息，二post是设置请求主体 设置请求主体不会出现缓存，但是url传递参数就会了 1234567891011121314151617181920setTimeout(()=&gt;&#123; $.ajax(&#123; url:'getList?lx=news', success:result=&gt;&#123; // 第一次请求数据回来，间隔一分钟后，浏览器又发送一次请求， // 但是新发送，不管是地址还是传递的参数都和第一次不一样， // 浏览器很有可能会把上一次数据获取，而不是获取新的数据 &#125; &#125;);&#125;,60000)// 解决方案:每一次重新请求的时候，在URL的末尾追加一个随机数，保证每一次请求的地址不完全一直// 就可以避免是从缓存中读取的数据setTimeout(()=&gt;&#123; url:'getList?lx=news_='+Math.random() success:result=&gt;&#123; &#125;&#125;) GET请求没有post请求安全(post也并不是十分安全，只是相对安全)原因:还是因为get是url传递给服务器有一种比较简单的黑客技术:url劫持，也就是可以客户端传递给服务器劫持掉，导致信息泄露 2.4.2 url 请求数据的地址(api地址)，真实项目中，后台开发工程师会编写一个api文档，在api文档中汇总了获取那些数据需要使用哪些地址，我们按照文档操作即可 2.4.3 async 异步(sync同步)，设置当前ajax请求是异步还是同步的，不写默认是异步(true)，如果设置false，则代表当前请求是同步的 用户名和密码这两个参数一般不用，如果你请求的url地址所在服务器设定了访问权限，则需要我们提供通行的用户名和密码才可以(一般服务器都可以允许匿名访问的) AJAX状态码xhr.readyState unsent 未发送，只要创建一个ajax对象，默认值是零 opened 我们已经执行了xhr,open这个操作 headers_resceived 当前ajax的请求已经发送，并且已经接收到服务器端返回的响应头信息了 loading 响应主体内容正在返回的路上 done 响应主体内容已经返回到客户端 HTTP网络状态码 记录了当前服务器返回信息的状态 xhr.status 200成功，一个完整的http事务完成了(以2开头的状态码一般性都是成功) 3开头一般也是成功，只不过是服务器做了特殊的处理 301 moved permanently 永久转移(永久重定向) 302 move temporarily 临时转移(临时重定向，新的http版本中任务307是临时重定向) 一般用于服务器的负载均衡:当前服务器处理不了，我把当前请求临时交给其他的服务器处理(一般图片请求经常出现302,很多公司都有单独的图片服务器) 304 not modified 从浏览器缓存中获取数据 把一些不经常更新的文件或者内容缓存到浏览器中，下一次从缓存中获取，减轻服务器压力，也提高页面加载的速度 4开头的，一般性都是失败的，而且客户端的问题偏大 400:请求参数错误 401:无权限访问 404:访问地址不存在 5开头的，一般都是失败，而且服务器的问题偏大 500:internal Server Error 未知的服务器错误 503:Service Unavailable 服务器超负债 … 面试题 ajax中总共支持几个方法let xhr = new xmlHttpReques();console.dir(xhr); [属性]readyState:存储的是当前ajax的状态response/responseText/responseXML : 都是用来接收服务器返回的响应主体的内容，只是更具服务器返回内容的格式不一样，我们使用不同的属性接收即可responseText是最常见的，接收到结果是字符串格式的(一般服务器返回的数据都是json格式字符串)responXML:偶尔会用到，如果服务器返回的是xml文档数据，我们需要使用这个属性接收status:记录了服务器返回的http状态码statusText:对返回状态码的描述timeout:设置当前ajax请求的超时时间，假设我们设置时间为3000(MS)，从AJAX请求发送开始，3秒后响应主体内容还没有返回，浏览器会把当前ajax请求强行断开 [方法]abor():强行终端ajax请求getAllResponseHeaders():获取全部的响应头信息(获取的结果是一丢字符串文本)getResponseHeader(key):获取指定属性名的响应头部信息，例如:xhr.getResponseHeader(‘data’)获取响应头中存储的服务的时间open():打开一个url地址overridMimeType():重写数据的MIME类型send():发送ajax请求(括号中书写的内容是客户端请求主体吧信息传递给服务器)setRequestHeader(key,value):设置请求头信息(可以是设置自定义请求信息) [事件]onabort:当ajax被终端请求触发这个时间onreadstatechange:ajax状态发烧改变，会触发这个事件ontimeout:当AJAX请求超时，会触发这个事件… 12345678910111213141516171819202122232425262728293031323334let xhr = new XMLHttpRequest(();xhr.open('get','temp.json?_='+Math.random(),true);xhr.setRequesHeader('cookie','xxx'); // =&gt; 设置请求内容不能出现中文汉字xhr.timeout = 10;xhr.ontimeout=()=&gt;&#123; console.log('当前请求已经超时'); xhr.abort();&#125;xhr.onreadystatechange = () =&gt;&#123; let &#123;readyState:state,status&#125; = xhr; // 说明请求数据成功了 if(!/^(2|3)\\d&#123;2&#125;$/.test(status)) return // 在状态为2的时候就获取响应头信息 if(state === 2)&#123; let headerAll = xhr.getAllResponseHeaders(), serverDate = xhr.getResponseHeader('date');// 获取的服务时间是格林尼治时间(相比北京时间差不多差8小时) console.log(headerAll,new Date(serverDate)); return; &#125; // 在状态为4的时候就获取响应头信息已经回来了 if(state === 4)&#123; let valueText = xhr.responseText,// 获取到的结果一般都是json字符串(可以时间json.parse把其转换成json对象) valueXML = xhr.responseXML; // 获取到的结果是xml格式的数据，(可以通过xml的一些常规操作获取存储的指定信息) // 如果服务器返回的是xml文档，responseText获取的结果是字符串，而responseXML获取的是标准xml文档 console.log(valueText,valueXML); &#125;&#125;xhr.send('name=wjw&amp;age=23&amp;sex=man') AJAX中的同步和异步编程1234567let xhr = new XMLHttpRequest();xhr.open('get','temp.json',false);xhr.onredystatechange=()=&gt;&#123; console.log(xhr.readySate);&#125;xhr.send();// 只输出一次结果4 12345678910let xhr = new XMLHttpRequest();xhr.open('get','temp.json',false);xhr.send();// =&gt; 同步开始发送ajax请求，开启ajax任务，在任务没有完成之前，什么事情都做不了// 下面绑定时间也做不了 =&gt; loading =&gt; 当readyState ===4 的是ajax任务完成，开始执行下面的操作xhr.onreadystatechange=()=&gt;&#123; console.log(xhr.readySate);&#125;// 绑定方法之前状态已经为4了，此时ajax的状态不会再改吧其他值，所以事件永远不会被处罚// 一次都没有执行方法(使用ajax同步编程，不要把send放在事件监听前// 这样我们无法在绑定方法中获取响应主体的内容) let xhr = new XMLHttpRequest(); // 下面绑定时间也做不了 =&gt; loading =&gt; 当readyState ===4 的是ajax任务完成，开始执行下面的操作 xhr.onreadystatechange=()=&gt;{ console.log(xhr.readySate); if(xhr.readySate===1) { xhr.setRequestHeader('aaa','bbb'); } } xhr.open('get','temp.json',false); // xhr.readyState === 1 AJAX特殊处理的一件事:执行OPEN状态变为1,会主动把之前监听的方法执行一次 // 然后再去执行SEND xhr.send(); // xhr.redayState === 4 AJAX任务借宿，主任务队列完成 AJAX类库的封装 JQ中的AJAX url 请求api地址 method 请求方法get/post..在老板的jq中使用是type，使用type和method相同效果 dataType dataType只是我们预设获取结果的类型不会影响服务器的返回(服务器端一般给我们返回的都是json格式的字符串),如果我们预设是json,那么类库中将吧服务器返回的字符串转换为json对象，如果我们预设是text(默认值)，我们把服务器获取的结果直接拿过来操作即可，我们预设的值还可以xml等 cache 设置是否清楚缓存，只对get系列请求有作用，默认是true不清除缓存，手动设置false，jq类库在请求url的末尾最佳一个随机数来清楚缓存 data 我们通过data可以把一些信息传递给服务器，get系列请求会把data中的内容拼接在url的末尾通过问号传参的方式给服务器，post系列请求会把内容请求放在主题传递给服务器;data的值可以设置为两种格式，字符串、对象，如果是字符串，设置的值是传递给服务器的就是什么，如果设置成对象，jq会把对象变为xxx=xxx&amp;xx=xx,这样来数据传递 async 设置同步或者异步，默认是true代表异步，false代表同步 success dangajax请求成功后redayState===4&amp;&amp;statue是以2或者3开头的请求成功后jq会把传递的回调函数执行，并且获取的结果当做实参传递给回调函数(result就是我们从服务器获取的结果) error 请求错误触发回调函数 complate 不管请求还是错误的还是正确的都会触发这个回调函数(他就是完成的意思) …. 封装自己的AJAX库 url method/type data dataType async cache success ~funcction(){ class ajaxClass { // send ajax init() { let xhr = new XMLHttpRequest(); xhr.onreadustatechange = () =&gt; { if (!/^[23]\\d{2}$/.test(xhr.status)) return; if (xhr.redayState === 4) { let result = xhr.responseText; // DATA-TYPE switch (this.dataType.toUpperCase()) { case 'TEXT': break; case 'JSON': result = JSON.parese(result); break; case 'XML': result = xhr.responseXML; break; } this.success(result); } } // DATA if (this.data !==null) { this.formatData(); if (this.idGET) { this.url +=this.querySymbol()+this.data; this.data = null; } } // CACHE this.isGET ? this.cache(); xhr.open(this.method, this.url, this.async); xhr.send(); } cacheFn() { // THIS:EXAMPLE !this.cache ? this.url += `${this.querySymbol()}_=${Math.random()}` : null; } querySymbol() { // THIS:EXAMPLE return this.url.indexOf('?') &gt; -1 ? '&amp;' : '?'; } formatData(){ // THIS:EXAMPLE if(Object.prototype.toString.call(this.data)==='[Object Object]'){ let obj = this.data, str = ``; for (const key in obj) { if (object.hasOwnProperty(key)) { str +=`${key}=${obj[key]}`; } } str = str.replace(/&amp;$/g,''); this.data = str; } } } let ajax = function () {}; // init parameters window.ajax = function ({ url = null, method = 'GET', type = 'GET', data = null, dataType = 'JSON', cache = true, async = ture, suceess = null } = {}) { let _this = new ajaxClass(); // 创建实例 ['url', 'method','data','dataType','cache','async','success'].forEach((item)=&gt;{ if (item === 'method') { _this.method = type === null ? method : type; return; } if (item==='success') { _this.suceess = typeof success === 'function' ? success : new Function(); } _this[item] = eval(item); }) _this.isGET = /^(GET|DELETE|HEAD)$/i.test(example.method); _this.init(); return _this; }; }(); ajax({})","categories":[{"name":"http与ajax入门笔记","slug":"http与ajax入门笔记","permalink":"http://yoursite.com/categories/http与ajax入门笔记/"}],"tags":[{"name":"http与ajax入门笔记","slug":"http与ajax入门笔记","permalink":"http://yoursite.com/tags/http与ajax入门笔记/"}]},{"title":"1. HTPP","slug":"http与ajax入门笔记/1. HTPP","date":"2019-04-08T03:10:04.000Z","updated":"2019-06-06T14:47:05.000Z","comments":true,"path":"2019/04/08/http与ajax入门笔记/1. HTPP/","link":"","permalink":"http://yoursite.com/2019/04/08/http与ajax入门笔记/1. HTPP/","excerpt":"","text":"前端和后端如何通讯 前端:客户端后端:服务端 职业规划建议 培养自己的人脉圈，以及建立自己的影响力 状态自己的总和能力 经常参加一些活动 开放分享(做讲师分享自己的智慧、写组件的个人博客做技术分享) 当我们在浏览器地址中输入URL地址，到最后看到页面，中间经历了哪些事情？假设我们访问的是 https://www.baidu.com这个地址，按下enter建后，我们可以看到百度首页 百度页面并没有在我们自己的客服端本地，我们是输入地址后，才请求过来的 输入不同的域名可以看到不同的页面 有的网页是https，有的是http(也有的是ftp) 需要客户端联网才能完成这些事情 DNS服务器 域名解析服务1.www.baidu.com 220.163.18.24域名和服务器关联在一起，是通过DNS解析完成，所谓的DNS解析就是在dns服务上生成一条解析记录，标注了域名和对应的外网ip地址 都经历了哪些事情？ 首先根据客户端输入的域名，到DNS服务器上进行反解析(通过域名找到对应服务器的外网ip) 通过找到外网的ip，找到对应的服务器 通过地址栏中输入的端口号(没输入是因为不同协议有自己默认的端口号)找到服务器上发布的对应项目 服务器获取请求资源的地址，例如/stu/index.html，把资源文件中的原代码找到 response 响应阶段 服务器端会把找的原代码返回给客户端(通过http等传输协议返回) 客户端接收到原代码后，会交给浏览器的内核(渲染引擎)进行渲染，最后由浏览器绘制出对应的页面 服务器自主渲染 客户端和服务端交互(通讯)模型 第一部分 传输协议URL、URI、URN URI : 统一资源标识符 URL: 统一资源路径地址 URN：统一资源名称 URI=URL+URN 一个完整的url包含很多部分https://www.yuque.com/as-giant/dz5g6s/eh4kdu/edit?name=wang&amp;age=2 传输协议是用来完成客户端和服务端的数据(内存)传输的，类似于快递小哥、负责把客户和商家的物品来回床底 客户端不仅可以向服务器发送请求，而且还可以吧一些内容传递给服务器 服务器端也可以把内容返回给客户端 客户端和服务端传输的内容总称:http报文，这些报文信息都是基于传输协议完成传输的，客户端传递给服务器叫做请求(Request),服务器返回给客户端叫做响应(Response) , request+response两个阶段统称为一个HTTP事务(事务:一个完整的事情) HTTP事务 当客户端想服务器端发送请求，此时客户端和服务器端会简历一个传输通道(链接通道)，传输协议就是基于这个通道吧信息进行传输的 当服务器端接受到请求信息，把内容返回给客户端后，传输通道会自动销毁关闭 传输协议分类 http:超文本传输协议(客户端和服务器端传输的内容除了文本以外)，还可以传输图片，音视频等文件流[二进制编码/base64],以及传输xml格式的数据等，是目前市场上应用最广泛的传输协议 https:http ssl,它比http更加安全，要往数据内容的传输通道是经过ssl加密的(它需要在服务器端惊醒特殊的处理)，所以涉及资金类的网站一般都是https协议的 ftp:资源文件传输协议，一般用客户端把资源文件(不是代码)上传到服务端，或者从服务器端下载一些资源文件（ftp传输的内容会http这类传输协议传输的内容多) http报文1、起始行 请求起始行 响应起始行 2、首部(头) 请求头：内置请求头、自定义请求头 响应式：内置响应头、自定义响应头 通用头：请求和响应都有的 3、主体 请求主体 响应主体 请求xxx都是客户端设置的信息，服务器获取这些信息响应xxx都是服务器端设置的信息，客户端用来接受这些信息 域名设置域名其实就给不好记忆的服务器外网ip设置了一个好记忆的名字顶级域名(一级域名):qq.com二级域名:www.qq.com、v.qq.com、sports.qq.com三级域名:kbs.sports.qq.com 端口号在服务器发布项目的时候，我们可以通过端口号区分当前服务器上不同的项目一台服务器的端口号取值范围:0~65535之间，如果电脑上安装了很多程序，有一些端口号是被占用了 HTTP:默认端口号80HTTP:默认端口号443FTP:默认端口号21 对于上述三个端口号其实是很重要的，如果被其它程序占用的，我们则不能使用了，所以服务器上一般是禁止安装其它程序的 第四部分 请求资源文件的路径名称/stu/index.html在服务器中发布项目的时候，我们一般都会配置一些默认文档:用户即使不输入请求文件的名称，服务器也会找到默认文档(一般默认文档都是index/default…)我们通常为了做seo优化，会把一些动态页面的地址(xxx.php、xxx.aspx、xxx.asp、xxx.jsp…)进行伪URL重写(需要服务器处理的)https://item.jd.com/432527.html不可能是有一个商品，自己就单独写一个详情页面，肯定是同一个详情页做的不同处理 第一种方案由后台语言很久详情页模板动态生成具体的详情页面 第二种方案当前页面就是一个页面，例如:detail.html/detail.php…,我们做详情页面的时候，开发是按照detail.html?id=432527 来开发的，但是这种页面不方便做seo优化，此时我们把真实的地址进行重写，重写为了让我们看到的是4325427.html 第五部分 问号传承?name=zf&amp;age=9把一些通过xxx=xxx的方式，放在一个url的末尾，通过问号传递 【作用】1.在ajax请求中，我们可以通过问号传递参数的方式，客户端吧一些信息传递给服务器，服务器更具传递信息的不一样，返回不同的数据 12345678910// $.ajax(url,&#123;&#125;);// $.get(url,function()&#123;&#125;);// 对于ajax请求的特殊写法，原理还是基于ajax方法实现 $.post $.script$.ajax(&#123; url:'getPersonInfo?id=12' ...&#125;)// 当前案例，我们传递给服务器的编号是多少，服务器端就会把对应编号人员信息给返回 2.消除ajax请求中get方式缓存 12345$.ajax(&#123; url:'xxx?_=0.123456' method:'get'&#125;)// 我们会在请求url的末尾最佳一个随机数_=随机数，保证每一次请求的url都是不一样的，以此来消除get请求一流的缓存问题 3.通过url传递传输的方式，可以实现页面之间信息的通讯，例如:我们有两个页面A/B,A是列表页面、B是详情页，点击A中的某一条信息，进入到唯一的详情页B，如果展示不同的信息，这种操作就可以基于URL问号传递参数来实现了 例如:http://sports.qq.com/kbsweb/game.htm?mid=10000:1471087http://sports.qq.com/kbsweb/game.htm?mid=10000:1471086在进入game.htm页面的时候，我们可以获取URL传递的参数值，更具传递参数值的不一样从服务器端获取不同的数据展示 在列表页面进行页面跳转的时候，我们需要记住的是跳转的同事传递不同的参数值 第六部分 HASH值#xxxURL末尾传递的井号什么，就是HASH值(哈希值) [作用]1、页面中锚点定位2、前端路由(SPA单页面开发) –&gt;","categories":[{"name":"http与ajax入门笔记","slug":"http与ajax入门笔记","permalink":"http://yoursite.com/categories/http与ajax入门笔记/"}],"tags":[{"name":"http与ajax入门笔记","slug":"http与ajax入门笔记","permalink":"http://yoursite.com/tags/http与ajax入门笔记/"}]},{"title":"13. promise","slug":"es6/13.promise","date":"2019-03-06T03:12:06.000Z","updated":"2019-06-06T14:25:45.000Z","comments":true,"path":"2019/03/06/es6/13.promise/","link":"","permalink":"http://yoursite.com/2019/03/06/es6/13.promise/","excerpt":"","text":"异步回调回调地狱在需要多个操作的时间，会导致多个回调函数嵌套，导致代码不够直观，就常说的回调地域 并行结果如果几个异步操作之间并没有前后顺序之分，但需要等多个异步完成操作完成后才能执行后续的任务，无法实现并行节约时间 Promisepromise本意是承诺，在程序中的意思就是承诺我过一段时间后会给你一个结果。什么时间会用到过一段时间？答案是异步操作，异步是指可能比较长时间才有结果的才做，例如网络请求、读取本地文件等 Promise的三种状态 Pending Promise对象势力创建时候的初始化状态 Fulfilled 可以理解为成功的状态 Rejected 可以理解为失败的状态 then方法就是用来指定Promise 对象的状态改变时确定执行的操作，resolve时执行第一个函数（onFulfilled）,reject时执行第二函数（onRejected） 构造一个Promise使用Promise123456789let promise = new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; if(Math.random()&gt;0.5) resolve('This is resolve!') else reject('This is reject') &#125;,1000);&#125;);promise.then(Fulfilled,Rejected) 构造一个Promise实例需要给Promise构造函数传入一个函数 传入的函数需要有两个形参，两个形参都是function类型的参数。 第一个形参运行后会让Promise实例处于resolve状态，所以我们一般给第一个形参命名为resolve，使 Promise对象的状态改变成成功，同时传递一个参数用于后续成功后的操作 第一个形参运行后悔让Promise实例处于reject状态，所以我们一般给第一个形参命名为reject，将Promise对象的状态改变为失败，同事将错误的信息传递到后续错误处理的操作 es5模拟Promise1234567891011121314function Promise(fn)&#123; this.success(data);&#125;,(error)=&gt;&#123; this.error();&#125;Promise.prtotype.resolve = function (data)&#123; this.success(data);&#125;Promise.prototype.then = function (success,error)&#123; this.success = success; this.error = error;&#125; es5模拟Promise123456789101112131415161718192021222324class Promise&#123; constructor(fn)&#123; fn((data)=&gt;&#123; this.success(data); &#125;,(error)=&gt;&#123; this.error(); &#125;) &#125; resolve(data)&#123; this.success(data); &#125; reject(error)&#123; this.error(error); &#125; then(success,error)&#123; this.success = success; this.error = error; console.log(this); &#125;&#125; promise 做为函数的返回值123456789101112131415161718192021222324function ajaxPromise(queryUrl)&#123; return new Promise((resolve,reject)=&gt;&#123; xhr.open('GET',queryUrl,ture); xhr.send(null); xhr.onreadystatechange = () =&gt;&#123; if(xhr.readyState === 4 )&#123; if(xhr.status === 200)&#123; resolve(xhr.responseText); &#125;else&#123; reject(xhr.responseText); &#125; &#125; &#125; &#125;)&#125;ajaxPromise('http://www.baidu.com') .then((value)=&gt;&#123; console.log(value); &#125;) .catch((err)=&gt;&#123; console.error(err); &#125;); promise的链式调用 每次调用返回的都是一个新的Promise实例 链式调用的参数通过返回值传递 then 可以使用链式调用的写法原因在于，每一次执行该方法时总是会返回一个 Promise 对象 12345678910readFile('1.txt').then(function(data)&#123; console.log(data);&#125;).then(function (data)&#123; console.log(data); return readFile(data);&#125;).then(function (data)&#123; console.log(data);&#125;).catch(function (err)&#123; console.log(err);&#125;) promise APIPromise.all 参数:接受一个数组，数组内都是Promise实例 返回值: 返回一个 promise 实例，这个promise 实例的状态转移取决于参数的 promise实例的状态变化。当参数处于resolve状态时，返回resolve状态。如果参数中任意一个实例处于reject状态，返回的promise实例变为reject状态。 123Promise.all([p1,p2]).then(function(result)&#123; console.log(result); //[ '2.txt', '2' ]&#125;) 不管两个promise谁先完成，Promise.all 方法会按照数组里面的顺序将结果返回 Promise.race 参数:接受一个数组，数组内都是Promise实例 返回值: 返回一个 promise 实例，这个promise 实例的状态转移取决于参数的 promise实例的状态变化。当参数处于resolve状态时，返回resolve状态。如果参数中任意一个实例处于reject状态，返回的promise实例变为reject状态。 123Promise.race([p1,p2]).then(function(result)&#123; console.log(result); //[ '2.txt', '2' ]&#125;) Promise.resolve返回一个Promise 实例，这个实例处于resolve状态。根据传入的参数不同有不同的功能: 值(对象、数组、字符串等):作为resolve传递出去的值 Promise 实例 : 原封不动返回 Promise.reject返回一个Promise实例，这个实例处于reject状态 参数一般就是抛出的错误信息。 qQ是一个在Javascrip中实现promise的模块 13.8.1 q的基本用法123456789101112131415161718var Q = require('q');var fs = require('fs');function read(filename)&#123; var deferred = Q.defer(); fs.readFile(filename,'utf8',function)(err,data)&#123; if(err)&#123; deferred.reject(err); &#125;else&#123; deferred.resolve(data); &#125; &#125;);&#125;read('1.txt1').then(function(data)&#123; console.log(data);&#125;,funtcion(error)&#123; console.error(error); &#125;) 13.8.2 q的简单实现12345678910111213141516171819module.exports = &#123; defer()&#123; var _success,_error; return &#123; resolve(data)&#123; _success(data); &#125;, reject(err)&#123; _error(err); &#125;, promise:&#123; then(success,error)&#123; _success = success; _error = error; &#125; &#125; &#125; &#125;&#125; 13.8.3 q的实现123456789101112131415161718192021222324var defer = function () &#123; var pending = [], value; return &#123; resolve: function (_value) &#123; if (pending) &#123; value = _value; for (var i = 0, ii = pending.length; i &lt; ii; i++) &#123; var callback = pending[i]; callback(value); &#125; pending = undefined; &#125; &#125;, promise: &#123; then: function (callback) &#123; if (pending) &#123; pending.push(callback); &#125; else &#123; callback(value); &#125; &#125; &#125; &#125;;&#125;; 13.9 bluebird 实现 promise 标准的库是功能最全，速度最快的一个库 13.9.1 bluebird经典使用123456789101112var Promise = require('./bluebird');var readFile = Promise.promisify(require(\"fs\").readFile);readFile(\"1.txt\", \"utf8\").then(function(contents) &#123; console.log(contents);&#125;)var fs = Promise.promisifyAll(require(\"fs\"));fs.readFileAsync(\"1.txt\", \"utf8\").then(function (contents) &#123; console.log(contents);&#125;) bluebird简单实现123456789101112131415161718192021222324module.exports = &#123; promisify(fn)&#123; return function () &#123; var args = Array.from(arguments); return new Promise(function (resolve, reject) &#123; fn.apply(null, args.concat(function (err) &#123; if (err) &#123; reject(err); &#125; else &#123; resolve(arguments[1]) &#125; &#125;)); &#125;) &#125; &#125;, promisifyAll(obj)&#123; for(var attr in obj)&#123; if(obj.hasOwnProperty(attr) &amp;&amp; typeof obj[attr] =='function')&#123; obj[attr+'Async'] = this.promisify(obj[attr]); &#125; &#125; return obj; &#125;&#125; 13.10 动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;move&lt;/title&gt; &lt;style&gt; .square&#123; width:40px; height:40px; border-radius: 50%; &#125; .square1&#123; background-color: red; &#125; .square2&#123; background-color: yellow; &#125; .square3&#123; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"square square1\" style=\"margin-left: 0\"&gt;&lt;/div&gt;&lt;div class=\"square square2\" style=\"margin-left: 0\"&gt;&lt;/div&gt;&lt;div class=\"square square3\" style=\"margin-left: 0\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var square1 = document.querySelector('.square1'); var square2 = document.querySelector('.square2'); var square3 = document.querySelector('.square3'); /*function move(element,target,resolve)&#123; let timer = setInterval(function()&#123; var marginLeft = parseInt(element.style.marginLeft, 10); if(marginLeft == target)&#123; resolve(); &#125;else&#123; element.style.marginLeft = ++marginLeft+'px'; &#125; &#125;,13); &#125;*/ function move(element,target,resolve)&#123; let current = 0; let timer = setInterval(function()&#123; element.style.transform=`translateX($&#123;++current&#125;px)`; if(current&gt;target)&#123; clearInterval(timer); resolve(); &#125;; &#125;,13); &#125; function animate(element,target)&#123; return new Promise(function(resolve,reject)&#123; move(element,target,resolve); &#125;); &#125; animate(square1,100) .then(function()&#123; return animate(square2,100); &#125;) .then(function()&#123; return animate(square3,100); &#125;);&lt;/script&gt;&lt;/html&gt; 13.11. co 13.11.1 co初体验1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let fs = require('fs');function getNumber()&#123; return new Promise(function (resolve,reject) &#123; setTimeout(function()&#123; let number = Math.random(); if(number &gt;.5)&#123; resolve(number); &#125;else&#123; reject('数字太小'); &#125; &#125;,1000); &#125;);&#125;function *read()&#123; let a = yield getNumber(); console.log(a); let b = yield 'b'; console.log(b); let c = yield getNumber(); console.log(c);&#125;function co(gen)&#123; return new Promise(function(resolve,reject)&#123; let g = gen(); function next(lastValue)&#123; let &#123;done,value&#125; = g.next(lastValue); if(done)&#123; resolve(lastValue); &#125;else&#123; if(value instanceof Promise)&#123; value.then(next,function(val)&#123; reject(val); &#125;); &#125;else&#123; next(value); &#125; &#125; &#125; next(); &#125;);&#125;co(read).then(function(data)&#123; console.log(data);&#125;,function(reason)&#123; console.log(reason);&#125;); 13.11.2 co连续读文件12345678910111213141516171819202122232425262728let fs = require('fs');function readFile(filename)&#123; return new Promise(function (resolve,reject) &#123; fs.readFile(filename,'utf8',function(err,data)&#123; if(err) reject(err); else resolve(data); &#125;) &#125;);&#125;function *read()&#123; let a = yield readFile('./1.txt'); console.log(a); let b = yield readFile('./2.txt'); console.log(b);&#125;function co(gen)&#123; let g = gen(); function next(val)&#123; let &#123;done,value&#125; = g.next(val); if(!done)&#123; value.then(next); &#125; &#125; next();&#125; 13.12 Promise/A+完整实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170function Promise(executor) &#123; let self = this; // 默认状态pending self.status = \"pending\"; // 此变量里放着此promise的结果 self.value = undefined; // 存放所有成功的回调函数 self.onResolvedCallbacks = []; // 存放所有的失败的回调函数 self.onRejectedCallbacks = []; // 调用方法promise 变成成功状态 // resolve的时候你把值传过来 function resolve(value) &#123; if (value instanceof Promise) &#123; return value.then(resolve, reject) &#125; setTimeout(function () &#123; // 异步执行所有的回调函数 if (self.status == 'pending') &#123; self.value = value; self.status = 'resolved'; self.onResolvedCallbacks.forEach(item =&gt; item(value)); &#125; &#125;); &#125; // 调用方法把当前promise变成失败 function reject(value) &#123; setTimeout(function () &#123; if (self.status == 'pending') &#123; self.value = value; self.status = 'rejected'; self.onRejectedCallbacks.forEach(item =&gt; item(value)); &#125; &#125;); &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; return reject(new TypeError('循环引用')); &#125; let then, called; if (x != null &amp;&amp; ((typeof x == 'object' || typeof x == 'function'))) &#123; try &#123; then = x.then; if (typeof then == 'function') &#123; then.call(x, function (y) &#123; if (called)return; called = true; resolvePromise(promise2, y, resolve, reject); &#125;, function (r) &#123; if (called)return; called = true; reject(r); &#125;); &#125; else &#123; resolve(x); &#125; &#125; catch (e) &#123; if (called)return; called = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125;// onFullfilled成功的回调,onReject失败的回调Promise.prototype.then = function (onFulfilled, onRejected) &#123; let self = this; onFulfilled = typeof onFulfilled == 'function' ? onFulfilled : function (value) &#123; return value &#125;; onRejected = typeof onRejected == 'function' ? onRejected : function (value) &#123; throw value &#125;; let promise2; if (self.status == 'resolved') &#123; promise2 = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; try &#123; let x = onFulfilled(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if (self.status == 'rejected') &#123; promise2 = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; try &#123; let x = onRejected(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if (self.status == 'pending') &#123; promise2 = new Promise(function (resolve, reject) &#123; self.onResolvedCallbacks.push(function (value) &#123; try &#123; let x = onFulfilled(value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); self.onRejectedCallbacks.push(function (value) &#123; try &#123; let x = onRejected(value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; return promise2;&#125;Promise.prototype.catch = function (onRejected) &#123; return this.then(null, onRejected);&#125;Promise.all = function (promises) &#123; return new Promise(function (resolve, reject) &#123; let result = []; let count = 0; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(function (data) &#123; result[i] = data; if (++count == promises.length) &#123; resolve(result); &#125; &#125;, function (err) &#123; reject(err); &#125;); &#125; &#125;);&#125;Promise.deferred = Promise.defer = function () &#123; var defer = &#123;&#125;; defer.promise = new Promise(function (resolve, reject) &#123; defer.resolve = resolve; defer.reject = reject; &#125;) return defer;&#125;/** * npm i -g promises-aplus-tests * promises-aplus-tests Promise.js */try &#123; module.exports = Promise&#125; catch (e) &#123;&#125;","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"12. JavaScript(ES6) 中条件语句","slug":"es6/12.JavaScript(ES6) 中条件语句","date":"2019-03-03T07:12:06.000Z","updated":"2019-06-06T14:23:49.000Z","comments":true,"path":"2019/03/03/es6/12.JavaScript(ES6) 中条件语句/","link":"","permalink":"http://yoursite.com/2019/03/03/es6/12.JavaScript(ES6) 中条件语句/","excerpt":"","text":"使用 Array.includes 来处理多个条件12345function test(fruit) &#123; if (fruit == 'apple' || fruit == 'strawberry') &#123; console.log('red'); &#125;&#125; 优化变成 -&gt;&gt; 12345678function test(fruit) &#123; // 条件提取到数组中 const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; if (redFruits.includes(fruit)) &#123; console.log('red'); &#125;&#125; 减少嵌套，提前使用 return 语句1234567891011121314151617181920212223function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1：fruit 必须有值 if (fruit) &#123; // 条件 2：必须为红色 if (redFruits.includes(fruit)) &#123; console.log('red'); // 条件 3：数量必须大于 10 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125; &#125; &#125; else &#123; throw new Error('No fruit!'); &#125;&#125; // 测试结果test(null); // 抛出错误：No fruitstest('apple'); // 打印：redtest('apple', 20); // 打印：red，big quantity 优化 123456789101112131415161718/* 在发现无效条件时提前 return */ function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1：提前抛出错误 if (!fruit) throw new Error('No fruit!'); // 条件2：必须为红色 if (redFruits.includes(fruit)) &#123; console.log('red'); // 条件 3：数量必须大于 10 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125; &#125;&#125; 为了减少一个嵌套层级，优化编码风格 123456789101112131415/* 在发现无效条件时提前 return */ function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; if (!fruit) throw new Error('No fruit!'); // 条件 1：提前抛出错误 if (!redFruits.includes(fruit)) return; // 条件 2：当 fruit 不是红色的时候，提前 return console.log('red'); // 条件 3：必须是大量存在 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125;&#125; 使用函数的默认参数 和 解构12345678910function test(fruit, quantity) &#123; if (!fruit) return; const q = quantity || 1; // 如果没有提供 quantity 参数，则默认为 1 console.log(`We have $&#123;q&#125; $&#123;fruit&#125;!`);&#125; // 测试结果test('banana'); // We have 1 banana!test('apple', 2); // We have 2 apple! 但是q在这边不直观所有优化 12345678function test(fruit, quantity = 1) &#123; // i如果没有提供 quantity 参数，则默认为 1 if (!fruit) return; console.log(`We have $&#123;quantity&#125; $&#123;fruit&#125;!`);&#125; // 测试结果test('banana'); // We have 1 banana!test('apple', 2); // We have 2 apple! 但是这边 也可能是个对象 12345678910// 解构 —— 只获得 name 属性// 参数默认分配空对象 &#123;&#125;function test(&#123;name&#125; = &#123;&#125;) &#123; console.log (name || 'unknown');&#125; //测试结果test(undefined); // unknowntest(&#123; &#125;); // unknowntest(&#123; name: 'apple', color: 'red' &#125;); // apple 选择 Map / Object 字面量，而不是Switch语句1234567891011121314151617function test(color) &#123; // 使用 switch case 语句，根据颜色找出对应的水果 switch (color) &#123; case 'red': return ['apple', 'strawberry']; case 'yellow': return ['banana', 'pineapple']; case 'purple': return ['grape', 'plum']; default: return []; &#125;&#125; //测试结果test(null); // []test('yellow'); // ['banana', 'pineapple'] 这边建议使用对象，更加清晰 12345678910// 使用对象字面量，根据颜色找出对应的水果 const fruitColor = &#123; red: ['apple', 'strawberry'], yellow: ['banana', 'pineapple'], purple: ['grape', 'plum'] &#125;; function test(color) &#123; return fruitColor[color] || [];&#125; 但是这边是很有可能为网络数据，无法判断red这样的变量，那么就用arry.filter 来过滤 1234567891011121314const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'strawberry', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'pineapple', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125;, &#123; name: 'plum', color: 'purple' &#125;]; function test(color) &#123; // 使用 Array filter ，根据颜色找出对应的水果 return fruits.filter(f =&gt; f.color == color);&#125; 使用 Array.every 和 Array.some 来处理全部/部分满足条件我们想检查所有水果是否都是红色的 1234567891011121314151617const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125; ]; function test() &#123; let isAllRed = true; // 条件：所有的水果都必须是红色 for (let f of fruits) &#123; if (!isAllRed) break; isAllRed = (f.color == 'red'); &#125; console.log(isAllRed); // false&#125; 使用 arry.every来过滤 123456789101112const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125; ]; function test() &#123; // 条件：简短方式，所有的水果都必须是红色 const isAllRed = fruits.every(f =&gt; f.color == 'red'); console.log(isAllRed); // false&#125; 如果我们想要检查是否有至少一个水果是红色的，我们可以使用 Array.some 仅用一行代码就实现出来 123456789101112const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125;]; function test() &#123; // 条件：是否存在红色的水果 const isAnyRed = fruits.some(f =&gt; f.color == 'red'); console.log(isAnyRed); // true&#125;","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"11 模块","slug":"es6/11.模块","date":"2019-03-03T06:12:06.000Z","updated":"2019-06-06T14:17:33.000Z","comments":true,"path":"2019/03/03/es6/11.模块/","link":"","permalink":"http://yoursite.com/2019/03/03/es6/11.模块/","excerpt":"","text":"可以根据应用的需求吧代码分成不同的模块，每个模块里可以导出它需要让其他模块使用的东西，在其他模块里面可以导入这些模块，导出的东西。 在浏览器中使用模块需要借助 导出 12export var name = 'wjh';export var age = 8; 导入 123//import &#123;name,age&#125; from './school.js';import * as school from './school.js';console.log(school.name,school.age); 在页面中引用 1234&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/traceur.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/BrowserSystem.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://google.github.io/traceur-compiler/src/bootstrap.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt; 重命名导出时重命名 1234function say()&#123; console.log('say');&#125;export &#123;say as say2&#125;; 导入时重命名 1import &#123;say2 as say3&#125; from &apos;./school.js&apos; 11.3 默认导出每个模块都可以有一个默认要导出的东西 123export default function say()&#123; console.log('say')&#125; 导入 1import say from './school.js' 11.4 深度克隆123456789101112131415161718192021222324252627282930313233343536373839var parent = &#123; age: 5, hobby: [1, 2, 3], home: &#123;city: '北京'&#125;,&#125;;var child = extendDeep(parent);child.age = 6;child.hobby.push('4');child.home.city = '广东';console.log('child ', child); //[1, 2, 3, 4]console.log('parent ', parent);function extend(parent) &#123; let child; if (Object.prototype.toString.call(parent) == '[object Object]') &#123; child = &#123;&#125;; for (let key in parent) &#123; child[key] = extend(parent[key]) &#125; &#125; else if (Object.prototype.toString.call(parent) == '[object Array]') &#123; child = parent.map(item =&gt; extend(item)); &#125; else &#123; return parent; &#125; return child;&#125;function extendDeep(parent, child) &#123; child = child || &#123;&#125;; for (var key in parent) &#123; if (typeof parent[key] === \"object\") &#123; child[key] = (Object.prototype.toString.call(parent[key]) === \"[object Array]\") ? [] : &#123;&#125;; extendDeep(parent[key], child[key]); &#125; else &#123; child[key] = parent[key]; &#125; &#125; return child;&#125;","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"10. 集合","slug":"es6/10.集合","date":"2019-03-03T06:12:06.000Z","updated":"2019-06-06T14:16:39.000Z","comments":true,"path":"2019/03/03/es6/10.集合/","link":"","permalink":"http://yoursite.com/2019/03/03/es6/10.集合/","excerpt":"","text":"10.1 Set 一个Set是一堆东西的集合，Set 有点像数组，不过跟数组不一样的是，Set里面不能有重复的内容 1234567891011121314var books = new Set();books.add('js');books.add('js');//添加重复元素的集合元素个数不会变化books.add('html');books.forEach(function(book)&#123; // 循环集合 console.log(book);&#125;)console.log(book.size);//集合中元数的个数console.log(books.has('js'));//判断集合是否有此元素books.delete('js');console.log(books.size);console.log(books.has('js'));books.clear();//清空setconsole.log(books.size); 10.2 Map 可以使用Map来组织这个名值对的数据 1234567891011var books = new Map();books.set('js',&#123;name:'js'&#125;);//向map中添加元素books.set('html',&#123;name:'html'&#125;);console.log(books.size);//查看集合中的元素console.log(books.get('js'));//通过key获取值books.delete('js');//执行key删除元素console.log(books.has('js'));//判断map中有没有keybook.forEach((value,key)=&gt;&#123; console.log(key+'='+value);&#125;)books.clear();//清空map","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"9. 生成器(Generator)与迭代器(Iterator)","slug":"es6/9.生成器(Generator)与迭代器(Iterator)","date":"2019-03-03T05:12:06.000Z","updated":"2019-06-06T14:16:04.000Z","comments":true,"path":"2019/03/03/es6/9.生成器(Generator)与迭代器(Iterator)/","link":"","permalink":"http://yoursite.com/2019/03/03/es6/9.生成器(Generator)与迭代器(Iterator)/","excerpt":"","text":"Generator 是一个特殊的函数，执行它会返回一个Iterator对象。通过遍历迭代器，Generator函数运行后悔返回遍历器对象，而不是函数的返回值。 Iterators模拟迭代器有一个next方法，每次执行的时候会返回一个对象 对象里面有两个函数，一个是value表示返回的值，还有就是布尔值done，表示是迭代完成 1234567891011121314151617181920function buy(books)&#123; let i = 0; return&#123; next()&#123; let done = i ===books.length; let value = !done ? books[i++]:undefined; return &#123; value:value, done:done &#125; &#125; &#125;&#125;let iterators = buy(['js','html']);var curr;do&#123; curr = iterators.next(); console.log(curr);&#125;while(!curr.done); Generators生成器用于创建迭代器 1234567891011function* buy(boos)&#123; for(var i=0;i&lt;boos.length;i++)&#123; yield books[i]; &#125;&#125;let buying = buy(['js','html]);var curr;do &#123; curr = buying.next(); console.log(curr);&#125;while(!curr.done);","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"8. 类","slug":"es6/8.类","date":"2019-03-03T03:12:06.000Z","updated":"2019-06-06T14:15:30.000Z","comments":true,"path":"2019/03/03/es6/8.类/","link":"","permalink":"http://yoursite.com/2019/03/03/es6/8.类/","excerpt":"","text":"class使用 class 这个关键词定义一个类，基于这个创建实例以后就会创建 constructor 方法，此方法可以用来初始化 12345678910111213class Person&#123; constructor(name)&#123; this.name = name; &#125; getName()&#123; console.log(this.name) &#125;&#125;let person = new Person('wjh');person.getName(); get与setgetter 可以用来获取属性,setter 可以去设置属性 123456789101112131415class Person &#123; constructor()&#123; this.hobbies = []; &#125; set hobby(hobby)&#123; this.hobbies.push(hobby); &#125; get hobby()&#123; return this.hobbies; &#125;&#125;let person = new Person();person.hobby = 'aa';person.hobby = 'bb';console.log(person.hobby) 静态方法-static在类里面添加静态的方法可以使用static 这个关键词，静态方法就是不需要实例化类就能使用的方法 123456class Person&#123; static add(a,b)&#123; return a+b; &#125;&#125;console.log(Person.add(1,x)); 继承extends一个类可以继承其他的类里的东西 123456789101112131415class Person&#123; constructor(name)&#123; this.name = name; &#125;&#125;class Teacher extends Person&#123; constructor(name,age)&#123; super(name); this.age = age; &#125;&#125;var teacher = Teacher('wjh',8);console.log(teacher.name,teacher.age)","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"7. 对象","slug":"es6/7.对象","date":"2019-03-02T10:12:06.000Z","updated":"2019-06-06T14:14:48.000Z","comments":true,"path":"2019/03/02/es6/7.对象/","link":"","permalink":"http://yoursite.com/2019/03/02/es6/7.对象/","excerpt":"","text":"对象字面量如果你想在对象里添加跟变量名一样的属性，并且属性的值就是变量表示的值就可以直接在对象里加上这些属性 1234567891011let name = 'wjh';let age = 8;let getName = function()&#123; console.log(this.name)&#125;let person =&#123; name, age, getName&#125;person.getName(); 7.2 Object.is 对比两个值是否相等 1console.log(Object.is(NaN,NaN)); Object.assign把多个对象的属性复制到一个对象中，第一个参数是复制的对象，从第二个参数开始往后，都是复制的源对象 12345678910var nameObj = &#123;name:'wjh'&#125;var ageObj = &#123;age:8&#125;;var obj = &#123;&#125;;Object.assign(obj,nameObj,ageObj);console.log(obj);//克隆对象function clone(obj)&#123; return Object.assgin(&#123;&#125;,obj);&#125; Object.setPrototypeOf将一个指定的对象原型设置为另一个对象或者null 123456789var obj1 = &#123;name:'wjh1'&#125;;var obj2 = &#123;name:'wjh2'&#125;;var obj = &#123;&#125;;Object.setPrototypeOf(obj,obj1);console.log(obj.name);console.log(Object.getPrototypeOf(obj));Object.setProtoypeOF(obj,obj2);console.log(obj.name);console.log(Object.getPrototypeOf(obj)); proto直接对象表达式中设置prototype 123456var obj1 = &#123;name:&apos;wjh&apos;&#125;;var obj3 = &#123; _proto_:obj1&#125; console.log(obj3.name);console.log(Object.getPrototypeOf(obj3)); super通过super可以调用protype上的属性或方法 123456789101112let person =&#123; eat()&#123; return 'milk'; &#125;&#125;let student = &#123; _proto_:person, eat()&#123; return super.eat()+'bead' &#125;&#125;console.log(student.eat());","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"6. 数组的新方法","slug":"es6/6.数组的新方法","date":"2019-03-02T09:12:06.000Z","updated":"2019-06-06T14:13:24.000Z","comments":true,"path":"2019/03/02/es6/6.数组的新方法/","link":"","permalink":"http://yoursite.com/2019/03/02/es6/6.数组的新方法/","excerpt":"","text":"1234567891011121314151617181920212223// 相同的阵列var people = [ &#123; name : 'Casper' , like : '锅烧意面' , age : 18 &#125;, &#123; name : 'Wang' , like : '炒面' , age : 24 &#125;, &#123; name : 'Bobo' , like : '萝卜泥' , age : 1 &#125;, &#123; name : '卤蛋' , like : '萝卜泥' , age : 3 &#125;]; filter() filter() 会回传一个阵列，其条件是return 后方为true 的物件，很适合用在搜寻符合条件的资料。 12345678var filterEmpty = people.filter( function ( item, index, array ) &#123;&#125;);console .log(filterEmpty); //没有条件，会是一个空阵列var filterAgeThan5 = people.filter( function ( item, index, array ) &#123; return item.age &gt; 5 ; //取得大于五岁的 如果这边符合条件 只要为ture即可&#125;);console .log(filterAgeThan5); // Casper, Wang这两个物件 find() find()与filter()很像，但find() 只会回传一次值，且是第一次为true的值。 12345678910111213var findEmpty = people.find( function ( item, index, array ) &#123;&#125;);console .log(findEmpty); //没有条件，会是undefinedvar findAgeThan5 = people.find( function ( item, index, array ) &#123; return item.age &gt; 5 ; //取得大于五岁的&#125;);console .log(findAgeThan5); //虽然答案有两个，但只会回传Casper这一个物件var findLike = people.find( function ( item, index, array ) &#123; return item.like === '萝卜泥' ; //取得阵列like === '萝卜泥'&#125;);console .log(findLike); //虽然答案有两个，但只会回传第一个Bobo物件 forEach() forEach 是这几个阵列函式最单纯的一个，不会额外回传值，只单纯执行每个阵列内的物件或值。 1234567891011var forEachIt = people.forEach( function ( item, index, array ) &#123; console .log(item, index, array); //物件,索引,全部阵列 return item; // forEach没在return的，所以这边写了也没用&#125;);console .log(forEachIt); // undefinedpeople.forEach( function ( item, index, array ) &#123; item.age = item.age + 1 ; // forEach就如同for，不过写法更容易&#125;);console .log(people); //全部age + 1 map() 使用map() 时他需要回传一个值，他会透过函式内所回传的值组合成一个阵列。如果不回传则是 undefined回传数量等于原始阵列的长度这很适合将原始的变数运算后重新组合一个新的阵列。 12345678910111213141516171819202122232425var mapEmpty = people.map( function ( item, index, array ) &#123;&#125;);console .log(mapEmpty); // [undefined, undefined, undefined, undefined]var mapAgeThan5 = people.map( function ( item, index, array ) &#123; return item.age &gt; 5 ; //比较大于五岁的&#125;);console .log(mapAgeThan5); // [true, true, false, false]var mapAgeThan5_2 = people.map( function ( item, index, array ) &#123; // 错误示范 if (item.age &gt; 5 ) &#123; return item; //回传大于五岁的 &#125; return false ; //别以为空的或是false就不会回传&#125;);console .log(mapAgeThan5_2); // [&#123;name: 'Casper'...&#125;, &#123;name: 'Wang'...&#125;, false, false]var mapEat = people.map( function ( item, index, array ) &#123; if (item.like !== '萝卜泥' ) &#123; return ` $&#123;item.like&#125;好吃` ; &#125; else &#123; return ` $&#123;item.like&#125;不好吃` ; &#125;&#125;);console .log(mapEat); // [\"锅烧意面好吃\", \"炒面好吃\", \"萝卜泥不好吃\", \"萝卜泥不好吃\"] every() every()可以检查所有的阵列是否符合条件，这仅会回传一个值trueor false，可以用来检查阵列中的内容是否符合特定条件。 12345678910var ans = array.every( function ( item, index, array ) &#123; console .log(item, index, array); //物件,索引,全部阵列 return item.age &gt; 10 //当全部age大于10才能回传true&#125;);console .log(ans); // false:只要有部分不符合，则为falsevar ans2 = array.every( function ( item, index, array ) &#123; return item.age &lt; 25&#125;);console .log(ans2); // true:全部age都小于25 some() some() 与every() 非常接近，都是回传true or false，差异仅在every() 需完全符合，some() 仅需要部分符合。 1234567891011121314var ans = people.some( function ( item, index, array ) &#123; return item.age &gt; 10 //当全部age大于10才能回传true&#125;);console .log(ans); // true:只要有部分符合，则为truevar ans2 = people.some( function ( item, index, array ) &#123; return item.age &lt; 25&#125;);console .log(ans2); // true:只要有部分符合，则为true var ans2 = people.some( function ( item, index, array ) &#123; return item.age &gt; 25&#125;);console .log(ans2); // false:全部都不符合则为false reduce() reduce() 和其他几个差异就很大了，他可以与前一个回传的值再次作运算，参数包含以下：accumulator: 前一个参数，如果是第一个阵列的话，值是以另外传入或初始化的值currentValue: 当前变数currentIndex: 当前索引array: 全部阵列 12345678910111213141516var reduceEmpty = people.reduce( function ( accumulator, currentValue, currentIndex, array ) &#123;&#125;);console .log(reduceEmpty); //没有条件，会是undefinedvar reducePlus = people.reduce( function ( accumulator, currentValue, currentIndex, array ) &#123; // 分别为前一个回传值, 目前值, 当前索引值 console .log(accumulator, currentValue, currentIndex); return accumulator + currentValue.age; //与前一个值相加&#125;, 0 ); //传入初始化值为0console .log(reducePlus); //总和为46var reducePlus = people.reduce( function ( accumulator, currentValue, currentIndex, array ) &#123; console .log( 'reduce' , accumulator, currentValue, currentIndex) return Math .max( accumulator, currentValue.age ); //与前一个值比较哪个大&#125;, 0 );console .log(reducePlus); //最大值为24","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"5. 函数","slug":"es6/5.函数","date":"2019-03-02T08:12:06.000Z","updated":"2019-06-06T14:11:39.000Z","comments":true,"path":"2019/03/02/es6/5.函数/","link":"","permalink":"http://yoursite.com/2019/03/02/es6/5.函数/","excerpt":"","text":"默认参数可以给定义的函数接收的参数设置默认的值 在执行这个函数的时候，如果不指定函数的参数的值，就会使用参数的这些默认的值。 12345function ajax(url,method='GET',dataType=\"json\")&#123; console.log(url); console.log(method); console.log(dataType);&#125; 展开操作符把…放在数组前面可以把一个数组进行展开，可以把一个函数而不需要使用apply 1234567891011121314151617181920212223//传入参数let print = function(a,b,c)&#123; console.log(a,b,c);&#125;print([1,2,3]);print(...[1,2,3]);// 可以替代applyvar m1 = Math.max.apply(null, [8, 9, 4, 1]);var m2 = Math.max(...[8, 9, 4, 1]);// 可以替代concatvar arr1 = [1, 3];var arr2 = [3, 5];var arr3 = arr1.concat(arr2);var arr4 = [...arr1, ...arr2];console.log(arr3,arr4);//类数组的转数组function max(a,b,c) &#123; console.log(Math.max(...arguments));&#125;max(1, 3, 4); 剩余操作符剩余操作符可以把其余参数的值放在一个叫做b的数组里 1234let rest = function(a,...rest)&#123; console.log(a,rest);&#125;rest(1,2,3); 解构参数1234let destruct = function(&#123;name,age&#125;)&#123; console.log(name,age);&#125;destruct(&#123;name:'wjh',age:10&#125;) 箭头函数箭头函数简化了函数的定义方式 1[1,2,3].forEach(val=&gt;console.log(val)); 输入参数如果多于一个要用()包含，函数体如果有多条语句需要用{}包起来 箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。 正是因为它没有this，从而避免了this指向的问题。 12345678var person = &#123; name:'wjh', getName:function()&#123;- setTimeout(function()&#123;console.log(this);&#125;,1000); //在浏览器执行的话this指向window+ setTimeout(() =&gt; console.log(this),1000);//在浏览器执行的话this指向person &#125;&#125;person.getName();","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"4. 字符串","slug":"es6/4.字符串","date":"2019-03-02T07:12:06.000Z","updated":"2019-06-06T14:07:26.000Z","comments":true,"path":"2019/03/02/es6/4.字符串/","link":"","permalink":"http://yoursite.com/2019/03/02/es6/4.字符串/","excerpt":"","text":"模板字符串模板字符串用反应号(数字1左边的那个建)包含，用${}括起来 12345678910var name = 'zfpx',age = 8;let desc = `$&#123;name&#125; is $&#123;age&#125; old!`;console.log(desc);//所有模板字符串的空格和换行，都是被保留的var str = `&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;b&lt;/li&gt;&lt;/ul&gt;`;console.log(str); 其中的变量会用变量的值替换掉 12345function replace(desc)&#123; return desc.replace(/\\$\\&#123;([^&#125;]+)\\&#125;/g,function(matched,key)&#123; return eval(key); &#125;);&#125; 带标签的模板字符串可以在模板字符串的前面添加一个标签，这个标签可以去处理模板字符串 标签其实就是一个函数,函数可以接收两个参数,一个是 strings 就是模板字符串里的每个部分的字符 还有一个参数可以使用rest的形式values,这个参数里面是模板字符串里的值。 12345var name = 'wjh',age = 8;function desc(strings,...values)&#123; console.log(strings,values);&#125;desc`$&#123;name&#125; is $&#123;age&#125; old!`; 字符串新方法 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 1234var s = 'wjh';s.startsWith('w') // trues.endsWith('h') // trues.includes('j') // true 第二个参数，表示开始搜索的位置 1234var s = &apos;wjh&apos;;console.log(s.startsWith(&apos;j&apos;,2)); // trueconsole.log(s.endsWith(&apos;j&apos;,2)); // trueconsole.log(s.includes(&apos;j&apos;,2)); // false endsWith的行为与其他其他方法有所不同。它针对前n个字符，而其他方法是从第几位开始到字符串结束 repeatrepeat 方法返回一个新字符串，表示将原字符串重复n次。 12&apos;x&apos;.repeat(3);&apos;x&apos;.repeat(0);","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"3. 解构","slug":"es6/3.解构","date":"2019-03-02T06:21:58.000Z","updated":"2019-06-06T14:05:34.000Z","comments":true,"path":"2019/03/02/es6/3.解构/","link":"","permalink":"http://yoursite.com/2019/03/02/es6/3.解构/","excerpt":"解构意思就是分解一个东西的结构,可以用一种类似数组的方式定义N个变量，可以将一个数组中的值按照规则赋值过去。","text":"解构意思就是分解一个东西的结构,可以用一种类似数组的方式定义N个变量，可以将一个数组中的值按照规则赋值过去。 12var [name,age]=['wjh',8];console.log(name,age); 嵌套赋值12345678910let [x,[y],z]=[1,[2.1]];console.log(x,y,z);let [x,[y,z]] = [1,[2.1,2.2]];console.log(x,y,z);let [json,arr,num] = [&#123;name:'wjw'&#125;,[1,2],3];console.log(json,arr,num);// 1 2.1 undefined 1 2.1 2.2 &#123; name: 'wjw' &#125; [ 1, 2 ] 3 省略赋值12let [,,x]=[1,2,3]console.log(x); 解构对象对象也可以被解构 123456var obj = &#123;name:'zfpx',age:8&#125;;//对象里的name属性的值会交给name这个变量，age的值会交给age这个变量var &#123;name,age&#125; = obj//对象里的name属性的值会交给myname这个变量，age的值会交给myage这个变量let &#123;name: myname, age: myage&#125; = obj;console.log(name,age,myname,myage); 默认值在赋值和传参的时候可以使用默认值 12345678910111213141516let [a='a',b='b',c=new Error('C必须指定')] = [1, , 3];console.log(a,b,c);function ajax(options)&#123; var method = options.method || \"get\"; var data = options.data || &#123;&#125;;&#125;function ajax(method='get',data)&#123; console.log(arguments);&#125;ajax(&#123; method:'post', data:&#123;'name':'wjh'&#125;&#125;)","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"2. 常量","slug":"es6/2.常量","date":"2019-03-02T05:21:58.000Z","updated":"2019-06-06T14:04:13.000Z","comments":true,"path":"2019/03/02/es6/2.常量/","link":"","permalink":"http://yoursite.com/2019/03/02/es6/2.常量/","excerpt":"使用 const 我们可以声明一个常量，一旦声明之后，就不可以更改。","text":"使用 const 我们可以声明一个常量，一旦声明之后，就不可以更改。 使用 const 我们可以声明一个常量，一旦声明之后，就不可以更改。 常量不能重新赋值12const MY_NAME = 'zfpx';MY_NAME = 'zfpx2';//Assignment to constant variable 变量可以改变 注意const限制的是不能给变量重新赋值，而变量的值本身是可以改变的,下面的操作是可以的 123const names = ['zfpx1'];names.push('zfpx2');console.log(names); 不同的块级作用域可以多次定义123456789101112const A = \"0\";&#123; const A = \"A\"; console.log(A)&#125;&#123; const A = \"B\"; console.log(A)&#125;console.log(A)// 结果 A B 0","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"1. 作用域变量","slug":"es6/1.作用域变量","date":"2019-03-01T03:12:06.000Z","updated":"2019-06-06T08:33:09.000Z","comments":true,"path":"2019/03/01/es6/1.作用域变量/","link":"","permalink":"http://yoursite.com/2019/03/01/es6/1.作用域变量/","excerpt":"作用域就是变量的作用范围。也就是你声明一个变量以后，这个变量可以在什么场合下使用。以前的JavaScript只有全局作用域，和函数作用域。","text":"作用域就是变量的作用范围。也就是你声明一个变量以后，这个变量可以在什么场合下使用。以前的JavaScript只有全局作用域，和函数作用域。 作用域就是变量的作用范围。也就是你声明一个变量以后，这个变量可以在什么场合下使用。以前的JavaScript只有全局作用域，和函数作用域。 var的问题1.var 没有块级作用域，定义后在当前包中都都可以访问，如果变量名重复，就会覆盖前面定义的变量，并且很可以被他人修改。 1234if(true)&#123; var a = &quot;a&quot;; //期望a是某一个值&#125;console.log(a); 2.var 在for循环标记变量共享，一般在循环中会使用的i会被共享，其本质也是由于没有块级作用域造成的 123456789101112131415for (var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; alert(i); &#125;, 0); &#125; // 结果就是 弹窗三次 3 for ( i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; alert(i); &#125;, 0); &#125; // 结果就是 弹窗三次 0-2 块级作用域在用var定义变量的时候，变量通过闭包进行隔离的，现在用了let，不仅仅可以通过闭包隔离，还可以增加了一些块级作用域隔离。块级作用用一组大括号定义一个快，使用let定义的变量字啊大括号的外面是访问不到的。 实现会计作用域12345if(ture)&#123; let name = &apos;wjh&apos;&#125;consloe.log(&apos;name&apos;); // ReferenceError: name is not defined 不会污染全局对象 1234if(ture)&#123; let name = &apos;wjh&apos;&#125;console.log(window.name); // undefined for 循环中也可以使用i 123456789// 嵌套循环不会相互影响for (let i = 0; i &lt; 3; i++) &#123; console.log(&quot;out&quot;, i); for (let i = 0; i &lt; 2; i++) &#123; console.log(&quot;in&quot;, i); &#125;&#125;// 结果 out 0 in 0 in 1 out 1 in 0 in 1 out 2 in 0 in 1 重复定义会报错1234if(ture)&#123; let a = 1; let a = 2; //Identifier &apos;a&apos;&#125; 不存在变量的预解释123456for(let i = 0;i&lt;2;i++)&#123; console.log(&apos;inner&apos;,i); let i =100;&#125;// 结果 i is not defined 闭包的新写法123;(function()&#123;&#125;)(); 现在 123&#123;&#125;","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]}]}