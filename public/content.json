{"meta":{"title":"AsGiant-bolg","subtitle":null,"description":null,"author":"Mason Mei","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"es6/13. promise","date":"2019-06-06T01:12:03.000Z","updated":"2019-06-06T01:12:03.000Z","comments":true,"path":"2019/06/06/es6/13. promise/","link":"","permalink":"http://yoursite.com/2019/06/06/es6/13. promise/","excerpt":"","text":"13. promise 13.1 异步回调 13.1.1 回调地狱在需要多个操作的时间，会导致多个回调函数嵌套，导致代码不够直观，就常说的回调地域 13.1.2 并行结果如果几个异步操作之间并没有前后顺序之分，但需要等多个异步完成操作完成后才能执行后续的任务，无法实现并行节约时间 13.2 Promisepromise本意是承诺，在程序中的意思就是承诺我过一段时间后会给你一个结果。什么时间会用到过一段时间？答案是异步操作，异步是指可能比较长时间才有结果的才做，例如网络请求、读取本地文件等 13.3 Promise的三种状态 Pending Promise对象势力创建时候的初始化状态 Fulfilled 可以理解为成功的状态 Rejected 可以理解为失败的状态 then方法就是用来指定Promise 对象的状态改变时确定执行的操作，resolve时执行第一个函数（onFulfilled）,reject时执行第二函数（onRejected） 13.4 构造一个Promise 13.4.1 使用Promise123456789let promise = new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; if(Math.random()&gt;0.5) resolve('This is resolve!') else reject('This is reject') &#125;,1000);&#125;);promise.then(Fulfilled,Rejected) 构造一个Promise实例需要给Promise构造函数传入一个函数 传入的函数需要有两个形参，两个形参都是function类型的参数。 第一个形参运行后会让Promise实例处于resolve状态，所以我们一般给第一个形参命名为resolve，使 Promise对象的状态改变成成功，同时传递一个参数用于后续成功后的操作 第一个形参运行后悔让Promise实例处于reject状态，所以我们一般给第一个形参命名为reject，将Promise对象的状态改变为失败，同事将错误的信息传递到后续错误处理的操作 13.4.2 es5模拟Promise1234567891011121314function Promise(fn)&#123; this.success(data);&#125;,(error)=&gt;&#123; this.error();&#125;Promise.prtotype.resolve = function (data)&#123; this.success(data);&#125;Promise.prototype.then = function (success,error)&#123; this.success = success; this.error = error;&#125; #### 13.4.3 es5模拟Promise123456789101112131415161718192021222324class Promise&#123; constructor(fn)&#123; fn((data)=&gt;&#123; this.success(data); &#125;,(error)=&gt;&#123; this.error(); &#125;) &#125; resolve(data)&#123; this.success(data); &#125; reject(error)&#123; this.error(error); &#125; then(success,error)&#123; this.success = success; this.error = error; console.log(this); &#125;&#125; 13.5 promise 做为函数的返回值123456789101112131415161718192021222324function ajaxPromise(queryUrl)&#123; return new Promise((resolve,reject)=&gt;&#123; xhr.open('GET',queryUrl,ture); xhr.send(null); xhr.onreadystatechange = () =&gt;&#123; if(xhr.readyState === 4 )&#123; if(xhr.status === 200)&#123; resolve(xhr.responseText); &#125;else&#123; reject(xhr.responseText); &#125; &#125; &#125; &#125;)&#125;ajaxPromise('http://www.baidu.com') .then((value)=&gt;&#123; console.log(value); &#125;) .catch((err)=&gt;&#123; console.error(err); &#125;); 13.6 promise的链式调用 每次调用返回的都是一个新的Promise实例 链式调用的参数通过返回值传递 then 可以使用链式调用的写法原因在于，每一次执行该方法时总是会返回一个 Promise 对象 12345678910readFile('1.txt').then(function(data)&#123; console.log(data);&#125;).then(function (data)&#123; console.log(data); return readFile(data);&#125;).then(function (data)&#123; console.log(data);&#125;).catch(function (err)&#123; console.log(err);&#125;) 13.7 promise API 13.7.1 Promise.all 参数:接受一个数组，数组内都是Promise实例 返回值: 返回一个 promise 实例，这个promise 实例的状态转移取决于参数的 promise实例的状态变化。当参数处于resolve状态时，返回resolve状态。如果参数中任意一个实例处于reject状态，返回的promise实例变为reject状态。 123Promise.all([p1,p2]).then(function(result)&#123; console.log(result); //[ '2.txt', '2' ]&#125;) 不管两个promise谁先完成，Promise.all 方法会按照数组里面的顺序将结果返回 13.7.2 Promise.race 参数:接受一个数组，数组内都是Promise实例 返回值: 返回一个 promise 实例，这个promise 实例的状态转移取决于参数的 promise实例的状态变化。当参数处于resolve状态时，返回resolve状态。如果参数中任意一个实例处于reject状态，返回的promise实例变为reject状态。 123Promise.race([p1,p2]).then(function(result)&#123; console.log(result); //[ '2.txt', '2' ]&#125;) 13.7.3 Promise.resolve返回一个Promise 实例，这个实例处于resolve状态。根据传入的参数不同有不同的功能: 值(对象、数组、字符串等):作为resolve传递出去的值 Promise 实例 : 原封不动返回 Promise.reject返回一个Promise实例，这个实例处于reject状态 参数一般就是抛出的错误信息。 13.8 qQ是一个在Javascrip中实现promise的模块 13.8.1 q的基本用法123456789101112131415161718var Q = require('q');var fs = require('fs');function read(filename)&#123; var deferred = Q.defer(); fs.readFile(filename,'utf8',function)(err,data)&#123; if(err)&#123; deferred.reject(err); &#125;else&#123; deferred.resolve(data); &#125; &#125;);&#125;read('1.txt1').then(function(data)&#123; console.log(data);&#125;,funtcion(error)&#123; console.error(error); &#125;) 13.8.2 q的简单实现12345678910111213141516171819module.exports = &#123; defer()&#123; var _success,_error; return &#123; resolve(data)&#123; _success(data); &#125;, reject(err)&#123; _error(err); &#125;, promise:&#123; then(success,error)&#123; _success = success; _error = error; &#125; &#125; &#125; &#125;&#125; 13.8.3 q的实现123456789101112131415161718192021222324var defer = function () &#123; var pending = [], value; return &#123; resolve: function (_value) &#123; if (pending) &#123; value = _value; for (var i = 0, ii = pending.length; i &lt; ii; i++) &#123; var callback = pending[i]; callback(value); &#125; pending = undefined; &#125; &#125;, promise: &#123; then: function (callback) &#123; if (pending) &#123; pending.push(callback); &#125; else &#123; callback(value); &#125; &#125; &#125; &#125;;&#125;; 13.9 bluebird 实现 promise 标准的库是功能最全，速度最快的一个库 13.9.1 bluebird经典使用123456789101112var Promise = require('./bluebird');var readFile = Promise.promisify(require(\"fs\").readFile);readFile(\"1.txt\", \"utf8\").then(function(contents) &#123; console.log(contents);&#125;)var fs = Promise.promisifyAll(require(\"fs\"));fs.readFileAsync(\"1.txt\", \"utf8\").then(function (contents) &#123; console.log(contents);&#125;) 13.9.2 bluebird简单实现123456789101112131415161718192021222324module.exports = &#123; promisify(fn)&#123; return function () &#123; var args = Array.from(arguments); return new Promise(function (resolve, reject) &#123; fn.apply(null, args.concat(function (err) &#123; if (err) &#123; reject(err); &#125; else &#123; resolve(arguments[1]) &#125; &#125;)); &#125;) &#125; &#125;, promisifyAll(obj)&#123; for(var attr in obj)&#123; if(obj.hasOwnProperty(attr) &amp;&amp; typeof obj[attr] =='function')&#123; obj[attr+'Async'] = this.promisify(obj[attr]); &#125; &#125; return obj; &#125;&#125; 13.10 动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;move&lt;/title&gt; &lt;style&gt; .square&#123; width:40px; height:40px; border-radius: 50%; &#125; .square1&#123; background-color: red; &#125; .square2&#123; background-color: yellow; &#125; .square3&#123; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"square square1\" style=\"margin-left: 0\"&gt;&lt;/div&gt;&lt;div class=\"square square2\" style=\"margin-left: 0\"&gt;&lt;/div&gt;&lt;div class=\"square square3\" style=\"margin-left: 0\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var square1 = document.querySelector('.square1'); var square2 = document.querySelector('.square2'); var square3 = document.querySelector('.square3'); /*function move(element,target,resolve)&#123; let timer = setInterval(function()&#123; var marginLeft = parseInt(element.style.marginLeft, 10); if(marginLeft == target)&#123; resolve(); &#125;else&#123; element.style.marginLeft = ++marginLeft+'px'; &#125; &#125;,13); &#125;*/ function move(element,target,resolve)&#123; let current = 0; let timer = setInterval(function()&#123; element.style.transform=`translateX($&#123;++current&#125;px)`; if(current&gt;target)&#123; clearInterval(timer); resolve(); &#125;; &#125;,13); &#125; function animate(element,target)&#123; return new Promise(function(resolve,reject)&#123; move(element,target,resolve); &#125;); &#125; animate(square1,100) .then(function()&#123; return animate(square2,100); &#125;) .then(function()&#123; return animate(square3,100); &#125;);&lt;/script&gt;&lt;/html&gt; 13.11. co 13.11.1 co初体验1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let fs = require('fs');function getNumber()&#123; return new Promise(function (resolve,reject) &#123; setTimeout(function()&#123; let number = Math.random(); if(number &gt;.5)&#123; resolve(number); &#125;else&#123; reject('数字太小'); &#125; &#125;,1000); &#125;);&#125;function *read()&#123; let a = yield getNumber(); console.log(a); let b = yield 'b'; console.log(b); let c = yield getNumber(); console.log(c);&#125;function co(gen)&#123; return new Promise(function(resolve,reject)&#123; let g = gen(); function next(lastValue)&#123; let &#123;done,value&#125; = g.next(lastValue); if(done)&#123; resolve(lastValue); &#125;else&#123; if(value instanceof Promise)&#123; value.then(next,function(val)&#123; reject(val); &#125;); &#125;else&#123; next(value); &#125; &#125; &#125; next(); &#125;);&#125;co(read).then(function(data)&#123; console.log(data);&#125;,function(reason)&#123; console.log(reason);&#125;); 13.11.2 co连续读文件12345678910111213141516171819202122232425262728let fs = require('fs');function readFile(filename)&#123; return new Promise(function (resolve,reject) &#123; fs.readFile(filename,'utf8',function(err,data)&#123; if(err) reject(err); else resolve(data); &#125;) &#125;);&#125;function *read()&#123; let a = yield readFile('./1.txt'); console.log(a); let b = yield readFile('./2.txt'); console.log(b);&#125;function co(gen)&#123; let g = gen(); function next(val)&#123; let &#123;done,value&#125; = g.next(val); if(!done)&#123; value.then(next); &#125; &#125; next();&#125; 13.12 Promise/A+完整实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170function Promise(executor) &#123; let self = this; // 默认状态pending self.status = \"pending\"; // 此变量里放着此promise的结果 self.value = undefined; // 存放所有成功的回调函数 self.onResolvedCallbacks = []; // 存放所有的失败的回调函数 self.onRejectedCallbacks = []; // 调用方法promise 变成成功状态 // resolve的时候你把值传过来 function resolve(value) &#123; if (value instanceof Promise) &#123; return value.then(resolve, reject) &#125; setTimeout(function () &#123; // 异步执行所有的回调函数 if (self.status == 'pending') &#123; self.value = value; self.status = 'resolved'; self.onResolvedCallbacks.forEach(item =&gt; item(value)); &#125; &#125;); &#125; // 调用方法把当前promise变成失败 function reject(value) &#123; setTimeout(function () &#123; if (self.status == 'pending') &#123; self.value = value; self.status = 'rejected'; self.onRejectedCallbacks.forEach(item =&gt; item(value)); &#125; &#125;); &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; return reject(new TypeError('循环引用')); &#125; let then, called; if (x != null &amp;&amp; ((typeof x == 'object' || typeof x == 'function'))) &#123; try &#123; then = x.then; if (typeof then == 'function') &#123; then.call(x, function (y) &#123; if (called)return; called = true; resolvePromise(promise2, y, resolve, reject); &#125;, function (r) &#123; if (called)return; called = true; reject(r); &#125;); &#125; else &#123; resolve(x); &#125; &#125; catch (e) &#123; if (called)return; called = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125;// onFullfilled成功的回调,onReject失败的回调Promise.prototype.then = function (onFulfilled, onRejected) &#123; let self = this; onFulfilled = typeof onFulfilled == 'function' ? onFulfilled : function (value) &#123; return value &#125;; onRejected = typeof onRejected == 'function' ? onRejected : function (value) &#123; throw value &#125;; let promise2; if (self.status == 'resolved') &#123; promise2 = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; try &#123; let x = onFulfilled(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if (self.status == 'rejected') &#123; promise2 = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; try &#123; let x = onRejected(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if (self.status == 'pending') &#123; promise2 = new Promise(function (resolve, reject) &#123; self.onResolvedCallbacks.push(function (value) &#123; try &#123; let x = onFulfilled(value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); self.onRejectedCallbacks.push(function (value) &#123; try &#123; let x = onRejected(value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; return promise2;&#125;Promise.prototype.catch = function (onRejected) &#123; return this.then(null, onRejected);&#125;Promise.all = function (promises) &#123; return new Promise(function (resolve, reject) &#123; let result = []; let count = 0; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(function (data) &#123; result[i] = data; if (++count == promises.length) &#123; resolve(result); &#125; &#125;, function (err) &#123; reject(err); &#125;); &#125; &#125;);&#125;Promise.deferred = Promise.defer = function () &#123; var defer = &#123;&#125;; defer.promise = new Promise(function (resolve, reject) &#123; defer.resolve = resolve; defer.reject = reject; &#125;) return defer;&#125;/** * npm i -g promises-aplus-tests * promises-aplus-tests Promise.js */try &#123; module.exports = Promise&#125; catch (e) &#123;&#125;","categories":[],"tags":[]},{"title":"","slug":"es6/12. JavaScript(ES6) 中条件语句","date":"2019-06-06T01:11:50.000Z","updated":"2019-06-06T01:11:50.000Z","comments":true,"path":"2019/06/06/es6/12. JavaScript(ES6) 中条件语句/","link":"","permalink":"http://yoursite.com/2019/06/06/es6/12. JavaScript(ES6) 中条件语句/","excerpt":"","text":"12. JavaScript(ES6) 中条件语句 12.1 使用 Array.includes 来处理多个条件12345function test(fruit) &#123; if (fruit == 'apple' || fruit == 'strawberry') &#123; console.log('red'); &#125;&#125; 优化变成 -&gt;&gt; 12345678function test(fruit) &#123; // 条件提取到数组中 const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; if (redFruits.includes(fruit)) &#123; console.log('red'); &#125;&#125; 12.2 减少嵌套，提前使用 return 语句1234567891011121314151617181920212223function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1：fruit 必须有值 if (fruit) &#123; // 条件 2：必须为红色 if (redFruits.includes(fruit)) &#123; console.log('red'); // 条件 3：数量必须大于 10 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125; &#125; &#125; else &#123; throw new Error('No fruit!'); &#125;&#125; // 测试结果test(null); // 抛出错误：No fruitstest('apple'); // 打印：redtest('apple', 20); // 打印：red，big quantity 优化 123456789101112131415161718/* 在发现无效条件时提前 return */ function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1：提前抛出错误 if (!fruit) throw new Error('No fruit!'); // 条件2：必须为红色 if (redFruits.includes(fruit)) &#123; console.log('red'); // 条件 3：数量必须大于 10 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125; &#125;&#125; 为了减少一个嵌套层级，优化编码风格 123456789101112131415/* 在发现无效条件时提前 return */ function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; if (!fruit) throw new Error('No fruit!'); // 条件 1：提前抛出错误 if (!redFruits.includes(fruit)) return; // 条件 2：当 fruit 不是红色的时候，提前 return console.log('red'); // 条件 3：必须是大量存在 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125;&#125; 12.3 使用函数的默认参数 和 解构12345678910function test(fruit, quantity) &#123; if (!fruit) return; const q = quantity || 1; // 如果没有提供 quantity 参数，则默认为 1 console.log(`We have $&#123;q&#125; $&#123;fruit&#125;!`);&#125; // 测试结果test('banana'); // We have 1 banana!test('apple', 2); // We have 2 apple! 但是q在这边不直观所有优化 12345678function test(fruit, quantity = 1) &#123; // i如果没有提供 quantity 参数，则默认为 1 if (!fruit) return; console.log(`We have $&#123;quantity&#125; $&#123;fruit&#125;!`);&#125; // 测试结果test('banana'); // We have 1 banana!test('apple', 2); // We have 2 apple! 但是这边 也可能是个对象 12345678910// 解构 —— 只获得 name 属性// 参数默认分配空对象 &#123;&#125;function test(&#123;name&#125; = &#123;&#125;) &#123; console.log (name || 'unknown');&#125; //测试结果test(undefined); // unknowntest(&#123; &#125;); // unknowntest(&#123; name: 'apple', color: 'red' &#125;); // apple 12.4 选择 Map / Object 字面量，而不是Switch语句1234567891011121314151617function test(color) &#123; // 使用 switch case 语句，根据颜色找出对应的水果 switch (color) &#123; case 'red': return ['apple', 'strawberry']; case 'yellow': return ['banana', 'pineapple']; case 'purple': return ['grape', 'plum']; default: return []; &#125;&#125; //测试结果test(null); // []test('yellow'); // ['banana', 'pineapple'] 这边建议使用对象，更加清晰 12345678910// 使用对象字面量，根据颜色找出对应的水果 const fruitColor = &#123; red: ['apple', 'strawberry'], yellow: ['banana', 'pineapple'], purple: ['grape', 'plum'] &#125;; function test(color) &#123; return fruitColor[color] || [];&#125; 但是这边是很有可能为网络数据，无法判断red这样的变量，那么就用arry.filter 来过滤 1234567891011121314const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'strawberry', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'pineapple', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125;, &#123; name: 'plum', color: 'purple' &#125;]; function test(color) &#123; // 使用 Array filter ，根据颜色找出对应的水果 return fruits.filter(f =&gt; f.color == color);&#125; 12.5 使用 Array.every 和 Array.some 来处理全部/部分满足条件我们想检查所有水果是否都是红色的 1234567891011121314151617const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125; ]; function test() &#123; let isAllRed = true; // 条件：所有的水果都必须是红色 for (let f of fruits) &#123; if (!isAllRed) break; isAllRed = (f.color == 'red'); &#125; console.log(isAllRed); // false&#125; 使用 arry.every来过滤 123456789101112const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125; ]; function test() &#123; // 条件：简短方式，所有的水果都必须是红色 const isAllRed = fruits.every(f =&gt; f.color == 'red'); console.log(isAllRed); // false&#125; 如果我们想要检查是否有至少一个水果是红色的，我们可以使用 Array.some 仅用一行代码就实现出来 123456789101112const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125;]; function test() &#123; // 条件：是否存在红色的水果 const isAnyRed = fruits.some(f =&gt; f.color == 'red'); console.log(isAnyRed); // true&#125;","categories":[],"tags":[]},{"title":"","slug":"es6/11. 模块","date":"2019-06-06T01:11:44.000Z","updated":"2019-06-06T01:11:44.000Z","comments":true,"path":"2019/06/06/es6/11. 模块/","link":"","permalink":"http://yoursite.com/2019/06/06/es6/11. 模块/","excerpt":"","text":"11. 模块可以根据应用的需求吧代码分成不同的模块，每个模块里可以导出它需要让其他模块使用的东西，在其他模块里面可以导入这些模块，导出的东西。 11.1 模块在浏览器中使用模块需要借助 导出 12export var name = 'wjh';export var age = 8; 导入 123//import &#123;name,age&#125; from './school.js';import * as school from './school.js';console.log(school.name,school.age); 在页面中引用 1234&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/traceur.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/BrowserSystem.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://google.github.io/traceur-compiler/src/bootstrap.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt; 11.2 重命名导出时重命名 1234function say()&#123; console.log('say');&#125;export &#123;say as say2&#125;; 导入时重命名 1import &#123;say2 as say3&#125; from &apos;./school.js&apos; 11.3 默认导出每个模块都可以有一个默认要导出的东西 123export default function say()&#123; console.log('say')&#125; 导入 1import say from './school.js' 11.4 深度克隆123456789101112131415161718192021222324252627282930313233343536373839var parent = &#123; age: 5, hobby: [1, 2, 3], home: &#123;city: '北京'&#125;,&#125;;var child = extendDeep(parent);child.age = 6;child.hobby.push('4');child.home.city = '广东';console.log('child ', child); //[1, 2, 3, 4]console.log('parent ', parent);function extend(parent) &#123; let child; if (Object.prototype.toString.call(parent) == '[object Object]') &#123; child = &#123;&#125;; for (let key in parent) &#123; child[key] = extend(parent[key]) &#125; &#125; else if (Object.prototype.toString.call(parent) == '[object Array]') &#123; child = parent.map(item =&gt; extend(item)); &#125; else &#123; return parent; &#125; return child;&#125;function extendDeep(parent, child) &#123; child = child || &#123;&#125;; for (var key in parent) &#123; if (typeof parent[key] === \"object\") &#123; child[key] = (Object.prototype.toString.call(parent[key]) === \"[object Array]\") ? [] : &#123;&#125;; extendDeep(parent[key], child[key]); &#125; else &#123; child[key] = parent[key]; &#125; &#125; return child;&#125;","categories":[],"tags":[]},{"title":"","slug":"es6/10. 集合","date":"2019-06-06T01:11:34.000Z","updated":"2019-06-06T01:11:34.000Z","comments":true,"path":"2019/06/06/es6/10. 集合/","link":"","permalink":"http://yoursite.com/2019/06/06/es6/10. 集合/","excerpt":"","text":"10. 集合 10.1 Set 一个Set是一堆东西的集合，Set 有点像数组，不过跟数组不一样的是，Set里面不能有重复的内容 1234567891011121314var books = new Set();books.add('js');books.add('js');//添加重复元素的集合元素个数不会变化books.add('html');books.forEach(function(book)&#123; // 循环集合 console.log(book);&#125;)console.log(book.size);//集合中元数的个数console.log(books.has('js'));//判断集合是否有此元素books.delete('js');console.log(books.size);console.log(books.has('js'));books.clear();//清空setconsole.log(books.size); 10.2 Map 可以使用Map来组织这个名值对的数据 1234567891011var books = new Map();books.set('js',&#123;name:'js'&#125;);//向map中添加元素books.set('html',&#123;name:'html'&#125;);console.log(books.size);//查看集合中的元素console.log(books.get('js'));//通过key获取值books.delete('js');//执行key删除元素console.log(books.has('js'));//判断map中有没有keybook.forEach((value,key)=&gt;&#123; console.log(key+'='+value);&#125;)books.clear();//清空map","categories":[],"tags":[]},{"title":"","slug":"es6/9. 生成器(Generator)与迭代器(Iterator)","date":"2019-06-06T01:11:27.000Z","updated":"2019-06-06T01:11:27.000Z","comments":true,"path":"2019/06/06/es6/9. 生成器(Generator)与迭代器(Iterator)/","link":"","permalink":"http://yoursite.com/2019/06/06/es6/9. 生成器(Generator)与迭代器(Iterator)/","excerpt":"","text":"9. 生成器(Generator)与迭代器(Iterator)Generator 是一个特殊的函数，执行它会返回一个Iterator对象。通过遍历迭代器，Generator函数运行后悔返回遍历器对象，而不是函数的返回值。 9.1 Iterators模拟迭代器有一个next方法，每次执行的时候会返回一个对象 对象里面有两个函数，一个是value表示返回的值，还有就是布尔值done，表示是迭代完成 1234567891011121314151617181920function buy(books)&#123; let i = 0; return&#123; next()&#123; let done = i ===books.length; let value = !done ? books[i++]:undefined; return &#123; value:value, done:done &#125; &#125; &#125;&#125;let iterators = buy(['js','html']);var curr;do&#123; curr = iterators.next(); console.log(curr);&#125;while(!curr.done); 9.3 Generators生成器用于创建迭代器 1234567891011function* buy(boos)&#123; for(var i=0;i&lt;boos.length;i++)&#123; yield books[i]; &#125;&#125;let buying = buy(['js','html]);var curr;do &#123; curr = buying.next(); console.log(curr);&#125;while(!curr.done);","categories":[],"tags":[]},{"title":"","slug":"es6/8. 类","date":"2019-06-06T01:11:21.000Z","updated":"2019-06-06T01:11:21.000Z","comments":true,"path":"2019/06/06/es6/8. 类/","link":"","permalink":"http://yoursite.com/2019/06/06/es6/8. 类/","excerpt":"","text":"8. 类 8.1 class 使用 class 这个关键词定义一个类，基于这个创建实例以后就会创建 constructor 方法，此方法可以用来初始化 12345678910111213class Person&#123; constructor(name)&#123; this.name = name; &#125; getName()&#123; console.log(this.name) &#125;&#125;let person = new Person('wjh');person.getName(); 8.2 get与set getter 可以用来获取属性,setter 可以去设置属性 123456789101112131415class Person &#123; constructor()&#123; this.hobbies = []; &#125; set hobby(hobby)&#123; this.hobbies.push(hobby); &#125; get hobby()&#123; return this.hobbies; &#125;&#125;let person = new Person();person.hobby = 'aa';person.hobby = 'bb';console.log(person.hobby) 8.3 静态方法-static 在类里面添加静态的方法可以使用static 这个关键词，静态方法就是不需要实例化类就能使用的方法 123456class Person&#123; static add(a,b)&#123; return a+b; &#125;&#125;console.log(Person.add(1,x)); 8.4 继承extends 一个类可以继承其他的类里的东西 123456789101112131415class Person&#123; constructor(name)&#123; this.name = name; &#125;&#125;class Teacher extends Person&#123; constructor(name,age)&#123; super(name); this.age = age; &#125;&#125;var teacher = Teacher('wjh',8);console.log(teacher.name,teacher.age)","categories":[],"tags":[]},{"title":"","slug":"es6/7. 对象","date":"2019-06-06T01:11:15.000Z","updated":"2019-06-06T01:11:15.000Z","comments":true,"path":"2019/06/06/es6/7. 对象/","link":"","permalink":"http://yoursite.com/2019/06/06/es6/7. 对象/","excerpt":"","text":"7. 对象 7.1 对象字面量 如果你想在对象里添加跟变量名一样的属性，并且属性的值就是变量表示的值就可以直接在对象里加上这些属性 1234567891011let name = 'wjh';let age = 8;let getName = function()&#123; console.log(this.name)&#125;let person =&#123; name, age, getName&#125;person.getName(); 7.2 Object.is 对比两个值是否相等 1console.log(Object.is(NaN,NaN)); 7.3 Object.assign 把多个对象的属性复制到一个对象中，第一个参数是复制的对象，从第二个参数开始往后，都是复制的源对象 12345678910var nameObj = &#123;name:'wjh'&#125;var ageObj = &#123;age:8&#125;;var obj = &#123;&#125;;Object.assign(obj,nameObj,ageObj);console.log(obj);//克隆对象function clone(obj)&#123; return Object.assgin(&#123;&#125;,obj);&#125; 7.4 Object.setPrototypeOf 将一个指定的对象原型设置为另一个对象或者null 123456789var obj1 = &#123;name:'wjh1'&#125;;var obj2 = &#123;name:'wjh2'&#125;;var obj = &#123;&#125;;Object.setPrototypeOf(obj,obj1);console.log(obj.name);console.log(Object.getPrototypeOf(obj));Object.setProtoypeOF(obj,obj2);console.log(obj.name);console.log(Object.getPrototypeOf(obj)); 7.5 proto 直接对象表达式中设置prototype 123456var obj1 = &#123;name:&apos;wjh&apos;&#125;;var obj3 = &#123; _proto_:obj1&#125; console.log(obj3.name);console.log(Object.getPrototypeOf(obj3)); 7.6 super 通过super可以调用protype上的属性或方法 123456789101112let person =&#123; eat()&#123; return 'milk'; &#125;&#125;let student = &#123; _proto_:person, eat()&#123; return super.eat()+'bead' &#125;&#125;console.log(student.eat());","categories":[],"tags":[]},{"title":"","slug":"es6/6. 数组的新方法","date":"2019-06-06T01:11:08.000Z","updated":"2019-06-06T01:11:08.000Z","comments":true,"path":"2019/06/06/es6/6. 数组的新方法/","link":"","permalink":"http://yoursite.com/2019/06/06/es6/6. 数组的新方法/","excerpt":"","text":"6. 数组的新方法1234567891011121314151617181920212223// 相同的阵列var people = [ &#123; name : 'Casper' , like : '锅烧意面' , age : 18 &#125;, &#123; name : 'Wang' , like : '炒面' , age : 24 &#125;, &#123; name : 'Bobo' , like : '萝卜泥' , age : 1 &#125;, &#123; name : '卤蛋' , like : '萝卜泥' , age : 3 &#125;]; 6.1.Array.prototype.filter() filter() 会回传一个阵列，其条件是return 后方为true 的物件，很适合用在搜寻符合条件的资料。 12345678var filterEmpty = people.filter( function ( item, index, array ) &#123;&#125;);console .log(filterEmpty); //没有条件，会是一个空阵列var filterAgeThan5 = people.filter( function ( item, index, array ) &#123; return item.age &gt; 5 ; //取得大于五岁的 如果这边符合条件 只要为ture即可&#125;);console .log(filterAgeThan5); // Casper, Wang这两个物件 6.2.Array.prototype.find() find()与filter()很像，但find() 只会回传一次值，且是第一次为true的值。 12345678910111213var findEmpty = people.find( function ( item, index, array ) &#123;&#125;);console .log(findEmpty); //没有条件，会是undefinedvar findAgeThan5 = people.find( function ( item, index, array ) &#123; return item.age &gt; 5 ; //取得大于五岁的&#125;);console .log(findAgeThan5); //虽然答案有两个，但只会回传Casper这一个物件var findLike = people.find( function ( item, index, array ) &#123; return item.like === '萝卜泥' ; //取得阵列like === '萝卜泥'&#125;);console .log(findLike); //虽然答案有两个，但只会回传第一个Bobo物件 6.3.Array.prototype.forEach() forEach 是这几个阵列函式最单纯的一个，不会额外回传值，只单纯执行每个阵列内的物件或值。 1234567891011var forEachIt = people.forEach( function ( item, index, array ) &#123; console .log(item, index, array); //物件,索引,全部阵列 return item; // forEach没在return的，所以这边写了也没用&#125;);console .log(forEachIt); // undefinedpeople.forEach( function ( item, index, array ) &#123; item.age = item.age + 1 ; // forEach就如同for，不过写法更容易&#125;);console .log(people); //全部age + 1 6.4 Array.prototype.map() 使用map() 时他需要回传一个值，他会透过函式内所回传的值组合成一个阵列。如果不回传则是 undefined回传数量等于原始阵列的长度这很适合将原始的变数运算后重新组合一个新的阵列。 12345678910111213141516171819202122232425var mapEmpty = people.map( function ( item, index, array ) &#123;&#125;);console .log(mapEmpty); // [undefined, undefined, undefined, undefined]var mapAgeThan5 = people.map( function ( item, index, array ) &#123; return item.age &gt; 5 ; //比较大于五岁的&#125;);console .log(mapAgeThan5); // [true, true, false, false]var mapAgeThan5_2 = people.map( function ( item, index, array ) &#123; // 错误示范 if (item.age &gt; 5 ) &#123; return item; //回传大于五岁的 &#125; return false ; //别以为空的或是false就不会回传&#125;);console .log(mapAgeThan5_2); // [&#123;name: 'Casper'...&#125;, &#123;name: 'Wang'...&#125;, false, false]var mapEat = people.map( function ( item, index, array ) &#123; if (item.like !== '萝卜泥' ) &#123; return ` $&#123;item.like&#125;好吃` ; &#125; else &#123; return ` $&#123;item.like&#125;不好吃` ; &#125;&#125;);console .log(mapEat); // [\"锅烧意面好吃\", \"炒面好吃\", \"萝卜泥不好吃\", \"萝卜泥不好吃\"] 6.5 Array.prototype.every() every()可以检查所有的阵列是否符合条件，这仅会回传一个值trueor false，可以用来检查阵列中的内容是否符合特定条件。 12345678910var ans = array.every( function ( item, index, array ) &#123; console .log(item, index, array); //物件,索引,全部阵列 return item.age &gt; 10 //当全部age大于10才能回传true&#125;);console .log(ans); // false:只要有部分不符合，则为falsevar ans2 = array.every( function ( item, index, array ) &#123; return item.age &lt; 25&#125;);console .log(ans2); // true:全部age都小于25 6.6 Array.prototype.some() some() 与every() 非常接近，都是回传true or false，差异仅在every() 需完全符合，some() 仅需要部分符合。 1234567891011121314var ans = people.some( function ( item, index, array ) &#123; return item.age &gt; 10 //当全部age大于10才能回传true&#125;);console .log(ans); // true:只要有部分符合，则为truevar ans2 = people.some( function ( item, index, array ) &#123; return item.age &lt; 25&#125;);console .log(ans2); // true:只要有部分符合，则为true var ans2 = people.some( function ( item, index, array ) &#123; return item.age &gt; 25&#125;);console .log(ans2); // false:全部都不符合则为false 6.7 Array.prototype.reduce() reduce() 和其他几个差异就很大了，他可以与前一个回传的值再次作运算，参数包含以下：accumulator: 前一个参数，如果是第一个阵列的话，值是以另外传入或初始化的值currentValue: 当前变数currentIndex: 当前索引array: 全部阵列 12345678910111213141516var reduceEmpty = people.reduce( function ( accumulator, currentValue, currentIndex, array ) &#123;&#125;);console .log(reduceEmpty); //没有条件，会是undefinedvar reducePlus = people.reduce( function ( accumulator, currentValue, currentIndex, array ) &#123; // 分别为前一个回传值, 目前值, 当前索引值 console .log(accumulator, currentValue, currentIndex); return accumulator + currentValue.age; //与前一个值相加&#125;, 0 ); //传入初始化值为0console .log(reducePlus); //总和为46var reducePlus = people.reduce( function ( accumulator, currentValue, currentIndex, array ) &#123; console .log( 'reduce' , accumulator, currentValue, currentIndex) return Math .max( accumulator, currentValue.age ); //与前一个值比较哪个大&#125;, 0 );console .log(reducePlus); //最大值为24","categories":[],"tags":[]},{"title":"","slug":"es6/5. 函数","date":"2019-06-06T01:10:59.000Z","updated":"2019-06-06T01:10:59.000Z","comments":true,"path":"2019/06/06/es6/5. 函数/","link":"","permalink":"http://yoursite.com/2019/06/06/es6/5. 函数/","excerpt":"","text":"5. 函数 5.1 默认参数可以给定义的函数接收的参数设置默认的值 在执行这个函数的时候，如果不指定函数的参数的值，就会使用参数的这些默认的值。 12345function ajax(url,method='GET',dataType=\"json\")&#123; console.log(url); console.log(method); console.log(dataType);&#125; 5.2 展开操作符把…放在数组前面可以把一个数组进行展开，可以把一个函数而不需要使用apply 1234567891011121314151617181920212223//传入参数let print = function(a,b,c)&#123; console.log(a,b,c);&#125;print([1,2,3]);print(...[1,2,3]);// 可以替代applyvar m1 = Math.max.apply(null, [8, 9, 4, 1]);var m2 = Math.max(...[8, 9, 4, 1]);// 可以替代concatvar arr1 = [1, 3];var arr2 = [3, 5];var arr3 = arr1.concat(arr2);var arr4 = [...arr1, ...arr2];console.log(arr3,arr4);//类数组的转数组function max(a,b,c) &#123; console.log(Math.max(...arguments));&#125;max(1, 3, 4); 5.3 剩余操作符剩余操作符可以把其余参数的值放在一个叫做b的数组里 1234let rest = function(a,...rest)&#123; console.log(a,rest);&#125;rest(1,2,3); 5.4 解构参数1234let destruct = function(&#123;name,age&#125;)&#123; console.log(name,age);&#125;destruct(&#123;name:'wjh',age:10&#125;) 5.6 箭头函数箭头函数简化了函数的定义方式 1[1,2,3].forEach(val=&gt;console.log(val)); 输入参数如果多于一个要用()包含，函数体如果有多条语句需要用{}包起来 箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。 正是因为它没有this，从而避免了this指向的问题。 12345678var person = &#123; name:'wjh', getName:function()&#123;- setTimeout(function()&#123;console.log(this);&#125;,1000); //在浏览器执行的话this指向window+ setTimeout(() =&gt; console.log(this),1000);//在浏览器执行的话this指向person &#125;&#125;person.getName();","categories":[],"tags":[]},{"title":"","slug":"es6/4. 字符串","date":"2019-06-06T01:10:51.000Z","updated":"2019-06-06T01:10:51.000Z","comments":true,"path":"2019/06/06/es6/4. 字符串/","link":"","permalink":"http://yoursite.com/2019/06/06/es6/4. 字符串/","excerpt":"","text":"4. 字符串 4.1 模板字符串模板字符串用反应号(数字1左边的那个建)包含，用${}括起来 12345678910var name = 'zfpx',age = 8;let desc = `$&#123;name&#125; is $&#123;age&#125; old!`;console.log(desc);//所有模板字符串的空格和换行，都是被保留的var str = `&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;b&lt;/li&gt;&lt;/ul&gt;`;console.log(str); 其中的变量会用变量的值替换掉 12345function replace(desc)&#123; return desc.replace(/\\$\\&#123;([^&#125;]+)\\&#125;/g,function(matched,key)&#123; return eval(key); &#125;);&#125; 4.2 带标签的模板字符串可以在模板字符串的前面添加一个标签，这个标签可以去处理模板字符串 标签其实就是一个函数,函数可以接收两个参数,一个是 strings 就是模板字符串里的每个部分的字符 还有一个参数可以使用rest的形式values,这个参数里面是模板字符串里的值。 12345var name = 'wjh',age = 8;function desc(strings,...values)&#123; console.log(strings,values);&#125;desc`$&#123;name&#125; is $&#123;age&#125; old!`; 字符串新方法 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 1234var s = 'wjh';s.startsWith('w') // trues.endsWith('h') // trues.includes('j') // true 第二个参数，表示开始搜索的位置 1234var s = &apos;wjh&apos;;console.log(s.startsWith(&apos;j&apos;,2)); // trueconsole.log(s.endsWith(&apos;j&apos;,2)); // trueconsole.log(s.includes(&apos;j&apos;,2)); // false endsWith的行为与其他其他方法有所不同。它针对前n个字符，而其他方法是从第几位开始到字符串结束 4.4 repeatrepeat 方法返回一个新字符串，表示将原字符串重复n次。 12&apos;x&apos;.repeat(3);&apos;x&apos;.repeat(0);","categories":[],"tags":[]},{"title":"个人简历","slug":"resume","date":"2019-06-05T03:19:04.000Z","updated":"2019-06-05T15:55:18.000Z","comments":true,"path":"2019/06/05/resume/","link":"","permalink":"http://yoursite.com/2019/06/05/resume/","excerpt":"","text":"梅衍青 男 ︳ 23岁 ︳大专 ︳ 2年工作经验 ︳ 上海 17621515830 ︳954663633@qq.com 上海工商职业技术学院 移动互联网方向 技能 前端：HTML、CSS、JavaScript前端框架: vue、webpack、cordova、react-native，微信小程序后端：php、node后端框架: thinkphp、express、koa2、egg数据库:mysql、mongodb、redis 版本控制：git、svn 工作经历 上海子杰软件有限公司 2017.01-2018-06 快睿登信息科技(上海)有限公司 2018.06-至今** 项目经验 一、风驰后台v0.2&amp;小通分期v0.2 2019.2-至今项目内容:风驰后台、小通分期(汇宝通)作为第二期项目的迭代。小通分期，增加分期功能。技术栈:avuex、vue全家桶、cordva、webpack、less项目类型:网页、app项目经验:技术点调用cordva插件，获取手机通讯录、GPS、联系人、电量、极光推送等原生功能。同时迭代风驰后台的页面系统，用户量也大量增加后发现并且处理一些关于手机适配的问题(主要是因为cordva是调用手机中的内核浏览器，出现了css3不兼容的问题)二、重构风驰后台v0.1 2018年12 – 2019-2项目内容:计划迭代汇宝通后台中，我提出了以下问题。1.前后端有绑定关系，发布后，前后端的这种依赖。2.ui的局限，后台都是使用敏捷开发，那么意味着很多组件是根据技术选型的时候就确定了的。我们现有的框架无法做到ui升级。选择迁回老风驰工程量也会很大(这里的重写包括语法结构都需要重写),选择强行在先有ui框架上修改，工程量无法估计。3.需求其实不是很明确的，只能参照老风驰的样子做，新老风驰经手的人都比较多，都是有什么需求直接加什么需求，但是具体权限和细节根据时间的推移，没有任何文档可以参照，所以建议重构。技术栈:avuex、vue全家桶项目类型:网页项目经验：当时遇到了一个问题，就是这套后台必须兼容手机端的问题，element-ui的缺点也提现出来的，那就是对于手机端的适配，很多插件都会有问题，第二个问题就是前端人手紧缺，原来使用的架构，人手上无法维护。加上时间比较紧张，经过调研，采用了avuex的框架方案，该方案的优势在于json驱动ui的思想理念。以最快的速度，重构了风驰后台。 三、黑卡 2018.11-2018-12项目内容:根据个人资质情况，可以进行不同次数的征信洗白，享有最高100，000的额度利率低至银行利率，介绍老铁洗白征信，长期有效，连续签到一年，1000元大奖，三星级会员五星级酒店。技术栈: vue、cordva、webpack、less项目类型：app、网页项目经验：针对于先有公司项目的沉淀，公司决定开启黑卡项目业务，对于vue技术的了解和逐步深入后，公司也对于原生和动态交互提出了更高的要求，针对于目前项目的组件规划和开发。 四、汇宝通-后台 2018.08-2018-10项目内容: vue后台贷款系统，引流，贷款模块，用户模块，商品模块，进件模块，风控模块技术栈:vue、webpack、element-ui项目类型：网页项目经验:正对于现在走向组件化的趋势，配合公司领导，进行了后台组件的开发。将原先的贷款系统，引流，贷款模块，用户模块，商品模块，进件模块，风控模块拆分为各个模块，方便与后台页面随时的重构组装，服务与公司将部分模块卖给第三方公司的构想。 五、汇宝通-app 2018.07-2018-09项目内容: p2p的线上贷款系统，引流，贷款模块，用户模块，商品模块，进件模块，风控模块为一体的app项目。技术栈:vue、cordva、webpack、less项目类型：app、网页项目经验：离开上一家公司后，我开始了新的征程，这第一次对于node技术进行了了解。前端做到工程和模块的话处理，将人力减少到最小数的敏捷开发。对于项目负责人的架构进行了学习和梳理。了解了关于cordva的插件。对于三个端(网页，安卓，ios)的兼容性，达到最快的试错。对于webpack的改造项目工程目录，达到了，一份代码能兼容三个端，并且还能够调用原生的底层权限。 六、梯子网小程序 2018.01-2018-06项目内容: 梯子网为教育局和大型社会培训机构提供一站式多机构管理，其中主要涉及两个难点，一是多机构的管理，不同机构可以定制自己模块下的内容，只有本机构下的人可以看到。二是定制化产生页面，不同的机构可以定制自己的页面栏目，根据自己的需要展示对应的内容，这还涉及到了不同机构、角色的权限问题。项目类型: 微信小程序技术栈: wxml、wxss、js项目经验：冬去春来，公司决定实现一个小程序的工作规划，对于项目探索工作交给了我。对于视频的学习，可能因为有着react-native项目经验，对于新起的mvvm这样的设计思路有着充分的了解。所以上手写小程序，反而觉得比较简单。对于微信组件和api进行了了解和使用。对于wx.request进行了封装，和关于一些常用函数的封装，针对一些常用组件的封装。例如wx.getStorage、清空缓存、分享、弹窗等等。方便对于其他协作的伙伴调用和使用。 七、上海天马Portal系统 2017.11-2017.12项目内容: 上海天马Portal管理系统是为了在公司内部整合所有业务系统，规范统一入口，消息通知，业务处理，是业务统一入口，用户无需牢记各个应用系统的地址，降低用户使用时的困难，避免用户来回切换业务系统，提升用户工作效率。项目类型: 网页技术栈:layui、jquery、html项目经验:第一次带2个实习生一起工作，心里美滋滋啊(不排除项目比较简单)，关于前端我才用了layui框架，使用过bootstrap后，总觉得layui的页面的美观程度还是比bootstrap框架要优雅很多的。也让我开始了解代码的书写规范，按照美工的设计与后台的配合，完成了项目的进度。 八、英语学习-EnglishOnlie 2017.08-2017.10项目内容: 软件分学生端和教师端，学生端主要实现学习功能，学习进度通过闯关和教师操作控制，教师端主要实现管理功能，管理学生帐户，学习资源管理，学习进度管理。项目类型:app、网页、微信网页技术栈：react-native、html、jquery项目经验:这个公司遗留下的一个比较老的项目，不少组件使用的是react-android，不兼容ios的组件，这个工作的主要任务，就是将ios的兼容问题彻底的解决、并且兼容网页与微信网页。这个项目最大的特色应该就是学生读英语的功能，可以经过讯飞系统的语言识别，来判断学生的读音，从而给予评分。第一次了解了网页的录音和微信网页的录音调用是不同的，微信的调用，是不同的，微信有着自己独有的api。 九、玖龙移动销售 2017.05-2017.07项目内容: 在前端、管理查看集团的产品、订单、销售统计信息。项目类型:app技术栈:react-native项目经验:经过之前三个月的学习，加入了新的项目组，对于这个项目而言，并没有参加项目的原始的开发计划。当时公司其他的项目比较紧张，与项目组长两个人直接飞往东莞珑石集团技术部门，进行了bug的修复，刚刚参加项目的时候，主要是对于ios的适配问题进行了修复工作(因为我是mac),了解了关于ios的info.list。第一次对于ios白名单有所认识，了解了关于前端调用原生的，最大的问题，是关于一些原生的权限问题。 十、中国国际珠宝交易平台 2017.01-2017.04 项目内容: “中国国际珠宝交易平台” APP 具有产品搜索/浏览、商品购买、评价、退换货等功能项目类型:app技术栈:react-native项目经验:这个项目是加入前端组织行列的第一个项目，你知道在2017年，这个react-native在大环境下，其实我认为还不算很成熟，当时项目组没有什么这方面的技术，就自发的组织学习这项技术。几个通宵后的学习，学了基本上的flex布局，对于react-natve的特殊的css处理方法进行了了解，了解了fetch的网络请求方案，让工作的环境中还算能够使用这项技术，因为那时候刚刚入行，代码的稚嫩，如今看来还是有很大的问题。 开源项目 **https://github.com/MYQ1996/asGiant-admin.git项目内容: 基于egg架构的自动生成接口的框架 你可以这么理解这个框架，就是在你配置完数据后，就生成了增删改查接口，也同时生成了相关的栏目。 这样即使你是一个不懂后端的同学，你也可以直接调用接口给前端使用 _在这个项目中，我希望能解决，前端对于后端的不熟悉和了解，但是对于调用接口比较熟悉的业务现状。完成了以下模块。对于表的增删改查操作、增删改字段的信息、短信管理(只需配置短信的key)、邮箱管理(需配置邮箱的key)、人员注册(手机号、用户名、邮箱)、针对于字段添加了人员权限。之后的规划想做个cms，针对于seo的网站排名调优。对于增加之后，直接生成相对应的前端页面，使用node写了一个微信机器人，符合时代需求，达到人工智能，和机器人聊天的过程中，直接操作平台，完成接口的操作。希望之后，技术提升之后，能够够写出一套兼容性比较高的组件，直接配合平台的使用，有考虑过taro，但是感觉对于原生的调用不足，还在思考这部分的工作。最后达到敏捷开发的效果。(因为加班的缘故，所以一直没有做完)。 掘金博客 https://juejin.im/user/5b4e88986fb9a04fba6e752b 自我描述 对于技术出生，还是个大专。还是受到不少的压力的，现在毕竟都觉得本科生比较好培养嘛。我是15年进的大专。第一年被选中参加了，学校的比赛班，主要就是负责学校对外的比赛参加。大二开始不参加日常课程直接进入培训，大三进入校企合作上班。对于技术不断追求，热衷学习研究新技术，实践在项目中。对于前后端有着一定的理解，希望能达到技术一个新的高度。ps: 希望能和贵公司有着合作的机会，也希望能成为你的同事。","categories":[{"name":"个人简历","slug":"个人简历","permalink":"http://yoursite.com/categories/个人简历/"}],"tags":[{"name":"个人简历","slug":"个人简历","permalink":"http://yoursite.com/tags/个人简历/"}]},{"title":"解构","slug":"es6/3. 解构","date":"2019-03-01T06:21:58.000Z","updated":"2019-06-06T01:17:02.000Z","comments":true,"path":"2019/03/01/es6/3. 解构/","link":"","permalink":"http://yoursite.com/2019/03/01/es6/3. 解构/","excerpt":"","text":"解构数组解构意思就是分解一个东西的结构,可以用一种类似数组的方式定义N个变量，可以将一个数组中的值按照规则赋值过去。 12var [name,age]=['wjh',8];console.log(name,age); 嵌套赋值12345678910let [x,[y],z]=[1,[2.1]];console.log(x,y,z);let [x,[y,z]] = [1,[2.1,2.2]];console.log(x,y,z);let [json,arr,num] = [&#123;name:'wjw'&#125;,[1,2],3];console.log(json,arr,num);// 1 2.1 undefined 1 2.1 2.2 &#123; name: 'wjw' &#125; [ 1, 2 ] 3 省略赋值12let [,,x]=[1,2,3]console.log(x); 解构对象对象也可以被解构 123456var obj = &#123;name:'zfpx',age:8&#125;;//对象里的name属性的值会交给name这个变量，age的值会交给age这个变量var &#123;name,age&#125; = obj//对象里的name属性的值会交给myname这个变量，age的值会交给myage这个变量let &#123;name: myname, age: myage&#125; = obj;console.log(name,age,myname,myage); 默认值在赋值和传参的时候可以使用默认值 12345678910111213141516let [a='a',b='b',c=new Error('C必须指定')] = [1, , 3];console.log(a,b,c);function ajax(options)&#123; var method = options.method || \"get\"; var data = options.data || &#123;&#125;;&#125;function ajax(method='get',data)&#123; console.log(arguments);&#125;ajax(&#123; method:'post', data:&#123;'name':'wjh'&#125;&#125;)","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"常量","slug":"es6/2.常量","date":"2019-03-01T05:21:58.000Z","updated":"2019-06-06T01:07:12.000Z","comments":true,"path":"2019/03/01/es6/2.常量/","link":"","permalink":"http://yoursite.com/2019/03/01/es6/2.常量/","excerpt":"","text":"使用 const 我们可以声明一个常量，一旦声明之后，就不可以更改。 常量不能重新赋值12const MY_NAME = 'zfpx';MY_NAME = 'zfpx2';//Assignment to constant variable 变量可以改变 注意const限制的是不能给变量重新赋值，而变量的值本身是可以改变的,下面的操作是可以的 123const names = ['zfpx1'];names.push('zfpx2');console.log(names); 不同的块级作用域可以多次定义123456789101112const A = \"0\";&#123; const A = \"A\"; console.log(A)&#125;&#123; const A = \"B\"; console.log(A)&#125;console.log(A)// 结果 A B 0","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"作用域变量","slug":"es6/1.作用域变量","date":"2019-03-01T03:12:06.000Z","updated":"2019-06-06T01:04:51.000Z","comments":true,"path":"2019/03/01/es6/1.作用域变量/","link":"","permalink":"http://yoursite.com/2019/03/01/es6/1.作用域变量/","excerpt":"","text":"作用域就是变量的作用范围。也就是你声明一个变量以后，这个变量可以在什么场合下使用。以前的JavaScript只有全局作用域，和函数作用域。 var的问题1.var 没有块级作用域，定义后在当前包中都都可以访问，如果变量名重复，就会覆盖前面定义的变量，并且很可以被他人修改。 1234if(true)&#123; var a = &quot;a&quot;; //期望a是某一个值&#125;console.log(a); 2.var 在for循环标记变量共享，一般在循环中会使用的i会被共享，其本质也是由于没有块级作用域造成的 123456789101112131415for (var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; alert(i); &#125;, 0); &#125; // 结果就是 弹窗三次 3 for ( i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; alert(i); &#125;, 0); &#125; // 结果就是 弹窗三次 0-2 块级作用域在用var定义变量的时候，变量通过闭包进行隔离的，现在用了let，不仅仅可以通过闭包隔离，还可以增加了一些块级作用域隔离。块级作用用一组大括号定义一个快，使用let定义的变量字啊大括号的外面是访问不到的。 实现会计作用域12345if(ture)&#123; let name = &apos;wjh&apos;&#125;consloe.log(&apos;name&apos;); // ReferenceError: name is not defined 不会污染全局对象 1234if(ture)&#123; let name = &apos;wjh&apos;&#125;console.log(window.name); // undefined for 循环中也可以使用i 123456789// 嵌套循环不会相互影响for (let i = 0; i &lt; 3; i++) &#123; console.log(&quot;out&quot;, i); for (let i = 0; i &lt; 2; i++) &#123; console.log(&quot;in&quot;, i); &#125;&#125;// 结果 out 0 in 0 in 1 out 1 in 0 in 1 out 2 in 0 in 1 重复定义会报错1234if(ture)&#123; let a = 1; let a = 2; //Identifier &apos;a&apos;&#125; 不存在变量的预解释123456for(let i = 0;i&lt;2;i++)&#123; console.log(&apos;inner&apos;,i); let i =100;&#125;// 结果 i is not defined 闭包的新写法123;(function()&#123;&#125;)(); 现在 123&#123;&#125;","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]}]}