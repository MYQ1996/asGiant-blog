{"meta":{"title":"AsGiant-bolg","subtitle":null,"description":null,"author":"Mason Mei","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"2 axios在项目中的运用","slug":"axios/2 axios在项目中的运用","date":"2019-06-11T12:19:05.000Z","updated":"2019-06-11T12:31:19.000Z","comments":true,"path":"2019/06/11/axios/2 axios在项目中的运用/","link":"","permalink":"http://yoursite.com/2019/06/11/axios/2 axios在项目中的运用/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183/** * 全站http配置 * * axios参数说明 * isSerialize是否开启form表单提交 * isToken是否需要token */import axios from 'axios'import store from '@/store/';import router from '@/router/router'import &#123; serialize &#125; from '@/util/util'import &#123;getToken,getRoleTitle&#125; from '@/util/auth' // 获取相对应的权限import &#123;Message&#125; from 'element-ui' // 调用弹窗组件import website from '@/config/website'; // statusWhiteList 通过此处，获取白名单，默认[400]import NProgress from 'nprogress' // progress bar vue中的进度条import 'nprogress/nprogress.css' // progress bar styleimport Cookies from 'js-cookie'axios.defaults.timeout = 20000; // 设置超时时间// 返回其他状态吗// 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。// 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，// promise 将被 resolve; 否则，promise 将被 rejecteaxios.defaults.validateStatus = function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt;= 500; // 默认的&#125;;//跨域请求，允许保存cookieaxios.defaults.withCredentials = true;// NProgress Configuration// 通过设置为false关闭加载旋转器。(默认值是ture)NProgress.configure(&#123; showSpinner: false&#125;);//HTTPrequest拦截-添加请求拦截器axios.interceptors.request.use(config =&gt; &#123; NProgress.start() // start progress bar 加载器开始加载 const meta = (config.meta || &#123;&#125;); // const isToken = meta.isToken === false; if (getToken() &amp;&amp; !isToken) &#123; config.headers['Admin.Authority.Token.cashloan'] = getToken(); // 'Bearer ' + getToken() // 让每个请求携带token--['Authorization']为自定义key 请根据实际情况自行修改 &#125; //headers中配置serialize为true开启序列化 是否开启form表单提交 if (config.methods === 'post' &amp;&amp; meta.isSerialize === true) &#123; config.data =config.data =&gt; &#123; let list = []; Object.keys(data).forEach(ele =&gt; &#123; list.push(`$&#123;ele&#125;=$&#123;data[ele]&#125;`) &#125;) return list.join('&amp;'); &#125;; &#125; return config &#125;, error =&gt; &#123; return Promise.reject(error)&#125;);//HTTPresponse拦截-添加响应拦截器axios.interceptors.response.use(res =&gt; &#123; NProgress.done(); // 进度条关闭 const status = Number(res.status) || 200; // 返回值必须是200 const statusWhiteList = website.statusWhiteList || []; // 白名单 400 const message = res.data.message || '未知错误'; // 确定的返回值或者是'未知错误' const code = res.data.code if (code === 11002) &#123; Message(&#123; message, type: \"error\" &#125;) &#125; if (code === 10004) &#123; Message(&#123; message: \"有另一台设备登录\", type: 'error' &#125;) store.dispatch('FedLogOut').then(() =&gt; router.push(&#123; path: '/login' &#125;)); &#125; if (code === 10001) &#123; Message(&#123; message: \"请重新登录\", type: 'error' &#125;) Cookies.set('loading', true) store.dispatch('FedLogOut').then(() =&gt; router.push(&#123; path: '/login' &#125;)); &#125; if (code === 10002) &#123; Message(&#123; dangerouslyUseHTMLString: true, message: `接口为$&#123;res.request.custom.url&#125;&lt;/br&gt;&lt;/br&gt;$&#123;getRoleTitle()&#125;没有权限`, type: 'error' &#125;) &#125; if (code === 10003) &#123; Message(&#123; dangerouslyUseHTMLString: true, message, type: 'error' &#125;) &#125; if (code === 404) &#123; Message(&#123; dangerouslyUseHTMLString: true, message: `接口为$&#123;res.request.custom.url&#125;&lt;/br&gt;&lt;/br&gt;$&#123;JSON.stringify(res.data)&#125;`, type: 'error' &#125;) &#125; if (code === 400) &#123; if (res.data.message.includes('/')) &#123; Message(&#123; dangerouslyUseHTMLString: true, message: message.split('/')[1], type: 'error' &#125;) return &#125; Message(&#123; dangerouslyUseHTMLString: true, message: `$&#123;JSON.stringify(res.data)&#125;`, type: 'error' &#125;) &#125; if (code === 500) &#123; if(!res.data.message.includes(\"TIMEOUT\"))&#123; Message(&#123; dangerouslyUseHTMLString: true, message:`服务器故障，请稍后重试`, // message: `接口为$&#123;res.request.custom.url&#125;&lt;/br&gt;&lt;/br&gt;$&#123;JSON.stringify(res.data)&#125;`, type: 'error' &#125;) &#125; &#125; //如果在白名单里则自行catch逻辑处理 if (statusWhiteList.includes(status)) return Promise.reject(res); //如果是401则跳转到登录页面 if (status === 401) store.dispatch('FedLogOut').then(() =&gt; router.push(&#123; path: '/login' &#125;)); // 如果请求为非200否者默认统一处理 if (status !== 200) &#123; Message(&#123; message: message, type: 'error' &#125;) return Promise.reject(new Error(message)) &#125; return res;&#125;, error =&gt; &#123; NProgress.done(); return Promise.reject(new Error(error));&#125;)export default axios;","categories":[{"name":"axios","slug":"axios","permalink":"http://yoursite.com/categories/axios/"}],"tags":[{"name":"axios","slug":"axios","permalink":"http://yoursite.com/tags/axios/"}]},{"title":"1 axios中文文档","slug":"axios/1 axios中文文档","date":"2019-06-11T11:19:05.000Z","updated":"2019-06-11T12:31:24.000Z","comments":true,"path":"2019/06/11/axios/1 axios中文文档/","link":"","permalink":"http://yoursite.com/2019/06/11/axios/1 axios中文文档/","excerpt":"","text":"什么是 axios？Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 axiosAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 特性 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 浏览器支持 Latest ✔ Latest ✔ Latest ✔ Latest ✔ Latest ✔ 8+ ✔ 安装使用 npm:使用 bower: 1npm install axios 1bower install axios 使用 cdn: 案例执行 GET 请求 123456789101112131415161718192021// 为给定 ID 的 user 创建请求axios.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 上面的请求也可以这样做axios.get('/user', &#123; params: &#123; ID: 12345 &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error); &#125;); 执行 POST 请求 12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行多个并发请求 123456789101112function getUserAccount() &#123; return axios.get('/user/12345');&#125;function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // 两个请求现在都执行完成&#125;)); axios API可以通过向 axios 传递相关配置来创建请求 axios(config)123456789// 发送 POST 请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;); 123456789// 获取远端图片axios(&#123; method:'get', url:'http://bit.ly/2mTM3nY', responseType:'stream'&#125;) .then(function(response) &#123; response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))&#125;); axios(url[, config])12// 发送 GET 请求（默认的方法）axios('/user/12345'); 请求方法的别名为方便起见，为所有支持的请求方法提供了别名 axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.options(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 注意在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 并发处理并发请求的助手函数 axios.all(iterable) axios.spread(callback) 创建实例可以使用自定义配置新建一个 axios 实例 axios.create([config])12345const instance = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123;'X-Custom-Header': 'foobar'&#125;&#125;); 实例方法以下是可用的实例方法。指定的配置将与实例的配置合并。 axios#request(config) axios#get(url[, config]) axios#delete(url[, config]) axios#head(url[, config]) axios#options(url[, config]) axios#post(url[, data[, config]]) axios#put(url[, data[, config]]) axios#patch(url[, data[, config]]) 请求配置这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&#123; // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // default // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: 'https://some-domain.com/api/', // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data, headers) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: &#123; firstName: 'Fred' &#125;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // default // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) &#123; /* ... */ &#125;, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: 'janedoe', password: 's00pers3cret' &#125;, // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // default // `responseEncoding` indicates encoding to use for decoding responses // Note: Ignored for `responseType` of 'stream' or client-side requests responseEncoding: 'utf8', // default // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: 'XSRF-TOKEN', // default // `xsrfHeaderName` is the name of the http header that carries the xsrf token value xsrfHeaderName: 'X-XSRF-TOKEN', // default // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // default // `socketPath` defines a UNIX Socket to be used in node.js. // e.g. '/var/run/docker.sock' to send requests to the docker daemon. // Only either `socketPath` or `proxy` can be specified. // If both are specified, `socketPath` is used. socketPath: null, // default // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 'proxy' 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: '127.0.0.1', port: 9000, auth: &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 响应结构某个请求的响应包含以下信息 123456789101112131415161718192021&#123; // `data` 由服务器提供的响应 data: &#123;&#125;, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: 'OK', // `headers` 服务器响应的头 headers: &#123;&#125;, // `config` 是为请求提供的配置信息 config: &#123;&#125;, // 'request' // `request` is the request that generated this response// It is the last ClientRequest instance in node.js (in redirects) // and an XMLHttpRequest instance the browser request: &#123;&#125;&#125; 使用 then 时，你将接收下面这样的响应 : 12345678axios.get('/user/12345') .then(function(response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config);&#125;); 在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用，正如在错误处理这一节所讲。 配置默认值你可以指定将被用在各个请求的配置默认值 全局的 axios 默认值123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 自定义实例默认值1234567// Set config defaults when creating the instanceconst instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);// Alter defaults after instance has been createdinstance.defaults.headers.common['Authorization'] = AUTH_TOKEN; 配置的优先顺序配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子： 123456789101112// 使用由库提供的配置的默认值来创建实例// 此时超时配置的默认值是 `0`var instance = axios.create();// 覆写库的超时默认值// 现在，在超时前，所有请求都会等待 2.5 秒instance.defaults.timeout = 2500;// 为已知需要花费很长时间的请求覆写超时设置instance.get('/longRequest', &#123; timeout: 5000&#125;); 拦截器在请求或响应被 then 或 catch 处理前拦截它们。 1234567891011121314151617// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); 如果你想在稍后移除拦截器，可以这样： 12const myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 可以为自定义 axios 实例添加拦截器 12const instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 错误处理12345678910111213141516171819axios.get('/user/12345') .catch(function (error) &#123; if (error.response) &#123; // The request was made and the server responded with a status code // that falls out of the range of 2xx console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); &#125; else if (error.request) &#123; // The request was made but no response was received // `error.request` is an instance of XMLHttpRequest in the browser and an instance of // http.ClientRequest in node.js console.log(error.request); &#125; else &#123; // Something happened in setting up the request that triggered an Error console.log('Error', error.message); &#125; console.log(error.config); &#125;); Y可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。 12345axios.get('/user/12345', &#123; validateStatus: function (status) &#123; return status &lt; 500; // Reject only if the status code is greater than or equal to 500 &#125;&#125;) 取消使用 cancel token 取消请求 Axios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。 可以使用 CancelToken.source 工厂方法创建 cancel token，像这样： 123456789101112131415161718192021const CancelToken = axios.CancelToken;const source = CancelToken.source();axios.get('/user/12345', &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message); &#125; else &#123; // 处理错误 &#125;&#125;);axios.post('/user/12345', &#123; name: 'new name'&#125;, &#123; cancelToken: source.token&#125;)// 取消请求（message 参数是可选的）source.cancel('Operation canceled by the user.'); 还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token： 123456789101112const CancelToken = axios.CancelToken;let cancel;axios.get('/user/12345', &#123; cancelToken: new CancelToken(function executor(c) &#123; // executor 函数接收一个 cancel 函数作为参数 cancel = c; &#125;)&#125;);// cancel the requestcancel(); 注意: 可以使用同一个 cancel token 取消多个请求 使用 application/x-www-form-urlencoded format默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。 浏览器在浏览器中，您可以使用URLSearchParams API，如下所示： 1234const params = new URLSearchParams();params.append('param1', 'value1');params.append('param2', 'value2');axios.post('/foo', params); 请注意，所有浏览器都不支持URLSearchParams（请参阅caniuse.com），但可以使用polyfill（确保填充全局环境）。 或者，您可以使用qs库编码数据： 12const qs = require('qs');axios.post('/foo', qs.stringify(&#123; 'bar': 123 &#125;)); 或者以另一种方式（ES6）， 123456789import qs from 'qs';const data = &#123; 'bar': 123 &#125;;const options = &#123; method: 'POST', headers: &#123; 'content-type': 'application/x-www-form-urlencoded' &#125;, data: qs.stringify(data), url,&#125;;axios(options); Node.js在node.js中，您可以使用querystring模块，如下所示： 12const querystring = require('querystring');axios.post('http://something.com/', querystring.stringify(&#123; foo: 'bar' &#125;)); 您也可以使用qs库。 Semver在axios达到1.0版本之前，破坏性更改将以新的次要版本发布。 例如0.5.1和0.5.4将具有相同的API，但0.6.0将具有重大变化。 Promisesaxios 依赖原生的 ES6 Promise 实现而被支持. 如果你的环境不支持 ES6 Promise，你可以使用 polyfill. TypeScriptaxios包括TypeScript定义。 12import axios from 'axios';axios.get('/user?ID=12345'); 资源 Changelog Upgrade Guide Ecosystem Contributing Guide Code of ConductCreditsaxios深受Angular提供的、$http服务的启发。 最终，axios是为了在Angular之外使用而提供独立的类似$http服的务。协议MIT","categories":[{"name":"axios","slug":"axios","permalink":"http://yoursite.com/categories/axios/"}],"tags":[{"name":"axios","slug":"axios","permalink":"http://yoursite.com/tags/axios/"}]},{"title":"个人简历","slug":"resume","date":"2019-06-05T03:19:04.000Z","updated":"2019-06-14T09:38:35.000Z","comments":true,"path":"2019/06/05/resume/","link":"","permalink":"http://yoursite.com/2019/06/05/resume/","excerpt":"","text":"梅衍青 男 ︳ 23岁 ︳大专 ︳ 2年工作经验 ︳ 上海 17621515830 ︳954663633@qq.com 上海工商职业技术学院 移动互联网方向 技能 前端：HTML、CSS、JavaScript前端框架: vue、webpack、cordova、react-native，微信小程序后端：php、node后端框架: thinkphp、express、koa2、egg数据库:mysql、mongodb、redis 版本控制：git、svn 工作经历 上海子杰软件有限公司 2017.01-2018-06 快睿登信息科技(上海)有限公司 2018.06-至今 项目经验 一、风驰后台v0.2&amp;小通分期v0.2 2019.2-至今项目内容:风驰后台、小通分期(汇宝通)作为第二期项目的迭代。小通分期，增加分期功能。技术栈:avuex、vue全家桶、cordva、webpack、less项目类型:网页、app项目经验:技术点调用cordva插件，获取手机通讯录、GPS、联系人、电量、极光推送等原生功能。同时迭代风驰后台的页面系统，用户量也大量增加后发现并且处理一些关于手机适配的问题(主要是因为cordva是调用手机中的内核浏览器，出现了css3不兼容的问题)二、重构风驰后台v0.1 2018年12 – 2019-2项目内容:计划迭代汇宝通后台中，我提出了以下问题。1.前后端有绑定关系，发布后，前后端的这种依赖。2.ui的局限，后台都是使用敏捷开发，那么意味着很多组件是根据技术选型的时候就确定了的。我们现有的框架无法做到ui升级。选择迁回老风驰工程量也会很大(这里的重写包括语法结构都需要重写),选择强行在先有ui框架上修改，工程量无法估计。3.需求其实不是很明确的，只能参照老风驰的样子做，新老风驰经手的人都比较多，都是有什么需求直接加什么需求，但是具体权限和细节根据时间的推移，没有任何文档可以参照，所以建议重构。技术栈:avuex、vue全家桶项目类型:网页项目经验：当时遇到了一个问题，就是这套后台必须兼容手机端的问题，element-ui的缺点也提现出来的，那就是对于手机端的适配，很多插件都会有问题，第二个问题就是前端人手紧缺，原来使用的架构，人手上无法维护。加上时间比较紧张，经过调研，采用了avuex的框架方案，该方案的优势在于json驱动ui的思想理念。以最快的速度，重构了风驰后台。 三、黑卡 2018.11-2018-12项目内容:根据个人资质情况，可以进行不同次数的征信洗白，享有最高100，000的额度利率低至银行利率，介绍老铁洗白征信，长期有效，连续签到一年，1000元大奖，三星级会员五星级酒店。技术栈: vue、cordva、webpack、less项目类型：app、网页项目经验：针对于先有公司项目的沉淀，公司决定开启黑卡项目业务，对于vue技术的了解和逐步深入后，公司也对于原生和动态交互提出了更高的要求，针对于目前项目的组件规划和开发。 四、汇宝通-后台 2018.08-2018-10项目内容: vue后台贷款系统，引流，贷款模块，用户模块，商品模块，进件模块，风控模块技术栈:vue、webpack、element-ui项目类型：网页项目经验:正对于现在走向组件化的趋势，配合公司领导，进行了后台组件的开发。将原先的贷款系统，引流，贷款模块，用户模块，商品模块，进件模块，风控模块拆分为各个模块，方便与后台页面随时的重构组装，服务与公司将部分模块卖给第三方公司的构想。 五、汇宝通-app 2018.07-2018-09项目内容: p2p的线上贷款系统，引流，贷款模块，用户模块，商品模块，进件模块，风控模块为一体的app项目。技术栈:vue、cordva、webpack、less项目类型：app、网页项目经验：离开上一家公司后，我开始了新的征程，这第一次对于node技术进行了了解。前端做到工程和模块的话处理，将人力减少到最小数的敏捷开发。对于项目负责人的架构进行了学习和梳理。了解了关于cordva的插件。对于三个端(网页，安卓，ios)的兼容性，达到最快的试错。对于webpack的改造项目工程目录，达到了，一份代码能兼容三个端，并且还能够调用原生的底层权限。 六、梯子网小程序 2018.01-2018-06项目内容: 梯子网为教育局和大型社会培训机构提供一站式多机构管理，其中主要涉及两个难点，一是多机构的管理，不同机构可以定制自己模块下的内容，只有本机构下的人可以看到。二是定制化产生页面，不同的机构可以定制自己的页面栏目，根据自己的需要展示对应的内容，这还涉及到了不同机构、角色的权限问题。项目类型: 微信小程序技术栈: wxml、wxss、js项目经验：冬去春来，公司决定实现一个小程序的工作规划，对于项目探索工作交给了我。对于视频的学习，可能因为有着react-native项目经验，对于新起的mvvm这样的设计思路有着充分的了解。所以上手写小程序，反而觉得比较简单。对于微信组件和api进行了了解和使用。对于wx.request进行了封装，和关于一些常用函数的封装，针对一些常用组件的封装。例如wx.getStorage、清空缓存、分享、弹窗等等。方便对于其他协作的伙伴调用和使用。 七、上海天马Portal系统 2017.11-2017.12项目内容: 上海天马Portal管理系统是为了在公司内部整合所有业务系统，规范统一入口，消息通知，业务处理，是业务统一入口，用户无需牢记各个应用系统的地址，降低用户使用时的困难，避免用户来回切换业务系统，提升用户工作效率。项目类型: 网页技术栈:layui、jquery、html项目经验:第一次带2个实习生一起工作，心里美滋滋啊(不排除项目比较简单)，关于前端我才用了layui框架，使用过bootstrap后，总觉得layui的页面的美观程度还是比bootstrap框架要优雅很多的。也让我开始了解代码的书写规范，按照美工的设计与后台的配合，完成了项目的进度。 八、英语学习-EnglishOnlie 2017.08-2017.10项目内容: 软件分学生端和教师端，学生端主要实现学习功能，学习进度通过闯关和教师操作控制，教师端主要实现管理功能，管理学生帐户，学习资源管理，学习进度管理。项目类型:app、网页、微信网页技术栈：react-native、html、jquery项目经验:这个公司遗留下的一个比较老的项目，不少组件使用的是react-android，不兼容ios的组件，这个工作的主要任务，就是将ios的兼容问题彻底的解决、并且兼容网页与微信网页。这个项目最大的特色应该就是学生读英语的功能，可以经过讯飞系统的语言识别，来判断学生的读音，从而给予评分。第一次了解了网页的录音和微信网页的录音调用是不同的，微信的调用，是不同的，微信有着自己独有的api。 九、玖龙移动销售 2017.05-2017.07项目内容: 在前端、管理查看集团的产品、订单、销售统计信息。项目类型:app技术栈:react-native项目经验:经过之前三个月的学习，加入了新的项目组，对于这个项目而言，并没有参加项目的原始的开发计划。当时公司其他的项目比较紧张，与项目组长两个人直接飞往东莞珑石集团技术部门，进行了bug的修复，刚刚参加项目的时候，主要是对于ios的适配问题进行了修复工作(因为我是mac),了解了关于ios的info.list。第一次对于ios白名单有所认识，了解了关于前端调用原生的，最大的问题，是关于一些原生的权限问题。 十、中国国际珠宝交易平台 2017.01-2017.04 项目内容: “中国国际珠宝交易平台” APP 具有产品搜索/浏览、商品购买、评价、退换货等功能项目类型:app技术栈:react-native项目经验:这个项目是加入前端组织行列的第一个项目，你知道在2017年，这个react-native在大环境下，其实我认为还不算很成熟，当时项目组没有什么这方面的技术，就自发的组织学习这项技术。几个通宵后的学习，学了基本上的flex布局，对于react-natve的特殊的css处理方法进行了了解，了解了fetch的网络请求方案，让工作的环境中还算能够使用这项技术，因为那时候刚刚入行，代码的稚嫩，如今看来还是有很大的问题。 开源项目 https://github.com/MYQ1996/asGiant-admin.git项目内容: 基于egg架构的自动生成接口的框架 你可以这么理解这个框架，就是在你配置完数据后，就生成了增删改查接口，也同时生成了相关的栏目。 这样即使你是一个不懂后端的同学，你也可以直接调用接口给前端使用 _在这个项目中，我希望能解决，前端对于后端的不熟悉和了解，但是对于调用接口比较熟悉的业务现状。完成了以下模块。对于表的增删改查操作、增删改字段的信息、短信管理(只需配置短信的key)、邮箱管理(需配置邮箱的key)、人员注册(手机号、用户名、邮箱)、针对于字段添加了人员权限。之后的规划想做个cms，针对于seo的网站排名调优。对于增加之后，直接生成相对应的前端页面，使用node写了一个微信机器人，符合时代需求，达到人工智能，和机器人聊天的过程中，直接操作平台，完成接口的操作。希望之后，技术提升之后，能够够写出一套兼容性比较高的组件，直接配合平台的使用，有考虑过taro，但是感觉对于原生的调用不足，还在思考这部分的工作。最后达到敏捷开发的效果。(因为加班的缘故，所以一直没有做完)。 掘金博客 https://juejin.im/user/5b4e88986fb9a04fba6e752b 自我描述 对于技术出生，还是个大专。还是受到不少的压力的，现在毕竟都觉得本科生比较好培养嘛。我是15年进的大专。第一年被选中参加了，学校的比赛班，主要就是负责学校对外的比赛参加。大二开始不参加日常课程直接进入培训，大三进入校企合作上班。对于技术不断追求，热衷学习研究新技术，实践在项目中。对于前后端有着一定的理解，希望能达到技术一个新的高度。ps: 希望能和贵公司有着合作的机会，也希望能成为你的同事。","categories":[],"tags":[]},{"title":"14 连接redis","slug":"egg-企业级框架和应用入门/14 连接redis","date":"2019-06-02T08:47:43.000Z","updated":"2019-06-08T15:06:43.000Z","comments":true,"path":"2019/06/02/egg-企业级框架和应用入门/14 连接redis/","link":"","permalink":"http://yoursite.com/2019/06/02/egg-企业级框架和应用入门/14 连接redis/","excerpt":"","text":"Redis client(support redis portocal) based on ioredis for egg framework 14.1 安装1npm i egg-redis --save 14.2 配置Change ${app_root}/config/plugin.js to enable redis plugin: 1234567exports.redis = &#123; enable: true, package: 'egg-redis',&#125;; Configure redis information in ${app_root}/config/config.default.js:Single Client 12345678config.redis = &#123; client: &#123; port: 6379, // Redis port host: '127.0.0.1', // Redis host password: 'auth', db: 0, &#125;&#125; 14.3 使用方法 14.3.1 serviceapp/service/redis.jsif(this.app.redis)判断是否有启用redis 1234567891011121314151617181920212223242526'use strict';const Service = require('egg').Service;class RedisService extends Service &#123; async set(key, value, seconds) &#123; value = JSON.stringify(value); if (this.app.redis) &#123; if (!seconds) &#123; await this.app.redis.set(key, value); &#125; else &#123; await this.app.redis.set(key, value, 'EX', seconds); &#125; &#125; &#125; async get(key) &#123; if (this.app.redis) &#123; const data = await this.app.redis.get(key); if (!data) return; return JSON.parse(data); &#125; &#125;&#125;module.exports = RedisService; 14.3.2 controllerapp/controller/default/index.js如果没有设置redis缓存，就去请求数据,再设置缓存 1234567var topNav = await this.ctx.service.cache.get('index_topNav');if (!topNav) &#123; topNav = await this.ctx.model.Nav.find(&#123; \"position\": 1 &#125;); await this.ctx.service.cache.set('index_topNav', topNav, 60 * 60);&#125;","categories":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/categories/egg-企业级框架和应用入门/"}],"tags":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/tags/egg-企业级框架和应用入门/"}]},{"title":"13 表单校验机制","slug":"egg-企业级框架和应用入门/13 表单校验机制","date":"2019-06-02T07:47:43.000Z","updated":"2019-06-08T15:06:33.000Z","comments":true,"path":"2019/06/02/egg-企业级框架和应用入门/13 表单校验机制/","link":"","permalink":"http://yoursite.com/2019/06/02/egg-企业级框架和应用入门/13 表单校验机制/","excerpt":"","text":"npm egg-validate-plus –save 13.1 开启插件123456// config/plugin.&#123;env&#125;.jsexports.validatePlus = &#123; enable: true, package: 'egg-validate-plus',&#125;; 13.2 配置插件1234567891011121314151617181920// config/config.&#123;env&#125;.jsconfig.validatePlus = &#123; resolveError(ctx, errors) &#123; if (errors.length) &#123; ctx.type = 'json'; ctx.status = 400; ctx.body = &#123; code: 400, error: errors, message: '参数错误', &#125;; &#125; &#125;&#125;; 13.3 使用插件 13.3.1 传入字符串12// app/controller/xx.jsconst &#123; query &#125; = this.ctx.request; 拿到验证结果 1const validateResult = await this.ctx.validate('user.login', query) 验证不通过时，阻止后面的代码执行 1if (!validateResult) return > 注意：不要带上 rules 13.3.2 直接传入验证规则对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// app/controller/xx.js// 直接引入 rules 文件下的验证规则，也可以是自己写的验证规则对象const rule = this.app.rules.user.login// 数据格式// const rule = &#123;// id: [// &#123; required: true &#125;,// &#123; type: 'number', message: 'id 必须为数字 &#125;// ],// password: [// &#123; required: true &#125;,// &#123; type: 'string', message: 'password 必须为字符串 &#125;// ]// &#125;// 从客户端传入的参数const &#123; query &#125; = this.ctx.request;// 数据格式：// query = &#123;// username: 123456,// password: 'abcdefg'// &#125;// 拿到验证结果const validateResult = await this.ctx.validate(rule, query)// 验证不通过时，阻止后面的代码执行if (!validateResult) return","categories":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/categories/egg-企业级框架和应用入门/"}],"tags":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/tags/egg-企业级框架和应用入门/"}]},{"title":"12 egg-swagger2","slug":"egg-企业级框架和应用入门/12 egg-swagger2","date":"2019-06-02T06:47:43.000Z","updated":"2019-06-08T15:06:21.000Z","comments":true,"path":"2019/06/02/egg-企业级框架和应用入门/12 egg-swagger2/","link":"","permalink":"http://yoursite.com/2019/06/02/egg-企业级框架和应用入门/12 egg-swagger2/","excerpt":"","text":"12.1 运营场景作为后台,例如有人需要后台提供文档….人家java都有swagger,egg在 egg-swagger2 支持下，我们也可以使用。 12.2 安装 npm i egg-swagger2 -S 12.3 开启插件12345// config/plugin.jsexports.swagger2 = &#123; enable: true, package: 'egg-swagger2',&#125;; 12.4 插件配置config.default.js 中配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445config.swagger2 = &#123; enable: true, // 禁用swagger , 默认为true base: &#123; /* default config,support cover schemes: [ 'http', ], host: '127.0.0.1:7001', basePath: '/', consumes: [ 'application/json', ], produces: [ 'application/json', ], */ info: &#123; description: '文档介绍, version: '1.0.0', title: '文档名称', contact: &#123; email: 'caandoll@aliyun.com', &#125;, license: &#123; name: 'Apache 2.0', url: 'http://www.apache.org/licenses/LICENSE-2.0.html', &#125;, &#125;, tags: [&#123; name: 'admin', description: 'Admin desc', &#125;, &#123; name: 'role', description: 'Role desc', &#125;, ], definitions: &#123; // model definitions &#125;, securityDefinitions: &#123; // security definitions &#125; &#125;, &#125;; 12.4 例子在 /app/router.js文件中 12.4.1 post请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657module.exports = app =&gt; &#123; const &#123; router, controller, swagger &#125; = app; router.post('/login', controller.test.postLogin); swagger.post('/login', &#123; tags: [ 'admin', ], summary: 'Login a admin', description: '', parameters: [ &#123; in: 'body', name: 'body', description: 'admin\\'s username &amp; password', required: true, schema: &#123; type: 'object', required: [ 'username', 'password' ], properties: &#123; username: &#123; type: 'string', description: 'admin\\'s username', &#125;, password: &#123; type: 'string', description: 'admin\\'s password', &#125;, &#125;, &#125;, &#125;, ], responses: &#123; 200: &#123; description: 'SUCCEED', schema: &#123; type: 'object', properties: &#123; status: &#123; type: 'string', description: 'status', &#125;, data: &#123; type: 'object', description: 'data', properties: &#123; token: &#123; type: 'string', description: 'token', &#125;, &#125;, &#125;, &#125;, &#125;, &#125;, &#125;, &#125;);&#125; 12.4.2 get请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061module.exports = app =&gt; &#123; const &#123; router, controller, swagger &#125; = app; router.get('/roles', controller.test.getRoles); swagger.get('/roles', &#123; tags: ['role',], summary: 'search role by page', description: '', parameters: [&#123; in: 'query', name: 'name', description: 'role\\'s name', &#125;, &#123; in: 'query', name: 'pageIndex', description: 'pageIndex', &#125;, &#123; in: 'query', name: 'pageSize', description: 'pageSize', &#125;, ], responses: &#123; 200: &#123; description: 'SUCCEED', schema: &#123; type: 'object', properties: &#123; status: &#123; type: 'string', description: 'status', &#125;, datas: &#123; type: 'array', description: 'result datas', properties: &#123; token: &#123; type: 'string', description: 'token', &#125;, &#125;, &#125;, pageIndex: &#123; type: 'number', description: 'pageIndex', &#125;, pageSize: &#123; type: 'number', description: 'pageSize', &#125;, totalCount: &#123; type: 'number', description: 'totalCount', &#125;, &#125;, &#125;, &#125;, &#125;, &#125;);&#125; 12.4.3 swagger的使用 npm run dev 跑起来 获取swgger地址 输入浏览器 你看到就是文档了 点击try it out 输入你传的值,然后点击Execute 结果 你就可以获取到接口传递过来的值,效果类似postman,但是清晰程度比postman好 12.5 常见问题一般情况下都不会有问题，但是如果你这时候巧妙的用了egg-static,那么你就会报错了经过排查，你就会发现 /node_modules/egg-swagger2/app.js 它会是一个数组，然后报错必须是个字符串,然后你懂得..你给他做成一个字符串即可","categories":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/categories/egg-企业级框架和应用入门/"}],"tags":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/tags/egg-企业级框架和应用入门/"}]},{"title":"11 引入静态文件","slug":"egg-企业级框架和应用入门/11 引入静态文件","date":"2019-06-02T05:47:43.000Z","updated":"2019-06-08T15:05:38.000Z","comments":true,"path":"2019/06/02/egg-企业级框架和应用入门/11 引入静态文件/","link":"","permalink":"http://yoursite.com/2019/06/02/egg-企业级框架和应用入门/11 引入静态文件/","excerpt":"","text":"11.1 经过测试插件设置1234exports.ejs = &#123; enable: true, package: 'egg-view-ejs',&#125;; 11.2 配置设置 a：静态文件 1234567config.static = &#123; prefix: '/', dir: path.join(appInfo.baseDir, 'app/public/') &#125; 当然此时你会遇到一个问题，你想要多个文件该如何事好 123456config.static = &#123; prefix: '/', dir: [ path.join(appInfo.baseDir, 'app/view/'), path.join(appInfo.baseDir, 'app/public/uploads/'), path.join(appInfo.baseDir, 'app/public/swagger/') ], &#125;; b：模板设置 1234567config.view = &#123; defaultExt: '.html', mapping: &#123; '.ejs': 'ejs', '.html': 'ejs', &#125;&#125; 11.3 路由控制器设置//将 index.html 放在app/view里，静态文件放在public里 12345const &#123; ctx &#125; = this;// render user.htmlyield ctx.render('index');","categories":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/categories/egg-企业级框架和应用入门/"}],"tags":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/tags/egg-企业级框架和应用入门/"}]},{"title":"10 阿里监控","slug":"egg-企业级框架和应用入门/10 阿里监控","date":"2019-06-02T03:47:43.000Z","updated":"2019-06-08T15:05:26.000Z","comments":true,"path":"2019/06/02/egg-企业级框架和应用入门/10 阿里监控/","link":"","permalink":"http://yoursite.com/2019/06/02/egg-企业级框架和应用入门/10 阿里监控/","excerpt":"","text":"Node.js 性能平台（alinode） 是面向所有 Node.js 应用提供 性能监控、安全提醒、故障排查、性能优化 等服务的整体性解决方案，提供完善的工具链和服务，协助开发者快速发现和定位线上问题。 1npm i nodeinstall -g 提供了egg-alinode 来快速接入，无需安装 agenthub 等额外的常驻服务。 1npm i egg-alinode --save 123456// /config/plugin.jsexports.alinode = &#123; enable:true, package:'egg-alinode',&#125;, 申请一下服务 访问控制台 控制台地址：https://node.console.aliyun.com 12345678910111213// config/config.default.jsexports.alinode = &#123; enable: true, appid: '***', // Node.js 性能平台给您的项目生成的 appid secret: '***', // Node.js 性能平台给您的项目生成的 secret logdir: '***', //可选，Node.js 性能平台日志输出地址绝对路径，与 NODE_LOG_DIR 保持一致。如：/tmp/，也可以不写 error_log: [ // '您的应用在业务层面产生的异常日志的路径，数组，可选，可配置多个', // '例如：/root/.logs/error.#YYYY#-#MM#-#DD#.log', // '不更改 Egg 默认日志输出路径可不配置本项目', ],// 可选 agentidMode:'IP', // 可选，如果设置，则在实例ID中添加部分IP信息，用于多个实例 hostname 相同的场景（以容器为主）&#125;; 然后你就能愉快针对你的egg，进行监控了","categories":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/categories/egg-企业级框架和应用入门/"}],"tags":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/tags/egg-企业级框架和应用入门/"}]},{"title":"9 部署","slug":"egg-企业级框架和应用入门/9 部署","date":"2019-06-02T02:47:43.000Z","updated":"2019-06-08T15:05:14.000Z","comments":true,"path":"2019/06/02/egg-企业级框架和应用入门/9 部署/","link":"","permalink":"http://yoursite.com/2019/06/02/egg-企业级框架和应用入门/9 部署/","excerpt":"","text":"9.1 部署服务器 首先当然是在你的服务器上部署好node服务,然后安装好。 服务器需要预装 Node.js，框架支持的 Node 版本为 &gt;= 8.0.0。框架内置了 egg-cluster 来启动 Master 进程，Master 有足够的稳定性，不再需要使用 pm2 等进程守护模块。同时，框架也提供了 egg-scripts 来支持线上环境的运行和停止。 1egg-scripts start --port=7001 --daemon --title=egg-server-showcase --port=7001 端口号，默认会读取环境变量 process.env.PORT，如未传递将使用框架内置端口 7001。 --daemon 是否允许在后台模式，无需 nohup。若使用 Docker 建议直接前台运行。 --env=prod 框架运行环境，默认会读取环境变量 process.env.EGG_SERVER_ENV， 如未传递将使用框架内置环境 prod。 --workers=2 框架 worker 线程数，默认会创建和 CPU 核数相当的 app worker 数，可以充分的利用 CPU 资源。 --title=egg-server-showcase 用于方便 ps 进程时 grep 用，默认为 egg-server-${appname}。 --framework=yadan 如果应用使用了可以配置 package.json 的 egg.framework 或指定该参数。 --ignore-stderr 忽略启动期的报错。 9.1.1 启动配置项你也可以在 config.{env}.js 中配置指定启动配置。 123456789// config/config.default.jsexports.cluster = &#123; listen: &#123; port: 7001, hostname: '127.0.0.1', // path: '/var/run/egg.sock', &#125;&#125; path，port，hostname 均为 server.listen 的参数，egg-scripts 和 egg.startCluster 方法传入的 port 优先级高于此配置。s 9.1.2 停止命令该命令将杀死 master 进程，并通知 worker 和 agent 优雅退出。支持以下参数： --title=egg-server 用于杀死指定的 egg 应用，未传递则会终止所有的 Egg 应用。 12&quot;start&quot;: &quot;egg-scripts start --daemon --title=$&#123;进程名称&#125;&quot;,&quot;stop&quot;: &quot;egg-scripts stop --title=$&#123;进程名称&#125;&quot; 你也可以直接通过 1ps -eo &quot;pid,command&quot; | grep -- &quot;--title=egg-server&quot; 来找到 master 进程，并 kill 掉，无需 kill -9。","categories":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/categories/egg-企业级框架和应用入门/"}],"tags":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/tags/egg-企业级框架和应用入门/"}]},{"title":"8 定时任务&amp;定点任务","slug":"egg-企业级框架和应用入门/8 定时任务&定点任务","date":"2019-06-01T10:47:43.000Z","updated":"2019-06-08T15:04:58.000Z","comments":true,"path":"2019/06/01/egg-企业级框架和应用入门/8 定时任务&定点任务/","link":"","permalink":"http://yoursite.com/2019/06/01/egg-企业级框架和应用入门/8 定时任务&定点任务/","excerpt":"","text":"egg提供了强大的定时任务系统。通过定时任务，可以系统修改服务的缓存数据，以便处理需要定时更新的数据。 在app/schedule目录下新建一个js文件，每一个js文件就是一个定时任务 ### 8.1 定时任务 1234567891011121314151617// app/schedulemodule.exports = &#123; schedule: &#123; interval: '1m', // 1 分钟间隔 type: 'all', // 指定所有的 worker 都需要执行 &#125;, async task(ctx) &#123; i++ console.log(i) &#125;,&#125;;/* 注释: 1ms -&gt; 1毫秒 1s -&gt; 1秒 1m -&gt; 1分钟*/ 8.2 定点任务 定点任务（以每周一的5点30分0秒更新排行榜为例） 1、使用cron参数设定时间，cron参数分为6个部分，*表示所有都满足 123456789* * * * * *┬ ┬ ┬ ┬ ┬ ┬│ │ │ │ │ |│ │ │ │ │ └ 星期 (0 - 7) (0或7都是星期日)│ │ │ │ └───── 月份 (1 - 12)│ │ │ └────────── 日期 (1 - 31)│ │ └─────────────── 小时 (0 - 23)│ └──────────────────── 分钟 (0 - 59)└───────────────────────── 秒 (0 - 59, optional) 1234567891011// app/schedulemodule.exports = &#123; schedule: &#123; cron: '0 30 5 * * 1', //每周一的5点30分0秒更新 type: 'all', // 指定所有的 worker 都需要执行 &#125;, async task(ctx) &#123; i++ console.log(i) &#125;,&#125;; 8.3 只执行一次定时任务 设置immediate参数为true时，该定时任务会在项目启动时，立即执行一次定时任务 1234567891011module.exports = &#123; schedule: &#123; interval: '1m', // 1 分钟间隔 type: 'all', // 指定所有的 worker 都需要执行 immediate: true, //项目启动就执行一次定时任务 &#125;, async task(ctx) &#123; i++ console.log(i) &#125;,&#125;; 8.4 关闭任务 配置disable参数为true时，该定时任务即关闭 8.5 指定定时任务执行环境env1env: [\"dev\", \"debug\"] //该定时任务在开发环境和debug模式下才执行","categories":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/categories/egg-企业级框架和应用入门/"}],"tags":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/tags/egg-企业级框架和应用入门/"}]},{"title":"7 Session的使用","slug":"egg-企业级框架和应用入门/7 Session的使用","date":"2019-06-01T08:47:43.000Z","updated":"2019-06-08T15:04:47.000Z","comments":true,"path":"2019/06/01/egg-企业级框架和应用入门/7 Session的使用/","link":"","permalink":"http://yoursite.com/2019/06/01/egg-企业级框架和应用入门/7 Session的使用/","excerpt":"","text":"7.1 Session 简单介绍session 是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而session 保存在服务器上。 7.2 Session 的工作流程当浏览器访问服务器并发送第一次请求时，服务器端会创建一个 session 对象，生成一个类似于 key,value 的键值对， 然后将 key(cookie)返回到浏览器(客户)端，浏览器下次再访问时，携带 key(cookie)，找到对应的 session(value)。 7.3 Egg.js 中 session 的使用egg.js 中 session 基于 egg-session 内置了对 session 的操作 7.3.1 设置1234this.ctx.session.userinfo=&#123; name:'张三', age:'20'&#125; 7.3.2 获取1var userinfo=this.ctx.session 7.3.3 Session 的默认设置12345exports.session = &#123; key: 'EGG_SESS', maxAge: 24 * 3600 * 1000, // 1 day httpOnly: true, encrypt: true&#125;; 7.4 Session 在 config.default.js 中的配置12345config.session=&#123; key:'SESSION_ID', maxAge:864000, renew: true //延长会话有效期&#125; 7.5 cookie 和session 区别 cookie 数据存放在客户的浏览器上，session 数据放在服务器上。 cookie 相比 session 没有 session 安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE欺骗。 session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用 COOKIE。 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。","categories":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/categories/egg-企业级框架和应用入门/"}],"tags":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/tags/egg-企业级框架和应用入门/"}]},{"title":"6 Cookie 的使用","slug":"egg-企业级框架和应用入门/6 Cookie 的使用","date":"2019-06-01T07:47:43.000Z","updated":"2019-06-08T15:04:32.000Z","comments":true,"path":"2019/06/01/egg-企业级框架和应用入门/6 Cookie 的使用/","link":"","permalink":"http://yoursite.com/2019/06/01/egg-企业级框架和应用入门/6 Cookie 的使用/","excerpt":"","text":"6 Cookie 的使用 6.1 Cookie 简介 cookie 是存储于访问者的计算机中的变量。可以让我们用同一个浏览器访问同一个域名的时候共享数据。 HTTP 是无状态协议。简单地说，当你浏览了一个页面，然后转到同一个网站的另一个页面，服务器无法认识到这是同一个浏览器在访问同一个网站。每一次的访问，都是没有任何关系的。 6.2 Cookie 的设置和获取 6.2.1 Cookie 设置语法 ctx.cookies.set(key, value, options) 1this.ctx.cookies.set('name','zhangsan'); 6.2.2 Cookie 获取语法 ctx.cookies.get(key, options) 1this.ctx.cookies.get('name') 6.2.3 清除 Cookie1this.ctx.cookies.set('name',null); 或者设置 maxAge 过期时间为 0 6.3 Cookie 参数 options https://eggjs.org/en/core/cookie-and-session.html#container 1234567ctx.cookies.set(key, value, &#123; maxAge:24 * 3600 * 1000, httpOnly: true, // 默认情况下是正确的 encrypt: true, // cookie在网络传输期间加密 ctx.cookies.get('frontend-cookie', &#123; encrypt: true&#125;); ### 6.4 设置中文 Cookie 6.4.1 第一种解决方案123console.log(new Buffer('hello, world!').toString('base64'));// 转换成 base64字符串：aGVsbG8sIHdvcmxkIQ==console.log(new Buffer('aGVsbG8sIHdvcmxkIQ==', 'base64').toString()); // 还原 base64字符串：hello, world! 6.4.2 第二种解决方案12345ctx.cookies.set(key, value, &#123; maxAge:24 * 3600 * 1000, httpOnly: true, // 默认情况下是正确的 encrypt: true, // cookie在网络传输期间进行加密&#125;);","categories":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/categories/egg-企业级框架和应用入门/"}],"tags":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/tags/egg-企业级框架和应用入门/"}]},{"title":"5 mysql数据库","slug":"egg-企业级框架和应用入门/5 mysql数据库","date":"2019-06-01T06:47:43.000Z","updated":"2019-06-08T15:04:13.000Z","comments":true,"path":"2019/06/01/egg-企业级框架和应用入门/5 mysql数据库/","link":"","permalink":"http://yoursite.com/2019/06/01/egg-企业级框架和应用入门/5 mysql数据库/","excerpt":"","text":"5 mysql数据库框架提供了 egg-mysql 插件来访问 MySQL 数据库。这个插件既可以访问普通的 MySQL 数据库，也可以访问基于 MySQL 协议的在线数据库服务。 5.1 安装与配置安装对应的插件 egg-mysql : 1npm i --save egg-mysql 开启插件： 12345// config/plugin.jsexports.mysql = &#123; enable: true, package: 'egg-mysql',&#125;; 在 config/config.${env}.js 配置各个环境的数据库连接信息。 5.1.1 单数据源如果我们的应用只需要访问一个 MySQL 数据库实例，可以如下配置：使用方式： 1234567891011121314151617181920// config/config.$&#123;env&#125;.jsexports.mysql = &#123; // 单数据库信息配置 client: &#123; // host host: 'mysql.com', // 端口号 port: '3306', // 用户名 user: 'test_user', // 密码 password: 'test_password', // 数据库名 database: 'test', &#125;, // 是否加载到 app 上，默认开启 app: true, // 是否加载到 agent 上，默认关闭 agent: false,&#125;; 1await app.mysql.query(sql, values); // 单实例可以直接通过 app.mysql 访问 5.1.2 多数据源如果我们的应用需要访问多个 MySQL 数据源，可以按照如下配置： 12345678910111213141516171819202122232425262728293031323334353637exports.mysql = &#123; clients: &#123; // clientId, 获取client实例，需要通过 app.mysql.get('clientId') 获取 db1: &#123; // host host: 'mysql.com', // 端口号 port: '3306', // 用户名 user: 'test_user', // 密码 password: 'test_password', // 数据库名 database: 'test', &#125;, db2: &#123; // host host: 'mysql2.com', // 端口号 port: '3307', // 用户名 user: 'test_user', // 密码 password: 'test_password', // 数据库名 database: 'test', &#125;, // ... &#125;, // 所有数据库配置的默认值 default: &#123; &#125;, // 是否加载到 app 上，默认开启 app: true, // 是否加载到 agent 上，默认关闭 agent: false,&#125;; 5.2 封装增删改查 5.2.1、插入，向users表内插入一条数据12345const result = await this.app.mysql.insert('users', &#123; name: 'wjw', age: 18 &#125;)// 判断：result.affectedRows === 1 5.2.2、查询，查询users表name=Jack的数据123456789101112const result = await this.app.mysql.select('users', &#123; columns: ['id', 'name'], //查询字段，全部查询则不写，相当于查询* where: &#123; name: 'wjw' &#125;, //查询条件 orders: [ ['id', 'desc'] //降序desc，升序asc ], limit: 10, //查询条数 offset: 0 //数据偏移量（分页查询使用） &#125;)//判断：result.length &gt; 0 5.2.3、修改，修改users表id=1的数据age为2012345678const result = await this.app.mysql.update('users', &#123; age: 20 //需要修改的数据 &#125;, &#123; where: &#123; id: 1 &#125; //修改查询条件 &#125;);//判断：result.affectedRows === 1 5.2.4、删除，删除users表name=wjw的数据123const result = await this.app.mysql.delete('users', &#123; name: 'wjw'&#125;)","categories":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/categories/egg-企业级框架和应用入门/"}],"tags":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/tags/egg-企业级框架和应用入门/"}]},{"title":"4 get、post请求","slug":"egg-企业级框架和应用入门/4 get、post请求","date":"2019-06-01T05:47:43.000Z","updated":"2019-06-08T15:03:56.000Z","comments":true,"path":"2019/06/01/egg-企业级框架和应用入门/4 get、post请求/","link":"","permalink":"http://yoursite.com/2019/06/01/egg-企业级框架和应用入门/4 get、post请求/","excerpt":"","text":"4.1 get 请求4.1.1 query在 URL 中 ?后面的部分是一个 Query String，这一部分经常用于 GET 类型的请求中传递参数。例如 GET /search?name=egg&amp;age=26中 name=egg&amp;age=26 就是用户传递过来的参数。我们可以通过 context.query(为一个对象)拿到解析过后的这个参数体 123456789101112module.exports = app =&gt; &#123;class HomeController extends Controller &#123; async getQuery() &#123; const queryObj = this.ctx.query; console.log(queryObj.age); console.log(queryObj); //打印结果：&#123; name: 'egg', age: '26' &#125; &#125; &#125; return SearchController;&#125;; 当 Query String 中的 key 重复时，context.query只取 key 第一次出现时的值，后面再出现的都会被忽略。GET /posts?category=egg&amp;category=koa 通过 context.query拿到的值是 { category: &#39;egg&#39; }。 4.1.2 queries有时候我们的系统会设计成让用户传递相同的 key，例如 GET /posts?category=egg&amp;id=1&amp;id=2&amp;id=3。针对此类情况，框架提供了 context.queries 对象，这个对象也解析了 Query String，但是它不会丢弃任何一个重复的数据，而是将他们都放到一个数组中： 12345678910111213// GET /posts?category=egg&amp;id=1&amp;id=2&amp;id=3const Controller = require('egg').Controller;class HomeController extends Controller &#123; async getQueries() &#123; console.log(this.ctx.queries); //result: // &#123; // category: [ 'egg' ], // id: [ '1', '2', '3' ], // &#125; &#125;&#125;; context.queries上所有的 key 如果有值，也一定会是数组类型。 4.2 post 请求123456789101112// 获取参数方法 post 请求module.exports = app =&gt; &#123;class HomeController extends Controller &#123; async postObj() &#123; const queryObj = ctx.request.body; ctx.body = queryObj; &#125; &#125; return SearchController;&#125;; 但是我们请求有时是get,有时是post,有时本来应该是post的请求,但是为了测试方便,还是做成get和post请求都支持的请求,于是一个能同时获取get和post请求参数的中间件就很有必要了. 4.3 编写中间层解决get、post请求 4.3.1 在app目录下新建middleware文件夹 4.3.2 在middleware里面新建params.js,内容如下12345678910111213/** * 获取请求参数中间件 * 可以使用ctx.params获取get或post请求参数 */module.exports = options =&gt; &#123; return async function params(ctx, next) &#123; ctx.params = &#123; ...ctx.query, ...ctx.request.body &#125; await next(); &#125;;&#125;; 本质上就是把get请求的参数和post请求的参数都放到params这个对象里,所以,不管是get还是post都能获取到请求参数 4.3.3 在/config/config.default.js里注入中间件123456789'use strict';module.exports = appInfo =&gt; &#123; const config = exports = &#123;&#125;;// 注入中间件 config.middleware = [ 'params', ]; return config;&#125;; 4.3.4 使用文章获取1234567891011121314151617181920212223/** * 添加文章接口 */'use strict';const Service = require('egg').Service;class ArticleService extends Service &#123; async add() &#123; const &#123; ctx &#125; = this; // 获取请求参数 const &#123; userId, title, content, &#125; = ctx.params; const result = await ctx.model.Article.create(&#123; userId, title, content, &#125;); return result; &#125;&#125;module.exports = ArticleService; 4.3 允许post请求跨域12345// config/plugin.jsexports.cors = &#123; enable: true, package: 'egg-cors',&#125;; 12345678910111213 // config/config.default.jsconfig.security = &#123; csrf: &#123; enable: false, ignoreJSON: true, &#125;, domainWhiteList: [ 'http://www.baidu.com' ], // 配置白名单&#125;;config.cors = &#123; // origin: '*',//允许所有跨域访问，注释掉则允许上面 白名单 访问 allowMethods: 'GET,HEAD,PUT,POST,DELETE,PATCH',&#125;; *一般性最好使用白名单，不要使用全部允许跨域，不安全","categories":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/categories/egg-企业级框架和应用入门/"}],"tags":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/tags/egg-企业级框架和应用入门/"}]},{"title":"3 访问路由","slug":"egg-企业级框架和应用入门/3 访问路由","date":"2019-06-01T03:47:43.000Z","updated":"2019-06-08T15:03:25.000Z","comments":true,"path":"2019/06/01/egg-企业级框架和应用入门/3 访问路由/","link":"","permalink":"http://yoursite.com/2019/06/01/egg-企业级框架和应用入门/3 访问路由/","excerpt":"","text":"egg在设计完全符合比较好的mvc的设计模式。 3.1 那么什么是mvc呢? 全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范。在egg中视图 (view)、控制器（controller） 和数据模型 Model（Service） 和配置文件（config） ### 3.2 控制器（controller） app/controller 目录下面实现 Controller 123456789101112// app/controller/home.jsconst Controller = require('egg').Controller;class HomeController extends Controller &#123; async index() &#123; const &#123; ctx &#125; = this; ctx.body = 'hi, world'; &#125;&#125;module.exports = HomeController; 输入 npm run dev查看 http://127.0.0.1:7001输出 hi, world 我认为控制器就是一个接口，他管理输入和输出 *同样你可以在app/controller 目录下 写很多个这样个js的，来代表接口 3.3 路由（Router）主要用来描述请求 URL 和具体承担执行动作的 Controller 的对应关系， 框架约定了 app/router.js 文件用于统一所有路由规则。 现在很多单页面，都是存在相对于的路由，你写个js，同样就要写一个路由 123456789// app/controller/user.jsclass UserController extends Controller &#123; async info() &#123; const &#123; ctx &#125; = this; ctx.body = &#123; name: `hello $&#123;ctx.params.id&#125;`, &#125;; &#125;&#125; 12345// app/router.jsmodule.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.get('/user/:id', controller.user.info);&#125;; 3.4 数据模型 Model（Service）简单来说，Service 就是在复杂业务场景下用于做业务逻辑封装的一个抽象层，提供这个抽象有以下几个好处： 保持 Controller 中的逻辑更加简洁。 保持业务逻辑的独立性，抽象出来的 Service 可以被多个 Controller 重复调用。 将逻辑和展现分离，更容易编写测试用例。 1234567891011// app/service/user.jsconst Service = require('egg').Service;class UserService extends Service &#123; async addName(name) &#123; const user = `你好,$&#123;name&#125;`; return user; &#125;&#125;module.exports = UserService; 12345678// app/controller/user.jsclass UserController extends Controller &#123; async info() &#123; const &#123; ctx &#125; = this; const userInfo = await ctx.service.user.addName('wjw'); ctx.body = userInfo; &#125;&#125; 3.5 egg中视图 (view) egg中的模板渲染，但是我认为前端后端分离的设计，更加有利于作为服务型架构设计，所以这边不描述view的构造","categories":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/categories/egg-企业级框架和应用入门/"}],"tags":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/tags/egg-企业级框架和应用入门/"}]},{"title":"2 目录结构介绍","slug":"egg-企业级框架和应用入门/2 目录结构介绍","date":"2019-06-01T02:47:43.000Z","updated":"2019-06-08T15:03:14.000Z","comments":true,"path":"2019/06/01/egg-企业级框架和应用入门/2 目录结构介绍/","link":"","permalink":"http://yoursite.com/2019/06/01/egg-企业级框架和应用入门/2 目录结构介绍/","excerpt":"","text":"2.1 目录结构12345678910111213141516171819202122232425262728293031323334353637egg-project├── package.json├── app.js (可选)├── agent.js (可选)├── app(项目开发目录)| ├── router.js (用于配置 URL 路由规则)│ ├── controller (用于解析用户的输入，处理后返回相应的结果)│ | └── home.js│ ├── service (用于编写业务逻辑层)│ | └── user.js│ ├── middleware (用于编写中间件)│ | └── response_time.js│ ├── schedule (可选)│ | └── my_task.js│ ├── public (用于放置静态资源)│ | └── reset.css│ ├── view (可选)│ | └── home.tpl│ └── extend (用于框架的扩展)│ ├── helper.js (可选)│ ├── request.js (可选)│ ├── response.js (可选)│ ├── context.js (可选)│ ├── application.js (可选)│ └── agent.js (可选)├── config (用于编写配置文件)| ├── plugin.js(用于配置需要加载的插件)| ├── config.default.js│ ├── config.prod.js| ├── config.test.js (可选)| ├── config.local.js (可选)| └── config.unittest.js (可选)└── test (用于单元测试) ├── middleware | └── response_time.test.js └── controller └── home.test.js","categories":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/categories/egg-企业级框架和应用入门/"}],"tags":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/tags/egg-企业级框架和应用入门/"}]},{"title":"1 环境搭建、创建、运行","slug":"egg-企业级框架和应用入门/1 环境搭建、创建、运行","date":"2019-06-01T01:47:43.000Z","updated":"2019-06-08T15:03:01.000Z","comments":true,"path":"2019/06/01/egg-企业级框架和应用入门/1 环境搭建、创建、运行/","link":"","permalink":"http://yoursite.com/2019/06/01/egg-企业级框架和应用入门/1 环境搭建、创建、运行/","excerpt":"","text":"1.1 介绍egg.js是阿里旗下基于node.js和koa是一个node企业级应用开发框架，可以帮助开发团队，和开发人员减少成本。基于koa2、es6、es7使得node具有更有规范的开发模式，更低的学习成本、更优雅的代码、更少的维护成本。 1.2 环境搭建1、要求nodejs版本必须大于8.0并且要用LTS 版本2、创建egg的环境 npm i egg-init -g / cnpm i egg-init -g (只需要安装一次)3、创建项目 cd 到目录里面 （注意目录不要用中文 不要有空格） 1.3 创建1234$ npm i egg-init -g$ egg-init egg-example --type=simple //例如:egg-init 项目名称 --type=simple$ cd egg-example$ npm i 1.4 运行项目12npm run dev open localhost:7001 //一般性来说默认端口是7001","categories":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/categories/egg-企业级框架和应用入门/"}],"tags":[{"name":"egg-企业级框架和应用入门","slug":"egg-企业级框架和应用入门","permalink":"http://yoursite.com/tags/egg-企业级框架和应用入门/"}]},{"title":"23 实例属性-$ref","slug":"Vue.js 2.0 手把手入门笔记/23 实例属性-$ref","date":"2019-05-18T07:10:04.000Z","updated":"2019-06-15T02:05:56.000Z","comments":true,"path":"2019/05/18/Vue.js 2.0 手把手入门笔记/23 实例属性-$ref/","link":"","permalink":"http://yoursite.com/2019/05/18/Vue.js 2.0 手把手入门笔记/23 实例属性-$ref/","excerpt":"","text":"官网针对-ref的解释 预期：stringref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例： 1234&lt;!-- `vm.$refs.p` will be the DOM node --&gt;&lt;p ref=&quot;p&quot;&gt;hello&lt;/p&gt;&lt;!-- `vm.$refs.child` will be the child component instance --&gt;&lt;child-component ref=&quot;child&quot;&gt;&lt;/child-component&gt; 当 v-for 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。 操作dom 如果我们用jQuery的话,一般性都可以操作dom 12$(\"#id\").text('xxx') // 使用Jquerydocument.getElementById(\"id\") // 使用原生Dom 现在我们牛逼了，我们用vue。那vue中，如果我要获取Dom，该怎么做？这就进入本文的主题ref, $refs，官网解释： 123&lt;div id=\"app\"&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/div&gt; 在JavaScript中我们习惯了使用document.getElementsByTagName 123456789var vm = new Vue(&#123; el: '#app', data:&#123; msg:'hello' &#125;, mounted() &#123; console.log(document.getElementsByTagName(\"div\")[0].innerHTML); &#125;&#125;) vue操作dom 那么我们在vue中呢 123&lt;div id=\"app\"&gt; &lt;div ref=\"msg\"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/div&gt; 12345678910111213var vm = new Vue(&#123; el: '#app', data:&#123; msg:'hello' &#125;, mounted() &#123; // console.log(document.getElementsByTagName(\"div\")[0].innerHTML); console.log('===================================='); console.log(this.$refs.msg); console.log('===================================='); &#125;&#125;)","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"22 自定义指令-directives","slug":"Vue.js 2.0 手把手入门笔记/22 自定义指令-directives","date":"2019-05-18T06:10:04.000Z","updated":"2019-06-15T02:06:05.000Z","comments":true,"path":"2019/05/18/Vue.js 2.0 手把手入门笔记/22 自定义指令-directives/","link":"","permalink":"http://yoursite.com/2019/05/18/Vue.js 2.0 手把手入门笔记/22 自定义指令-directives/","excerpt":"","text":"15.1 介绍Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。举一个栗子: 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div v-color='flag'&gt;123&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; directives:&#123; color(el,bindings)&#123; //el值指代的是button按钮 console.log(arguments); el.style.background = bindings.value; &#125; &#125;, el: '#app', data: &#123; flag: 'red' &#125;, methods:&#123; getSomething()&#123; return \"hello\" &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 出现如图情况 再来个栗子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;style&gt; .a&#123; position: absolute;width: 100px;height: 100px;background: red; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div class=\"a\" v-drag&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; directives:&#123; drag(el)&#123; el.onmousedown = function (e) &#123; var disx = e.pageX - el.offsetLeft; var disy = e.pageY - el.offsetTop; document.onmousemove = function (e) &#123; el.style.left = e.pageX - disx +'px'; el.style.top = e.pageX - disy + 'px'; &#125; document.onmouseup = function (e) &#123; document.onmousemove = document.onmousemove = null; &#125; e.preventDefault(); &#125; &#125; &#125;, el: '#app', data: &#123; flag: 'red' &#125;, methods:&#123; getSomething()&#123; return \"hello\" &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 可以拖动 15.2 钩子函数一个指令定义对象可以提供如下几个钩子函数 (均为可选)：bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 15.3 钩子函数参数 el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot;中，表达式为 &quot;1 + 1&quot;。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"21 内置组件-动画(transition)","slug":"Vue.js 2.0 手把手入门笔记/21 内置组件-动画(transition)","date":"2019-05-18T05:10:04.000Z","updated":"2019-06-15T02:06:11.000Z","comments":true,"path":"2019/05/18/Vue.js 2.0 手把手入门笔记/21 内置组件-动画(transition)/","link":"","permalink":"http://yoursite.com/2019/05/18/Vue.js 2.0 手把手入门笔记/21 内置组件-动画(transition)/","excerpt":"","text":"1 组件的过渡Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡 在进入/离开的过渡中，会有 6 个 class 切换。 v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。1.1 初步代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;style&gt; div&gt;div&#123; width:100px;height: 100px;background: red; &#125; .v-enter&#123; opacity: 1; &#125; /* 激活的时候 */ .v-enter-avtive&#123; opacity: 0; transition: 1s linear; &#125; /* 离开 */ .v-leave-active&#123; opacity: 0; background: black; transition: 1s linear; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;button @click=\"flag=!flag\"&gt;切换&lt;/button&gt; &lt;!-- vue自定义的组件 --&gt; &lt;transition&gt; &lt;div v-show=\"flag\"&gt;&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; flag:true &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 1.2 多个transition 遇上了多个transition的时候，同一个class肯定是会冲突的，那么如何处理呢 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;style&gt; div&gt;div&#123; width:100px;height: 100px;background: red; &#125; .jw-enter-active &#123; transition: all .3s ease; &#125; .jw-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0); &#125; .jw-enter, .jw-leave-to &#123; transform: translateX(10px); opacity: 0; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;button @click=\"flag=!flag\"&gt;切换&lt;/button&gt; &lt;!-- vue自定义的组件 --&gt; &lt;transition name=\"jw\"&gt; &lt;div v-show=\"flag\"&gt;&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; flag:true &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 简单的理解就是就 transition有一个name属性在css中name-状态即可调用","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"20 指令-条件判断(v-if&amp;v-show)","slug":"Vue.js 2.0 手把手入门笔记/20 指令-条件判断(v-if&v-show)","date":"2019-05-18T03:10:04.000Z","updated":"2019-06-15T02:06:19.000Z","comments":true,"path":"2019/05/18/Vue.js 2.0 手把手入门笔记/20 指令-条件判断(v-if&v-show)/","link":"","permalink":"http://yoursite.com/2019/05/18/Vue.js 2.0 手把手入门笔记/20 指令-条件判断(v-if&v-show)/","excerpt":"","text":"1 v-if&amp;v-show 条件渲染 (使用 v-if) 条件展示 (使用 v-show) if操作的是dom show 操作的样式如果频繁切换dom使用v-show,当数据一开时就确定下来使用v-if更好一些,如果if通过内部指令不会执行了只有dom从显示到隐藏 或者隐藏到显示 才能使用vue的动画 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;span v-if=\"flag\"&gt;你看的见我&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; flag:true &#125; &#125;) &lt;/script&gt;&lt;/html&gt; 2 区别总结 v-show:操作的是元素的display属性 v-if:操作的是元素的创建和插入 相比较而言v-show的性能要高","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"19 生命周期","slug":"Vue.js 2.0 手把手入门笔记/19 生命周期","date":"2019-05-17T03:10:04.000Z","updated":"2019-06-15T02:06:25.000Z","comments":true,"path":"2019/05/17/Vue.js 2.0 手把手入门笔记/19 生命周期/","link":"","permalink":"http://yoursite.com/2019/05/17/Vue.js 2.0 手把手入门笔记/19 生命周期/","excerpt":"","text":"1 vue生命周期简介 2 生命周期探究12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: \"hello is world\" &#125;, beforeCreate() &#123; console.group('beforeCreate 创建前状态===============》'); console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); //undefined console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); //undefined console.log(\"%c%s\", \"color:red\", \"message: \" + this.message) &#125;, created() &#123; console.group('created 创建完毕状态===============》'); console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); //undefined console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); //已被初始化 &#125;, beforeMount() &#123; console.group('beforeMount 挂载前状态===============》'); console.log(\"%c%s\", \"color:red\", \"el : \" + (this.$el)); //已被初始化 console.log(this.$el); console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); //已被初始化 &#125;, mounted() &#123; console.group('mounted 挂载结束状态===============》'); console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); //已被初始化 console.log(this.$el); console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); //已被初始化 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); //已被初始化 &#125;, beforeUpdate() &#123; console.group('beforeUpdate 更新前状态===============》'); console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); &#125;, updated() &#123; console.group('updated 更新完成状态===============》'); console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); &#125;, beforeDestroy() &#123; console.group('beforeDestroy 销毁前状态===============》'); console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); &#125;, destroyed() &#123; console.group('destroyed 销毁完成状态===============》'); console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); console.log(this.$el); console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); console.log(\"%c%s\", \"color:red\", \"message: \" + this.message) &#125; &#125;)&lt;/script&gt;&lt;/html&gt; chrome浏览器里打开，F12看console就能发现 3 beforecreated el 和 data 并未初始化 4 created 完成了 data 数据的初始化，el没有 5 beforeMount 完成了 el 和 data 初始化 6 mounted 完成挂载 7 update 在console控制台中输入 1app.message= 'hello!!'; 8 destroy我们在console里执行下命令对 vue实例进行销毁。销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在，可以这么理解，执行了destroy操作，后续就不再受vue控制了。 1app.$destroy(); 9 生命周期总结 9.1 beforecreate 可以在这加个loading事件,加载的动画 9.2 created 在这结束loading，还做一些初始化，实现函数自执行 9.3 mounted 在这发起后端请求，拿回数据，配合路由钩子做一些事情 9.4 beforeDestroy 你确认删除XX吗？ destroyed ：当前组件已被删除，清空相关内容","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"18 数据-属性(props)","slug":"Vue.js 2.0 手把手入门笔记/18 数据-属性(props)","date":"2019-05-16T07:10:04.000Z","updated":"2019-06-15T02:06:37.000Z","comments":true,"path":"2019/05/16/Vue.js 2.0 手把手入门笔记/18 数据-属性(props)/","link":"","permalink":"http://yoursite.com/2019/05/16/Vue.js 2.0 手把手入门笔记/18 数据-属性(props)/","excerpt":"","text":"组件接受的选项之一 props 是 Vue 中非常重要的一个选项。父子组件的关系可以总结为：props down, events up父组件通过 props 向下传递数据给子组件；子组件通过 events 给父组件发送消息。 父子级组件比如我们需要创建两个组件 parent 和 child。需要保证每个组件可以在相对隔离的环境中书写，这样也能提高组件的可维护性。这里我们先定义父子两个组件和一个 Vue 对象 12345678910111213141516171819202122var childNode = &#123; template: ` &lt;div&gt;childNode&lt;/div&gt; `&#125;;var parentNode = &#123; template: ` &lt;div&gt; &lt;child&gt;&lt;/child&gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; `, components: &#123; child: childNode &#125;&#125;;new Vue(&#123; el: &quot;#example&quot;, components: &#123; parent: parentNode &#125;&#125;); 123&lt;div id=\"example\"&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt; 这里的 childNode 定义的 template 是一个 div，并且内容是”childNode”字符串。而在 parentNode 的 template 中定义了 div 的 class 名叫 parent 并且包含了两个 child 组件。 静态 props 组件实例的作用域是孤立的。这意味着不能（也不应该）在子组件的模板中直接引用父组件的数据。要让子组件使用父组件的数据，需要通过子组件的 props 选项。父组件向子组件传递数据分为两种方式：动态和静态，这里先介绍静态方式。子组件要显示的用 props 声明它期望获得的数据修改上例中的代码，给 childNode 添加一个 props 选项和需要的forChildMsg数据;然后在父组件中的占位符添加特性的方式来传递数据。 1234567891011121314151617181920var childNode = &#123; template: ` &lt;div&gt; &#123;&#123;forChildMsg&#125;&#125; &lt;/div&gt; `, props: [\"for-child-msg\"] // 直接把参数作为数组放进去&#125;;var parentNode = &#123; template: ` &lt;div&gt; &lt;p&gt;parentNode&lt;/p&gt; &lt;child for-child-msg=\"aaa\"&gt;&lt;/child&gt; &lt;child for-child-msg=\"bbb\"&gt;&lt;/child&gt; &lt;/div&gt; `, components: &#123; child: childNode &#125;&#125;; 命名规范** 对于 props 声明的属性，在父组件的 template 模板中，属性名需要使用中划线写法；子组件 props 属性声明时，使用小驼峰或者中划线写法都可以；而子组件的模板使用从父组件传来的变量时，需要使用对应的小驼峰写法。别担心，Vue 能够正确识别出小驼峰和下划线命名法混用的变量，如这里的forChildMsg和for-child-msg是同一值。 动态props 原则上很简单，for-child-msg作为一个变量 123456789101112131415161718var parentNode = &#123; template: ` &lt;div&gt; &lt;p&gt;parentNode&lt;/p&gt; &lt;child :for-child-msg=\"childMsg1\"&gt;&lt;/child&gt; &lt;child :for-child-msg=\"childMsg2\"&gt;&lt;/child&gt; &lt;/div&gt; `, components: &#123; child: childNode &#125;, data: function() &#123; return &#123; childMsg1: \"child-1\", childMsg2: \"child-2\" &#125;; &#125;&#125;; 在父组件的 data 的 return 数据中的 childMsg1 和 childMsg2 会被传入子组件中 props 验证验证传入的 props 参数的数据规格，如果不符合数据规格，Vue 会发出警告。 能判断的所有种类（也就是 type 值）有：String, Number, Boolean, Function, Object, Array, Symbol 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Vue.component(\"example\", &#123; props: &#123; // 基础类型检测, null意味着任何类型都行 propA: Number, // 多种类型 propB: [String, Number], // 必传且是String propC: &#123; type: String, required: true &#125;, // 数字有默认值 propD: &#123; type: Number, default: 101 &#125;, // 数组、默认值是一个工厂函数返回对象 propE: &#123; type: Object, default: function() &#123; console.log(\"propE default invoked.\"); return &#123; message: \"I am from propE.\" &#125;; &#125; &#125;, // 自定义验证函数 propF: &#123; isValid: function(value) &#123; return value &gt; 100; &#125; &#125; &#125;&#125;);let childNode = &#123; template: \"&lt;div&gt;&#123;&#123;forChildMsg&#125;&#125;&lt;/div&gt;\", props: &#123; \"for-child-msg\": Number &#125;&#125;;let parentNode = &#123; template: ` &lt;div class=\"parent\"&gt; &lt;child :for-child-msg=\"msg\"&gt;&lt;/child&gt; &lt;/div&gt;`, components: &#123; child: childNode &#125;, data() &#123; return &#123; // 当这里是字符串 \"123456\"时会报错 msg: 123456 &#125;; &#125;&#125;; 还可以在 props 定义的数据中加入自定义验证函数，当函数返回 false 时，输出警告。比如我们把上述例子中的 childNode 的for-child-msg修改成一个对象，并包含一个名叫validator的函数，该命名是规定叫validator的，自定义函数名不会生效 12345678910let childNode = &#123; template: \"&lt;div&gt;&#123;&#123;forChildMsg&#125;&#125;&lt;/div&gt;\", props: &#123; \"for-child-msg\": &#123; validator: function(value) &#123; return value &gt; 100; &#125; &#125; &#125;&#125;; 在这里我们给for-child-msg变量设置了validator函数，并且要求传入的值必须大于 100，否则报出警告。 单向数据流props 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件五一修改父组件的状态。所以不应该在子组件中修改 props 中的值，Vue 会报出警告。 1234567891011121314151617181920212223242526272829303132let childNode = &#123; template: `&lt;div class=\"child\"&gt; &lt;div&gt; &lt;span&gt;子组件数据&lt;/span&gt; &lt;input v-model=\"forChildMsg\"/&gt; &lt;/div&gt; &lt;p&gt;&#123;&#123;forChildMsg&#125;&#125;&lt;/p&gt; &lt;/div&gt;`, props: &#123; \"for-child-msg\": String &#125;&#125;;let parentNode = &#123; template: ` &lt;div class=\"parent\"&gt; &lt;div&gt; &lt;span&gt;父组件数据&lt;/span&gt; &lt;input v-model=\"msg\"/&gt; &lt;/div&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;child :for-child-msg=\"msg\"&gt;&lt;/child&gt; &lt;/div&gt;`, components: &#123; child: childNode &#125;, data() &#123; return &#123; msg: \"default string.\" &#125;; &#125;&#125;; 传递的过程将短横分割命名，转成驼峰命名法即可 这里我们给父组件和子组件都有一个输入框，并且显示出父组件数据和子组件的数据。当我们在父组件的输入框输入新数据时，同步的子组件数据也被修改了；这就是 props 的向子组件传递数据。而当我们修改子组件的输入框时，浏览器的控制台则报出错误警告 [Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop’s value. Prop being mutated: “forChildMsg” 修改 props 数据通常有两种原因： prop 作为初始值传入后，子组件想把它当做局部数据来用 prop 作为初始值传入后，由子组件处理成其他数据输出 定义一个局部变量，并用 prop 的值初始化它 但是由于定义的 ownChildMsg 只能接受 forChildMsg 的初始值，当父组件要传递的值变化发生时，ownChildMsg 无法收到更新。 1234567891011121314151617let childNode = &#123; template: ` &lt;div class=\"child\"&gt; &lt;div&gt; &lt;span&gt;子组件数据&lt;/span&gt; &lt;input v-model=\"forChildMsg\"/&gt; &lt;/div&gt; &lt;p&gt;&#123;&#123;forChildMsg&#125;&#125;&lt;/p&gt; &lt;p&gt;ownChildMsg : &#123;&#123;ownChildMsg&#125;&#125;&lt;/p&gt; &lt;/div&gt;`, props: &#123; \"for-child-msg\": String &#125;, data() &#123; return &#123; ownChildMsg: this.forChildMsg &#125;; &#125;&#125;; 这里我们加了一个用于查看 ownChildMsg 数据是否变化，结果发现只有默认值传递给了 ownChildMsg，父组件改变只会变化到 forChildMsg，不会修改 ownChildMsg。 定义一个计算属性，处理 prop 的值并返回 由于是计算属性，所以只能显示值，不能设置值。我们这里设置的是一旦从父组件修改了 forChildMsg 数据，我们就把 forChildMsg 加上一个字符串”—ownChildMsg”，然后显示在屏幕上。这时是可以每当父组件修改了新数据，都会更新 ownChildMsg 数据的。 12345678910111213141516171819let childNode = &#123; template: ` &lt;div class=\"child\"&gt; &lt;div&gt; &lt;span&gt;子组件数据&lt;/span&gt; &lt;input v-model=\"forChildMsg\"/&gt; &lt;/div&gt; &lt;p&gt;&#123;&#123;forChildMsg&#125;&#125;&lt;/p&gt; &lt;p&gt;ownChildMsg : &#123;&#123;ownChildMsg&#125;&#125;&lt;/p&gt; &lt;/div&gt;`, props: &#123; \"for-child-msg\": String &#125;, computed: &#123; ownChildMsg() &#123; return this.forChildMsg + \"---ownChildMsg\"; &#125; &#125;&#125;; 更加妥帖的方式是使用变量存储 prop 的初始值，并用 watch 来观察 prop 值得变化。发生变化时，更新变量的值。 123456789101112131415161718192021222324let childNode = &#123; template: ` &lt;div class=\"child\"&gt; &lt;div&gt; &lt;span&gt;子组件数据&lt;/span&gt; &lt;input v-model=\"forChildMsg\"/&gt; &lt;/div&gt; &lt;p&gt;&#123;&#123;forChildMsg&#125;&#125;&lt;/p&gt; &lt;p&gt;ownChildMsg : &#123;&#123;ownChildMsg&#125;&#125;&lt;/p&gt; &lt;/div&gt;`, props: &#123; \"for-child-msg\": String &#125;, data() &#123; return &#123; ownChildMsg: this.forChildMsg &#125;; &#125;, watch: &#123; forChildMsg() &#123; this.ownChildMsg = this.forChildMsg; &#125; &#125;&#125;;","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"17 数据-观察(watch)","slug":"Vue.js 2.0 手把手入门笔记/17 数据-观察(watch)","date":"2019-05-16T06:10:04.000Z","updated":"2019-06-15T02:06:43.000Z","comments":true,"path":"2019/05/16/Vue.js 2.0 手把手入门笔记/17 数据-观察(watch)/","link":"","permalink":"http://yoursite.com/2019/05/16/Vue.js 2.0 手把手入门笔记/17 数据-观察(watch)/","excerpt":"","text":"一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 为什么一定要有watch，不用可以吗？我们已经有了computed，能不能不去使用? 1 watch的出现 做一个实验 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"a\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; a:\"1\" &#125;, computed: &#123; a()&#123; setTimeout(() =&gt; &#123; this.a=1; &#125;, 500); &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 不难发现在异步的情况下就不好使用了 2 代码实现123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"a\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; a:\"\" &#125;, watch: &#123; // 只有值变化的时候才会触发 支持异步了，其他情况我们更善于使用 a(newVal,oldVal)&#123; // watch的属性名字要和观察的人的名字一致 console.log(newVal); console.log(oldVal); &#125; &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 3 computed与watch的区别Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动:侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123; fullName &#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;/html&gt; 12345678910111213141516var vm = new Vue(&#123;el: '#app', data: &#123; firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + ' ' + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + ' ' + val &#125; &#125;&#125;) 上面代码是命令式且重复的。将它与计算属性的版本进行比较： 123456789101112var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar' &#125;, computed: &#123; fullName: function () &#123; return this.firstName + ' ' + this.lastName &#125; &#125;&#125;) 是不是感觉优雅很多 4 侦听器虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"something\"&gt; &#123;&#123;somethingShow&#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; something: '', somethingShow:'' &#125;, watch: &#123; something(val)&#123; this.somethingShow = \"loading\" this.getSomething() &#125; &#125;, methods:&#123; getSomething()&#123; setTimeout(() =&gt; &#123; this.somethingShow = \"hello\" &#125;, 1000);// 我们使用延迟模拟一个网络请求 &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 5 vm.$watch vm.$watch( expOrFn, callback, [options] ) 观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"something\"&gt; &#123;&#123;somethingShow&#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; something: '', somethingShow:'' &#125; &#125;) vm.$watch('something',(newVal,oldVal)=&gt;&#123;// watch的属性名要和观察的人名字一致 vm.somethingShow = \"loading\" console.log('===================================='); console.log(newVal); console.log('===================================='); vm.somethingShow = newVal &#125;)&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"16 数据-计算属性(computed)","slug":"Vue.js 2.0 手把手入门笔记/16 数据-计算属性(computed)","date":"2019-05-16T05:10:04.000Z","updated":"2019-06-15T02:06:49.000Z","comments":true,"path":"2019/05/16/Vue.js 2.0 手把手入门笔记/16 数据-计算属性(computed)/","link":"","permalink":"http://yoursite.com/2019/05/16/Vue.js 2.0 手把手入门笔记/16 数据-计算属性(computed)/","excerpt":"","text":"9.1 什么是计算属性模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如: 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div id=\"example\"&gt; &#123;&#123; message.split('').reverse().join('') &#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; message: 'Hello' &#125; &#125;); &lt;/script&gt; &lt;/div&gt;&lt;/html&gt; 这里的表达式包含3个操作，并不是很清晰，所以遇到复杂逻辑时应该使用Vue特带的计算属性computed来进行处理。 9.2 计算属性的用法123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div id=\"example\"&gt; &#123;&#123;getMessage&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; message: 'Hello' &#125;, computed: &#123; // 放在computed中最后也会放在vm上，不能和methods与data重名 getMessage() &#123; return this.message.split('').reverse().join('') &#125; &#125; &#125;); &lt;/script&gt; &lt;/div&gt;&lt;/html&gt; 9.3 计算属性使用技巧计算属性可以依赖其他计算属性计算属性不仅可以依赖当前Vue 实例的数据，还可以依赖其他实例的数据 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app1\"&gt;&lt;/div&gt; &lt;div id=\"app2\"&gt; &#123;&#123;getMessage&#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script&gt; var vm= new Vue(&#123; el: '#app1', data: &#123; message: 'World' &#125; &#125;); var vm2 = new Vue(&#123; el: '#app2', data: &#123; message: 'Hello' &#125;, computed: &#123; getMessage() &#123; return `$&#123;this.message&#125; $&#123;vm.message&#125;` &#125; &#125; &#125;); &lt;/script&gt; &lt;/div&gt;&lt;/html&gt; 9.4 getter和setter每一个计算属性都包含一个getter 和一个setter ，我们上面的两个示例都是计算属性的默认用法， 只是利用了getter 来读取。在你需要时，也可以提供一个setter 函数， 当手动修改计算属性的值就像修改一个普通数据那样时，就会触发setter 函数，执行一些自定义的操作 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"getMessage\"&gt; &lt;--模拟修改--!&gt; &#123;&#123;getMessage&#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script&gt; var vm= new Vue(&#123; el: '#app', data: &#123; hi:'Hello', message: 'World' &#125;, computed:&#123; getMessage:&#123; //get,set方法 // getter get()&#123; return this.hi + ' ' + this.message &#125;, // setter set(newValue)&#123; console.log('===================================='); console.log(newValue); console.log('===================================='); var names = newValue.split(' '); this.hi = names[0]; this.message = names[names.length - 1]; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 绝大多数情况下，我们只会用默认的getter 方法来读取一个计算属性，在业务中很少用到setter,所以在声明一个计算属性时，可以直接使用默认的写法，不必将getter 和setter 都声明。 9.5 质疑什么不直接用methods我们可以将同一函数定义为一个方法而不是一个计算属性，两种方式的最终结果确实是完全相同的。只是一个使用getMessage()取值，一个使用getMessage取值。然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 hi还没有发生改变，多次访问 getMessage计算属性会立即返回之前的计算结果，而不必再次执行函数。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div&gt;&#123;&#123;getMessage&#125;&#125;&lt;/div&gt; &lt;div&gt; &#123;&#123;getMessage1()&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script&gt; var vm= new Vue(&#123; el: '#app', data: &#123; hi:'Hello', message: 'World' &#125;, computed:&#123; getMessage()&#123; //get,set方法 return this.hi + ' ' + this.message //而使用计算属性，只要title没变，页面渲染是不会重新进这里来计算的，而是使用了缓存。 &#125; &#125;, methods:&#123; getMessage1()&#123; return this.hi + ' ' + this.message //进这个方法，再次计算。不是刷新，而是只要页面渲染，就会进方法里重新计算。 &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt;","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"15 动态绑定样式-v-bind","slug":"Vue.js 2.0 手把手入门笔记/15 动态绑定样式-v-bind","date":"2019-05-16T04:10:04.000Z","updated":"2019-06-15T02:06:53.000Z","comments":true,"path":"2019/05/16/Vue.js 2.0 手把手入门笔记/15 动态绑定样式-v-bind/","link":"","permalink":"http://yoursite.com/2019/05/16/Vue.js 2.0 手把手入门笔记/15 动态绑定样式-v-bind/","excerpt":"","text":"13.1 对象语法 :class 绑定的样式和class绑定的不冲突 13.1.1 直接绑定一个data1&lt;div v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/div&gt; active 这个 class 存在与否将取决于数据属性 isActive 的 布尔值 1&lt;div class=\"static\" v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt;&lt;/div&gt; 13.1.2 data中使用一个对象绑定123456data: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125; 13.1.3 计算属性中绑定123456789101112data: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, 'text-danger': this.error &amp;&amp; this.error.type === 'fatal' &#125; &#125;&#125; 13.2 数组语法1&lt;div v-bind:class=\"[activeClass, errorClass]\"&gt;&lt;/div&gt; 13.2.1 直接动态绑定一个class1234data: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; 13.2.2 三元表达式1&lt;div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"&gt;&lt;/div&gt; 不过，当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法： 1&lt;div v-bind:class=\"[&#123; active: isActive &#125;, errorClass]\"&gt;&lt;/div&gt;","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"14 插槽-slot","slug":"Vue.js 2.0 手把手入门笔记/14 插槽-slot","date":"2019-05-16T03:10:04.000Z","updated":"2019-06-15T02:06:59.000Z","comments":true,"path":"2019/05/16/Vue.js 2.0 手把手入门笔记/14 插槽-slot/","link":"","permalink":"http://yoursite.com/2019/05/16/Vue.js 2.0 手把手入门笔记/14 插槽-slot/","excerpt":"","text":"老版本vue 模板中只能有一个根元素 HTML内容模板（）元素是一种用于保存客户端内容机制，该内容在加载页面时不会呈现，但随后可以在运行时使用JavaScript实例化。 123456789&lt;div id=\"app\"&gt; &lt;modal&gt;&lt;/modal&gt; &lt;/div&gt;&lt;template id=\"modal\"&gt; &lt;div&gt; &lt;h1&gt;是否删除&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112let modal = &#123; template:\"#modal\"&#125;const app = new Vue(&#123; el:'#app', components:&#123; modal &#125;, data:&#123; &#125;&#125;) 我们通常是想把h1的值动态放入，所以就要用到插槽 单个插槽 | 默认插槽 | 匿名插槽 首先是单个插槽，单个插槽是vue的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置name属性。单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（name属性）不同就可以了。 1234567891011&lt;div id=\"app\"&gt; &lt;modal&gt; &lt;h1&gt;插入成功&lt;/h1&gt; &lt;/modal&gt;&lt;/div&gt;&lt;template id=\"modal\"&gt; &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 当我们看到插入成功的时候，匿名插入就实现了 具名插槽 匿名插槽没有name属性，所以是匿名插槽，那么，插槽加了name属性，就变成了具名插槽。具名插槽可以在一个组件中出现N次，出现在不同的位置。下面的例子，就是一个有两个具名插槽和单个插槽的组件，这三个插槽被父组件用同一套css样式显示了出来，不同的是内容上略有区别。 简单的来说，就是，我们可能遇到一个问题我们想插入不同的插槽内的内容不一样 在 2.6.0+ 中已弃用 123456789101112131415&lt;div id=\"app\"&gt; &lt;modal&gt; &lt;h1&gt;插入成功&lt;/h1&gt; &lt;h2 slot=\"title\"&gt;标题&lt;/h2&gt; &lt;h2 slot=\"content\"&gt;内容&lt;/h2&gt; &lt;/modal&gt;&lt;/div&gt;&lt;template id=\"modal\"&gt; &lt;div&gt; &lt;slot name=\"default\"&gt;&lt;/slot&gt; &lt;slot name=\"title\"&gt;&lt;/slot&gt; &lt;slot name=\"content\"&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 我们可以发现没有name的情况下，默认就是default 作用域插槽 | 带数据的插槽 最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的template里面写 在 2.6.0+ 中已弃用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue作用域插槽&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/vue/2.3.4/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app2\"&gt; &lt;!-- 组件使用者只需传递users数据即可 --&gt; &lt;my-stripe-list :items=\"users\" odd-bgcolor=\"#D3DCE6\" even-bgcolor=\"#E5E9F2\"&gt; &lt;!-- props对象接收来自子组件slot的$index参数 --&gt; &lt;template slot=\"cont\" scope=\"props\"&gt; &lt;span&gt;&#123;&#123;users[props.$index].id&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;users[props.$index].name&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;users[props.$index].age&#125;&#125;&lt;/span&gt; &lt;!-- 这里可以自定[编辑][删除]按钮的链接和样式 --&gt; &lt;a :href=\"'#edit/id/'+users[props.$index].id\"&gt;编辑&lt;/a&gt; &lt;a :href=\"'#del/id/'+users[props.$index].id\"&gt;删除&lt;/a&gt; &lt;/template&gt; &lt;/my-stripe-list&gt; &lt;/div&gt; &lt;script&gt; Vue.component('my-stripe-list', &#123; /*slot的$index可以传递到父组件中*/ template: ` &lt;div&gt; &lt;div v-for=\"(item, index) in items\" style=\"line-height:2.2;\" :style=\"index % 2 === 0 ? 'background:'+oddBgcolor : 'background:'+evenBgcolor\"&gt; &lt;slot name=\"cont\" :$index=\"index\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; `, props: &#123; items: Array, oddBgcolor: String, evenBgcolor: String &#125; &#125;); new Vue(&#123; el: '#app2', data: &#123; users: [&#123; id: 1, name: '张三', age: 20 &#125;, &#123; id: 2, name: '李四', age: 22 &#125;, &#123; id: 3, name: '王五', age: 27 &#125;, &#123; id: 4, name: '张龙', age: 27 &#125;, &#123; id: 5, name: '赵虎', age: 27 &#125; ] &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这种写法，习惯了element-ui的朋友一定就很熟悉了。 总结： 1 . 使用slot可以在自定义组件内插入原生HTML元素，需要搭配使用name和slot属性，否则多个slot可能会返回重复的HTML元素。2 . 使用slot-scope可以将slot内部的作用域指向该子组件，否则默认作用域指向调用slot的父组件。 新版本的 v-slot 从 vue@2.6.x 开始，Vue 为具名和范围插槽引入了一个全新的语法，即我们今天要讲的主角：v-slot 指令。目的就是想统一 slot 和 scope-slot 语法，使代码更加规范和清晰。既然有新的语法上位，很明显，slot 和 scope-slot 也将会在 vue@3.0.x 中彻底的跟我们说拜拜了。而从 vue@2.6.0 开始，官方推荐我们使用 v-slot 来替代后两者。 #### 具名插槽 > 实例化一个vue 123456789101112131415// 组件Vue.component('lv-hello', &#123; template: ` &lt;div&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;h1&gt;我的天呀&lt;/h1&gt; &lt;/div&gt;`&#125;)new Vue(&#123; el: '#app1', data: &#123; &#125;&#125;); 老版本 123456&lt;div id=\"app1\"&gt; &lt;!-- 老版本使用具名插槽 --&gt; &lt;lv-hello&gt; &lt;p slot=\"header\"&gt;我是头部&lt;/p&gt; &lt;/lv-hello&gt;&lt;/div&gt; 新版本的变化 12345678 &lt;!-- 新版本使用具名插槽 --&gt; &lt;lv-hello&gt; &lt;!-- 注意：这块的 v-slot 指令只能写在 template 标签上面，而不能放置到 p 标签上 --&gt; &lt;template v-slot:header&gt; &lt;p&gt;我是头部&lt;/p&gt; &lt;/template&gt; &lt;/lv-hello&gt;&lt;/div&gt; 具名插槽的缩写 将 v-slot: 替换成 # 号 1234567891011&lt;div id=\"app\"&gt; &lt;lv-hello&gt; &lt;template #header&gt; &lt;p&gt;我是头部&lt;/p&gt; &lt;/template&gt; &lt;!-- 注意: #号后面必须有参数，否则会报错。即便是默认插槽，也需要写成 #default --&gt; &lt;template #default&gt; &lt;p&gt;我是默认插槽&lt;/p&gt; &lt;/template&gt; &lt;/lv-hello&gt;&lt;/div&gt; 作用域插槽 所谓作用域插槽，就是让插槽的内容能够访问子组件中才有的数据。 123456789101112131415Vue.component('lv-hello', &#123; data: function () &#123; return &#123; firstName: '张', lastName: '三' &#125; &#125;, template: ` &lt;div&gt; &lt;slot name=\"header\" :firstName=\"firstName\" :lastName=\"lastName\"&gt;&lt;/slot&gt; &lt;h1&gt;我的天呀&lt;/h1&gt; &lt;/div&gt; `&#125;) 12345678910111213&lt;div id=\"app\"&gt; &lt;!-- 老版本使用具名插槽 --&gt; &lt;lv-hello&gt; &lt;p slot=\"header\" slot-scope=\"hh\"&gt;我是头部 &#123;&#123; hh.firstName &#125;&#125; &#123;&#123; hh.lastName &#125;&#125;&lt;/p&gt; &lt;/lv-hello&gt;&lt;!-- 新版本使用具名插槽 --&gt; &lt;lv-hello&gt; &lt;!-- 注意：这块的 v-slot 指令只能写在 template 标签上面，而不能放置到 p 标签上 --&gt; &lt;template v-slot:header=\"hh\"&gt; &lt;p&gt;我是头部 &#123;&#123; hh.firstName &#125;&#125; &#123;&#123; hh.lastName &#125;&#125;&lt;/p&gt; &lt;/template&gt; &lt;/lv-hello&gt;&lt;/div&gt;","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"13 全局api-fifer过滤器","slug":"Vue.js 2.0 手把手入门笔记/13 全局api-fifer过滤器","date":"2019-05-15T15:10:04.000Z","updated":"2019-06-15T02:07:07.000Z","comments":true,"path":"2019/05/15/Vue.js 2.0 手把手入门笔记/13 全局api-fifer过滤器/","link":"","permalink":"http://yoursite.com/2019/05/15/Vue.js 2.0 手把手入门笔记/13 全局api-fifer过滤器/","excerpt":"","text":"8.1 介绍允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示 8.2 优势1、在Vue中使用过滤器（Filters）来渲染数据是一种很有趣的方式。2、首先我们要知道，Vue中的过滤器不能替代Vue中的methods、computed或者watch，3、过滤器不改变真正的data，而只是改变渲染的结果，并返回过滤后的版本。4、在很多不同的情况下，过滤器都是有用的，比如尽可能保持API响应的干净，并在前端处理数据的格式。5、在你希望避免重复和连接的情况下，它们也可以有效地封装成可重用代码块背后的所有逻辑。 8.3 过滤器例子12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script&gt; var vm= new Vue(&#123; el: '#app', data: &#123; message: 'world' &#125;, filters: &#123; // 可以有好多的自定义过滤器 capitalize(value) &#123; // 这里的this指向的window if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 8.4 过滤器串连1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123; message | filterA | filterB &#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script&gt; var vm= new Vue(&#123; el: '#app', data: &#123; message: 'world' &#125;, filters: &#123; // 可以有好多的自定义过滤器 filterA(value)&#123; return value.split('').reverse().join(''); &#125;, filterB(value)&#123; return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 8.5 过滤器传参123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123; message | filterA('hello',hi) &#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;script&gt; var vm= new Vue(&#123; el: '#app', data: &#123; hi:'!', message: 'world' &#125;, filters: &#123; // 可以有好多的自定义过滤器 filterA(value1,value2,value3)&#123; return `$&#123;value2&#125; $&#123;value1&#125; $&#123;value3&#125;`; &#125; &#125; &#125;); &lt;/script&gt;&lt;/html&gt; 这里，filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数，普通字符串 ‘hello’ 作为第二个参数，表达式 hi 的值作为第三个参数。","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"12 全局api-delete","slug":"Vue.js 2.0 手把手入门笔记/12 全局api-delete","date":"2019-05-15T14:10:04.000Z","updated":"2019-06-15T02:07:12.000Z","comments":true,"path":"2019/05/15/Vue.js 2.0 手把手入门笔记/12 全局api-delete/","link":"","permalink":"http://yoursite.com/2019/05/15/Vue.js 2.0 手把手入门笔记/12 全局api-delete/","excerpt":"","text":"Vue.delete( target, propertyName/index ) 参数： {Object | Array} target {string | number} propertyName/index 仅在 2.2.0+ 版本中支持 Array + index 用法。 用法：删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。 在 2.2.0+ 中同样支持在数组上工作。 目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。 123456data:&#123; namelist : &#123; id : 1, name : '叶落森' &#125; &#125; 123// 删除namedelete this.namelist.name;//js方法Vue.delete(this.namelist,'name');//vue方法","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"11 全局api-set","slug":"Vue.js 2.0 手把手入门笔记/11 全局api-set","date":"2019-05-15T13:10:04.000Z","updated":"2019-06-15T02:07:18.000Z","comments":true,"path":"2019/05/15/Vue.js 2.0 手把手入门笔记/11 全局api-set/","link":"","permalink":"http://yoursite.com/2019/05/15/Vue.js 2.0 手把手入门笔记/11 全局api-set/","excerpt":"","text":"官网说明Vue.set( target, propertyName/index, value ) 参数： {Object | Array} target {string | number} propertyName/index {any} value 返回值：设置的值。 用法：向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = &#39;hi&#39;) 注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。 示例12345678910111213141516&lt;div id=\"div\"&gt; &lt;p &gt;&#123;&#123;items&#125;&#125;&lt;/p&gt;&lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123;el:\"#div\", data: &#123; items: ['a', 'b', 'c'] &#125;&#125;); Vue.set(vm.items,2,\"ling\") &lt;/script&gt; 1 设置数组元素Vue.set(vm.items,2,”ling”) : 表示 把vm.items 这个数组的下标为2 的元素，改为”ling”把数组 [“a”,”b”,”c”] 修改 后是 [“a”,”b”,”ling”] 2 向响应式对象添加属性1234567891011121314151617181920&lt;div id=\"div\"&gt; &lt;p&gt;&#123;&#123;person&#125;&#125;&lt;/p&gt;&lt;/div&gt; &lt;script&gt;var vm = new Vue(&#123;el:\"#div\",data: &#123; person:&#123; name:\"ling\", job:\"engineer\" &#125;&#125;,created:function()&#123; alert(this.person.age) &#125;&#125;); Vue.set(vm.person,\"age\",\"26\")&lt;/script&gt; 注意：person 是data 里面的子对象，所以可以使用 Vue.set( ) 方法。data 这个根对象就不能使用 set 方法 说明：控制台可以在person 里找到age 这个属性，说明添加成功 (响应式) ** 对比非响应式方法vm.food=”chocolate”alert(vm.food) 控制台和网页上的 都没有显示food 这个属性，说明food 这个属性没有被添加 （非响应式） **","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"10 全局api-nextTick","slug":"Vue.js 2.0 手把手入门笔记/10 全局api-nextTick","date":"2019-05-15T12:10:04.000Z","updated":"2019-06-15T02:07:25.000Z","comments":true,"path":"2019/05/15/Vue.js 2.0 手把手入门笔记/10 全局api-nextTick/","link":"","permalink":"http://yoursite.com/2019/05/15/Vue.js 2.0 手把手入门笔记/10 全局api-nextTick/","excerpt":"","text":"官方说明参数： {Function} [callback] {Object} [context] 用法：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 12345678910111213// 修改数据vm.msg = 'Hello'// DOM 还没有更新Vue.nextTick(function () &#123; // DOM 更新了&#125;)// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)Vue.nextTick() .then(function () &#123; // DOM 更新了&#125;) 2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。 示例先来一个示例了解下关于Vue中的DOM更新以及nextTick的作用。模板 123456789&lt;div class=\"app\"&gt; &lt;div ref=\"msgDiv\"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;div v-if=\"msg1\"&gt;Message got outside $nextTick: &#123;&#123;msg1&#125;&#125;&lt;/div&gt; &lt;div v-if=\"msg2\"&gt;Message got inside $nextTick: &#123;&#123;msg2&#125;&#125;&lt;/div&gt; &lt;div v-if=\"msg3\"&gt;Message got outside $nextTick: &#123;&#123;msg3&#125;&#125;&lt;/div&gt; &lt;button @click=\"changeMsg\"&gt; Change the Message &lt;/button&gt;&lt;/div&gt; Vue实例** 12345678910111213141516171819new Vue(&#123; el: '.app', data: &#123; msg: 'Hello Vue.', msg1: '', msg2: '', msg3: '' &#125;, methods: &#123; changeMsg() &#123; this.msg = \"Hello world.\" this.msg1 = this.$refs.msgDiv.innerHTML this.$nextTick(() =&gt; &#123; this.msg2 = this.$refs.msgDiv.innerHTML &#125;) this.msg3 = this.$refs.msgDiv.innerHTML &#125; &#125;&#125;) 点击前 点击后 从图中可以得知：msg1和msg3显示的内容还是变换之前的，而msg2显示的内容是变换之后的。其根本原因是因为Vue中DOM更新是异步的（详细解释在后面）。 应用场景下面了解下nextTick的主要应用的场景及原因。 在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中 在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted()钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。 具体原因在Vue的官方文档中详细解释: Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0)代替。例如，当你设置vm.someData = &#39;new value&#39;，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"9 全局api- Vue.extend","slug":"Vue.js 2.0 手把手入门笔记/9 全局api- Vue.extend","date":"2019-05-15T11:10:04.000Z","updated":"2019-06-15T02:07:30.000Z","comments":true,"path":"2019/05/15/Vue.js 2.0 手把手入门笔记/9 全局api- Vue.extend/","link":"","permalink":"http://yoursite.com/2019/05/15/Vue.js 2.0 手把手入门笔记/9 全局api- Vue.extend/","excerpt":"","text":"使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。 data 选项是特例，需要注意 - 在 Vue.extend() 中它必须是函数 1&lt;div id=\"mount-point\"&gt;&lt;/div&gt; 1234567891011121314// 创建构造器var demo = Vue.extend(&#123; template: '&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;', data: function () &#123; return &#123; firstName: 'Walter', lastName: 'White', alias: 'Heisenberg' &#125; &#125;&#125;)// 创建 Profile 实例，并挂载到一个元素上。new demo().$mount('#mount-point')","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"8 组件化管理","slug":"Vue.js 2.0 手把手入门笔记/8 组件化管理","date":"2019-05-15T10:10:04.000Z","updated":"2019-06-15T02:07:35.000Z","comments":true,"path":"2019/05/15/Vue.js 2.0 手把手入门笔记/8 组件化管理/","link":"","permalink":"http://yoursite.com/2019/05/15/Vue.js 2.0 手把手入门笔记/8 组件化管理/","excerpt":"","text":"1.组件化开发我们可以很直观的将一个复杂的页面分割成若干个独立组件，每个组件包含组件的逻辑和样式,再将这些独立组件完成一个复杂的页面。这样既减少了逻辑复杂度，又实现了代码的重用。页面是组件的容器，组件自动组合形成完整的界面，当不需要某个组件时，或者想要替换某个组件时，可以随时进行替换和删除，而不影响整个应用的运行。 2、组件化开发的好处 提高开发效率 方便重复使用 便于协同开发 更容易被管理和维护 在vue中例如div、span都可以看做一个组件 3、全局组件 全局组件:可以声明一次在任何地方使用 局部组件:必须告诉这个组件属于谁 一般写插件的时候全局组件使用的多一些 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;my-handsom&gt;&lt;/my-handsom&gt; &lt;my-handsom&gt;&lt;/my-handsom&gt; &lt;my-handsom&gt;&lt;/my-handsom&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt;&lt;script&gt; Vue.component(\"my-handsom\",&#123; //一个对象可以看成一个组件 data: function () &#123; return &#123; count: 0 &#125; &#125;, template: '&lt;button v-on:click=\"count++\"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;' &#125;) var vm = new Vue(&#123; el: '#app' &#125;)&lt;/script&gt;&lt;/html&gt; ## 组件名不要带大写，多组件使用 - 只要组件和定义相同是可以的(首字母可以大写) html采用短横线隔开命名法js中转驼峰也是可以的 深入了解组件props 组件的参数传递 slot 插槽在组件抽象设计中的应用 自定义事件 父子组件的通信方式","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"7 缩写","slug":"Vue.js 2.0 手把手入门笔记/7 缩写","date":"2019-05-15T09:10:04.000Z","updated":"2019-06-15T02:07:42.000Z","comments":true,"path":"2019/05/15/Vue.js 2.0 手把手入门笔记/7 缩写/","link":"","permalink":"http://yoursite.com/2019/05/15/Vue.js 2.0 手把手入门笔记/7 缩写/","excerpt":"","text":"7.1 指令缩写1234&lt;a v-bind:href='url'&gt;&lt;/a&gt;&lt;a :href='url'&gt;&lt;/a&gt;&lt;a v-on:click='doSomething'&gt;&lt;/a&gt;&lt;a @click='doSomething'&gt;&lt;/a&gt; 7.2 函数缩写 缩写后","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"6 事件修饰符的使用","slug":"Vue.js 2.0 手把手入门笔记/6 事件修饰符的使用","date":"2019-05-15T08:10:04.000Z","updated":"2019-06-15T02:07:47.000Z","comments":true,"path":"2019/05/15/Vue.js 2.0 手把手入门笔记/6 事件修饰符的使用/","link":"","permalink":"http://yoursite.com/2019/05/15/Vue.js 2.0 手把手入门笔记/6 事件修饰符的使用/","excerpt":"","text":"1 事件处理如果需要在内联语句处理器中访问原生DOM事件。可以使用特殊变量`$event`，把它传入到`methods`中的方法中。&lt;br /&gt; 在Vue中，**事件修饰符**处理了许多DOM事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理。在Vue中事件修饰符主要有： .stop：等同于JavaScript中的event.stopPropagation()，防止事件冒泡 .prevent：等同于JavaScript中的event.preventDefault()，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播） .capture：与事件冒泡的方向相反，事件捕获由外到内 .self：只会触发自己范围内的事件，不包含子元素 .once：只会触发一次1.1 stop 防止事件冒泡冒泡事件：嵌套两三层父子关系，然后所有都有点击事件，点击子节点，就会触发从内至外 子节点-》父节点的点击事件 12345678910111213141516171819202122232425262728&lt;!-- HTML --&gt; &lt;div id=\"app\"&gt; &lt;div class=\"outeer\" @click=\"outer\"&gt; &lt;div class=\"middle\" @click=\"middle\"&gt; &lt;button @click=\"inner\"&gt;点击我(^_^)&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;/div&gt; let app = new Vue(&#123; el: '#app', data () &#123; return &#123; message: '测试冒泡事件' &#125; &#125;, methods: &#123; inner: function () &#123; this.message = 'inner： 这是最里面的Button' &#125;, middle: function () &#123; this.message = 'middle: 这是中间的Div' &#125;, outer: function () &#123; this.message = 'outer: 这是外面的Div' &#125; &#125; &#125;) 防止冒泡事件的写法是：在点击上加上.stop相当于在每个方法中调用了等同于event.stopPropagation()，点击子节点不会捕获到父节点的事件 123456789101112131415&lt;!-- HTML --&gt; &lt;div id=\"app\"&gt; &lt;div class=\"outeer\" @click.stop=\"outer\"&gt; &lt;div class=\"middle\" @click.stop=\"middle\"&gt; &lt;button @click.stop=\"inner\"&gt;点击我(^_^)&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 1.2 prevent取消默认事件.prevent等同于JavaScript的event.preventDefault()，用于取消默认事件。比如我们页面的&lt;a href=&quot;#&quot;&gt;标签，当用户点击时，通常在浏览器的网址列出#： #### 1.3 .capture 捕获事件捕获事件：嵌套两三层父子关系，然后所有都有点击事件，点击子节点，就会触发从外至内 父节点-》子节点的点击事件 12345678&lt;!-- HTML --&gt; &lt;div id=\"app\"&gt; &lt;div class=\"outeer\" @click.capture=\"outer\"&gt; &lt;div class=\"middle\" @click.capture=\"middle\"&gt; &lt;button @click.capture=\"inner\"&gt;点击我(^_^)&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 1.4 .self修饰符.self只会触发自己范围内的事件，不会包含子元素。 12345678&lt;!-- HTML --&gt; &lt;div id=\"app\"&gt; &lt;div class=\"outeer\" @click.self=\"outer\"&gt; &lt;div class=\"middle\" @click.self=\"middle\"&gt; &lt;button @click.stop=\"inner\"&gt;点击我(^_^)&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 1.5 .once 只执行一次点击如果我们在@click事件上添加.once修饰符，只要点击按钮只会执行一次。 ## 2 键盘修饰符在JavaScript事件中除了前面所说的事件，还有键盘事件，也经常需要监测常见的键值。在Vue中允许v-on在监听键盘事件时添加关键修饰符。记住所有的keyCode比较困难，所以Vue为最常用的键盘事件提供了别名： .enter：回车键 .tab：制表键 .delete：含delete和backspace键 .esc：返回键 .space: 空格键 .up：向上键 .down：向下键 .left：向左键 .right：向右键 3 鼠标修饰符鼠标修饰符用来限制处理程序监听特定的滑鼠按键。常见的有： .left：鼠标左键 .middle：鼠标中间滚轮 .right：鼠标右键 4 修饰键可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应： .ctrl .alt .shift .meta 5 自定义按键修饰符别名在Vue中可以通过config.keyCodes自定义按键修饰符别名。例如，由于预先定义了keycode 116（即F5）的别名为f5，因此在文字输入框中按下F5，会触发prompt方法，出现alert。 1234567891011121314151617181920212223242526272829&lt;!-- HTML --&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-on:keydown.f5=&quot;prompt()&quot;&gt;&lt;/div&gt;Vue.config.keyCodes.f5 = 116;let app = new Vue(&#123; el: &apos;#app&apos;, methods: &#123; prompt: function() &#123; alert(&apos;我是 F5！&apos;); &#125; &#125;&#125;); ### 6 总结在Vue中，使用v-on来给元素绑定事件，而为了更好的处理逻辑方面的事物，Vue提供了一个methods。在methods中定义一些方法，这些方法可以帮助我们处理一些逻辑方面的事情。而在这篇文章中，我们主要介绍了一些事件的修饰符，比如常见的阻止事件冒泡，键盘修饰符等。除此之外，还提供了config.keyCodes提供自定义按键修饰符别名。","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"5 事件","slug":"Vue.js 2.0 手把手入门笔记/5 事件","date":"2019-05-15T07:10:04.000Z","updated":"2019-06-15T02:07:52.000Z","comments":true,"path":"2019/05/15/Vue.js 2.0 手把手入门笔记/5 事件/","link":"","permalink":"http://yoursite.com/2019/05/15/Vue.js 2.0 手把手入门笔记/5 事件/","excerpt":"","text":"5.1 定义&amp;缩写 事件定义以及缩写 1234567891011121314&lt;div id=\"app\"&gt; &lt;button @click=\"msg\"&gt;&lt;/button&gt; &lt;button @mousedown=\"add\"&gt;&lt;/button&gt; &lt;!--如果不传递参数，则不要写括号会自动传入事件源，如果写括号了，要手动传入$event属性--&gt;&lt;/div&gt;let vm = new Vue(&#123; el:\"#app\", methods:&#123; msg()&#123; console.log(Math.random()); &#125; &#125;&#125;) methods和data中的数据会全部放在vm上，而且名字不能冲突，冲突会报错，methods中的this指向的都是实例 5.2 mousedown当鼠标指针移动到元素上方，并按下鼠标按键（左、右键均可）时，会发生 mousedown 事件。与 click 事件不同，mousedown 事件仅需要按键被按下，而不需要松开即可发生。 5.3 mouseup当在元素上松开鼠标按键（左、右键均可）时，会发生 mouseup 事件。与 click 事件不同，mouseup 事件仅需要松开按钮。当鼠标指针位于元素上方时，放松鼠标按钮就会触发该事件。 5.4 click当鼠标指针停留在元素上方，然后按下并松开鼠标左键时，就会发生一次 click 事件。注意：触发click事件的条件是按下并松开鼠标左键！，按下并松开鼠标右键并不会触发click事件。三个事件的触发顺序 5.5 总结若在同一个元素上按下并松开鼠标左键，会依次触发mousedown、mouseup、click，前一个事件执行完毕才会执行下一个事件若在同一个元素上按下并松开鼠标右键，会依次触发mousedown、mouseup，前一个事件执行完毕才会执行下一个事件，不会触发click事件","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"4 数组的循环v-for","slug":"Vue.js 2.0 手把手入门笔记/4 数组的循环v-for","date":"2019-05-15T06:10:04.000Z","updated":"2019-06-15T02:07:57.000Z","comments":true,"path":"2019/05/15/Vue.js 2.0 手把手入门笔记/4 数组的循环v-for/","link":"","permalink":"http://yoursite.com/2019/05/15/Vue.js 2.0 手把手入门笔记/4 数组的循环v-for/","excerpt":"","text":"vue 提供了一个v-for 解决循环问题 更高效 会复用原有结构 4.1 代码12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"content\"&gt; &lt;!--要循环谁就在谁身上增加v-for属性,类似于for...in..--&gt; &lt;!--默认是value of 数组/ (value,index) of 数组--&gt; &lt;li v-for=\"(todo,index) in todos\"&gt; &lt;!-- 会改变原始数组的方法，为变异方法 例如push(),pop()等； 非变异方法，不会改变原始数组，但是会返回一个新数组 --&gt; &#123;&#123; todo.text &#125;&#125; &#123;&#123;index+1&#125;&#125; &lt;/li&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;!-- 使用官网的vue地址 --&gt;&lt;script&gt; let vm = new Vue(&#123; el:'#content', data:&#123; todos: [ &#123; text: '学习 JavaScript' &#125;, &#123; text: '学习 Vue' &#125;, &#123; text: '整个牛项目' &#125; ] &#125; &#125;)&lt;/script&gt;&lt;/html&gt; v-for循环数组 当用for来更新已被渲染的元素时，vue的“就地复用”机制 是不会改变数据项的顺序的。要想重新排序，需为每项添加key属性（也就是每项唯一的id） 想要改变 会改变原始数组的方法，为变异方法 例如push(),pop()等； 非变异方法，不会改变原始数组，但是会返回一个新数组 4.2 为什么v-for一定要有key12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div&gt; &lt;input type=\"text\" v-model=\"name\"&gt; &lt;button @click=\"add\"&gt;添加&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;li v-for=\"(item, i) in list\"&gt; &lt;input type=\"checkbox\"&gt; &#123;&#123;item.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;!-- 使用官网的vue地址 --&gt;&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; name: '', newId: 3, list: [ &#123; id: 1, name: '蔬菜' &#125;, &#123; id: 2, name: '奶酪' &#125;, &#123; id: 3, name: '肉' &#125; ] &#125;, methods: &#123; add() &#123; //注意这里是unshift this.list.unshift(&#123; id: ++this.newId, name: this.name &#125;) this.name = '' &#125; &#125; &#125;); &lt;/script&gt; &lt;/div&gt;&lt;/html&gt; 当你输入汤时 就会变成这个样子 =&gt; 但是当你换成了key 可以简单的这样理解：加了key(一定要具有唯一性) id的checkbox跟内容进行了一个关联。是我们想达到的效果 vue和react的虚拟DOM的Diff算法大致相同，其核心是基于两个简单的假设首先讲一下diff算法的处理方法，对操作前后的dom树同一层的节点进行对比，一层一层对比，如下图： 当某一层有很多相同的节点时，也就是列表节点时，Diff算法的更新过程默认情况下也是遵循以上原则。比如一下这个情况：我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的： 即把C更新成F，D更新成C，E更新成D，最后再插入E，是不是很没有效率？所以我们需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。 vue中列表循环需加:key=”唯一标识” 唯一标识可以是item里面id index等，因为vue组件高度复用增加Key可以标识组件的唯一性，为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"3 数据响应的变化","slug":"Vue.js 2.0 手把手入门笔记/3 数据响应的变化","date":"2019-05-15T05:10:04.000Z","updated":"2019-06-15T02:08:01.000Z","comments":true,"path":"2019/05/15/Vue.js 2.0 手把手入门笔记/3 数据响应的变化/","link":"","permalink":"http://yoursite.com/2019/05/15/Vue.js 2.0 手把手入门笔记/3 数据响应的变化/","excerpt":"","text":"vue会循环data中的数据(数据劫持) 依次的增加getter和setter 123456let vm = new Vue(&#123; el:'#content', data:&#123; a:&#123;&#125; &#125;&#125;) 但是这时候我想添加一个school方法，发现没有产生getter和setter 1.1 方法一 $set 使用变量时 先要初始化，否则新加的属性不会导致页面刷新 1vm.$set(vm.a,\"school\",'1')// 此方法可以给对象添加响应式的变化 1.2 方法二 替换原对象1vm.a = &#123;\"school\":\"heihei\",age:8&#125;; 1.3 数组问题 去改变数组中的某一项监控不到的，也不能改变数组的长度方法 123456let vm = new Vue(&#123; el:'#content', data:&#123; a:[1,2,3,4,5,6] &#125;&#125;) 错误方法 12vm.a[0] =100vm.a.length -=2 变异方法:pop push shift unshit sort reserve splice 1vm.a = vm.a.map(item=&gt;item*3)","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"2 vue基础指令","slug":"Vue.js 2.0 手把手入门笔记/2 vue基础指令","date":"2019-05-15T04:10:04.000Z","updated":"2019-06-15T02:08:37.000Z","comments":true,"path":"2019/05/15/Vue.js 2.0 手把手入门笔记/2 vue基础指令/","link":"","permalink":"http://yoursite.com/2019/05/15/Vue.js 2.0 手把手入门笔记/2 vue基础指令/","excerpt":"","text":"2.1 安装vue cnd方式 npm 方式 2.2 简单的尝试 这里使用cnd方便测试 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"content\"&gt; &lt;!-- moustache 小胡子语法 表达式 可以放赋值 取值 三元--&gt; &#123;&#123; msg &#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; &lt;!-- 使用官网的vue地址 --&gt;&lt;script&gt; // 引用vue后会给一个vue构造函数 var vm = new Vue(&#123; // vm === viewModel el: '#content', // 告诉vue管理哪一部分,querySelector \"document.querySelector(\"#content\")\" data: &#123; // data中的数据会被vm所代理 msg: 'Hello Vue!' // 可以通过vm.msg获取对应的呢日用 &#125; &#125;)// Object.defineProperty vm.msg = \"wjw\" // 修改视图&lt;/script&gt;&lt;/html&gt; 2.3 模板语法 综上所属得出了一套模板语法 2.3.1 文本1&lt;span&gt;Message:&#123;&#123;msg&#125;&#125;&lt;/span&gt; 2.3.2 表达式123&#123;&#123;number + 1&#125;&#125;&#123;&#123;ok?&apos;YES&apos;:&apos;NO&apos;&#125;&#125;&#123;&#123;message.split(&apos;&apos;).reverse().join(&apos;&apos;)&#125;&#125; 但是vue的表单元素 input checkbox textarea radio select 非文本处理 vue的指令 directive 只是dom上的行间属性，vue给这类属性赋予了一些意义，来实现特殊功能所有指令都以v-开头value属性默认情况下回vue忽略掉 selected checked 都没有意义 #### 2.3.3表单输入 v-model 会将msg赋予输入框，输入框的值改变会影响数据 12&lt;input v-model=\"msg\"&gt;&lt;input type=\"checkbox\" v-model=\"msg1\" value=\"爬山\"&gt; 2.3.4 原始HTML1&lt;p&gt;Using mustache:&lt;span v-html='rawHtml'&gt;&lt;/spn&gt;&lt;/p&gt; 2.3.5 指令1&lt;p v-if='seen'&gt;现在看到我了&lt;/p&gt; 2.3.6 特性1&lt;div v-bind:id='dynamicld'&gt;&lt;/div&gt; 2.4 Object.defineProperty原理1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;input type=\"text\" id=\"input\"&gt;&lt;/body&gt; &lt;script&gt; let obj = &#123;&#125; let temp = &#123;&#125;; document.getElementById(\"content\").innerHTML = obj.name // 'name' 代表属性 Object.defineProperty(obj,'name',&#123; configurable:false, //是否可删除 // writable:true,// 是否可赋值(如果使用set方法,则不能使用) enumerable:true, // 是否可枚举,也是就for..in.. // value:1,// 值(如果使用get方法,则不能使用) get()&#123; // 取obj的name会触发get方法 return temp['name'] &#125;, set(val)&#123;// 给obj赋值会触发get方法 // console.log(val); temp['name'] = val // 改变temp的结果 input.value = val // 将值赋值给输入框 &#125; &#125;); input.value = obj.name // 页面一加载，会将调用get方法 input.addEventListener('input',function()&#123; // 等待输入框的变化 obj.name = this.value // 当值变化时会调用set方法 document.getElementById(\"content\").innerHTML = obj.name &#125;)&lt;/script&gt;&lt;/html&gt; 最后可以实现双向绑定的雏形","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"1 vue介绍","slug":"Vue.js 2.0 手把手入门笔记/1 vue介绍","date":"2019-05-15T03:10:04.000Z","updated":"2019-06-15T02:08:34.000Z","comments":true,"path":"2019/05/15/Vue.js 2.0 手把手入门笔记/1 vue介绍/","link":"","permalink":"http://yoursite.com/2019/05/15/Vue.js 2.0 手把手入门笔记/1 vue介绍/","excerpt":"","text":"1 介绍 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。 2 特点: 核心只关注视图层(view) 灵活、轻量、灵活的特点 适用于移动端项目 渐进式框架 3 什么是库，什么是框架？ 库是将代码集合成一个产品，库是我们调用库中的方法实现自己的功能 框架则是为解决一类问题而开发的产品，框架是我们在指定的位置编写代码，框架帮我们调用。 框架是库的升级版 4 渐进式 声明式渲染(无需关心如何实现) 组件系统 客户端路由(vue-router) 大规模状态管理(vuex) 构建工具(vue-cli) 5 Vue的两个核心点 响应的数据变化 当数据发生改变-&gt;视图的自动更新 组合的视图组件 ui页面映射为组件树 划分组件可维护、可复用、可测试###6 MVC(backbone,react) model 数据 view 视图 controller 控制器 7 MVVM(angular,vue) 双向 model 数据 view 视图 viewModel视图模型 8 Object.defineProperty(es5)没有替代方案 不支持ie8&lt;=","categories":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/categories/Vue基础入门笔记/"}],"tags":[{"name":"Vue基础入门笔记","slug":"Vue基础入门笔记","permalink":"http://yoursite.com/tags/Vue基础入门笔记/"}]},{"title":"14 z-index的特点","slug":"css入门/14 z-index的特点","date":"2019-04-30T10:19:05.000Z","updated":"2019-06-08T15:01:02.000Z","comments":true,"path":"2019/04/30/css入门/14 z-index的特点/","link":"","permalink":"http://yoursite.com/2019/04/30/css入门/14 z-index的特点/","excerpt":"","text":"默认是书写顺序在后的定位元素覆盖在顺序钱的定位元素 可以使用z-index属性修改定位元素的层级关系 所有定位元素的z-index默认都是一样的 z-index值是数字没有单位，支持负数 一般都是同级元素进行层级的比较 当参数是相对定位或绝对定位的时候，父级元素之间没有z-index值，子级元素的z-index值会出来比较。","categories":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/categories/css入门/"}],"tags":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/tags/css入门/"}]},{"title":"13 定位","slug":"css入门/13 定位","date":"2019-04-30T09:19:05.000Z","updated":"2019-06-08T15:01:03.000Z","comments":true,"path":"2019/04/30/css入门/13 定位/","link":"","permalink":"http://yoursite.com/2019/04/30/css入门/13 定位/","excerpt":"","text":"13 定位 13.1 绝对定位 position:absolute 脱离文档流 可以设置参照物，参照物必须是其父级元素(直系父级)，如果直接父级没有会一直往上查，直到找到最外层的根元素为止 有宽度和高度的情况下，top和bottom同时有值，top生效，left和right同时有值，left生效 没有段杜和高度的情况下，top和bottom同时设置值的情况下，会将在这个盒子拉大，上下值都起作用，左右同理。 13.2 相对定位 position:relative 不会脱离文档流 占位 所有后面的元素不会往前跑 可以设置上下左右四个方位 如果同时设置top和bottom同时有值，top生效 如果同时设置left和right同时有值，left生效 参照物自己本身 z-index 必须和定位元素(绝对，相对，固定)同时使用才起作用 13.3 固定定位 position:fixed 脱离文档流 参照物是浏览器的可视窗口 任何元素都可以设置固定定位 可以top/bottom/left/right四个方位 可以通过z-index改变层级 13.4 定位的不同点和不同点 13.4.1 相同点 可以top/bottom/left四个方位，如果同时有top，bottom只有top作用,如果同有left、right、只有left起作用 都设置z-index改变层级 而且z-index越大 越在上 13.4.2 不同点 是否脱离文档流 绝对定位:是 相对定位:否 固定定位:是 只有相对定位没有脱离文档流，绝对和固定定位都会脱离文档流 不占位 参照物 绝对定位:是觉有定位元素的父级元素，如果直接父级没有定位元素，则会往上级知道找到我们的根元素html为止 绝对定位元素 一定给他的直接父级元素相对参照物(postion:relative) 相对定位:它自己本身 固定定位:整个浏览器窗口","categories":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/categories/css入门/"}],"tags":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/tags/css入门/"}]},{"title":"12 文档流和脱离文档流","slug":"css入门/12 文档流和脱离文档流","date":"2019-04-30T08:19:05.000Z","updated":"2019-06-08T15:01:04.000Z","comments":true,"path":"2019/04/30/css入门/12 文档流和脱离文档流/","link":"","permalink":"http://yoursite.com/2019/04/30/css入门/12 文档流和脱离文档流/","excerpt":"","text":"12.1 介绍 文档流:指的是元素排版布局过程中，元素会自动从左到右，从上往下的流式排版。最终窗体自上而下分成一行行，并在每行中从左至右的顺序排放元素 每个非浮动块级元素都独占一行，浮动元素则按规定浮在行的一端。若当前行容不下则另起新行再浮动 内联元素也不会独占一行;几乎所有元素(包括块级，内联和列表元素)均可生成子行，用于摆放子元素 标准文档流等级:分为两个等级，块级元素和行内元素； 脱离文档流：文档流内的正常元素识别不到这个元素(脱离文档的元素相当于平行漂浮在文档流之上) 正常的文档流:从左往右 从上往下文档流可以分等级:行内元素和会计元素行内元素 从左往右块级元素 从上往下 12.2 面试题:行内元素和块级元素的特点，请列举出标签？需求:需要块级元素(比如:div)在一行显示脱离文档流:元素的正常排列方式被打破 脱离文档流的影响: float 定位 12.3 浮动参数的影响或负作用 设置背景颜色属性不起作用 给父元素设置边框border属性没有被撑开 给父元素设置内边距padding属性也没有被撑开 12.4 如何清浮动 给浮动元素的父元素手动添加一个固定的高度(不推荐) 给浮动元素的父元素设置overflow:hidden/auto 给浮动元素的父元素结束标签之前加一个具有元素特点的标签(我们一般用div)，给元素clear:both clearFix伪元素去清楚浮动 (这种方法是项目中最常用的方法) 利用伪元素:after清浮动的固定代码；只要清浮动我们在浮动元素的父元素上加一个.clearfix即可 12.5 让元素消失在我们的视野中 透明度opacity:0; [0~1] display:node 隐藏 height:0和overflow:hidden line-height:0和overflow:hidden(没有设置高度的情况下) visbility:hidden;让所有可见性的元素隐藏 margin/padding设置足够大 只要能让他消失 利用transform 属性 让transform坐标足够大","categories":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/categories/css入门/"}],"tags":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/tags/css入门/"}]},{"title":"11 浮动元素的特点","slug":"css入门/11 浮动元素的特点","date":"2019-04-30T07:19:05.000Z","updated":"2019-06-08T15:01:04.000Z","comments":true,"path":"2019/04/30/css入门/11 浮动元素的特点/","link":"","permalink":"http://yoursite.com/2019/04/30/css入门/11 浮动元素的特点/","excerpt":"","text":"11.1 float元素的特点 浮动元素在一行显示 设置属性值为left时，浮动元素会依次从父级盒子的左侧向右排布，设置属性值为right时，浮动元素会依次从父级盒子的右侧想左排布 浮动元素自动其有块级元素的属性 浮动元素脱离文档流 浮动元素内的子元素，不会继承浮动属性 浮动元素下面的元素不能识别浮动元素的高度和位置,所以不许display:block了","categories":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/categories/css入门/"}],"tags":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/tags/css入门/"}]},{"title":"10 文本省略号","slug":"css入门/10 文本省略号","date":"2019-04-30T06:19:05.000Z","updated":"2019-06-08T15:01:05.000Z","comments":true,"path":"2019/04/30/css入门/10 文本省略号/","link":"","permalink":"http://yoursite.com/2019/04/30/css入门/10 文本省略号/","excerpt":"","text":"10.1 单行文本出现省略号必备的条件（面试题）12345678910111213*&#123; margin:0; padding:0;&#125;h2:&#123; width:600px; height:30px; /*单行文本出现省略好必备的条件*/ overflow:hidden;/*溢出隐藏*/ white-space:nowrap;/*强制文字不折行*/ text-overflow:ellipsis;/*文字隐藏的方式:以省略号的方式隐藏*/&#125; 10.2 多行文本出现省略号必备的条件（面试题）1234567h2&#123; width:600px;/*宽度*/ display:-webkit-box;/*弹性盒子模型*/ -webkit-line-orient:vertical;/*规定元素的排行方式:垂直排序*/ -webkit-line-clamp:2;/*文字的行数 需要显示几行 值就写几行*/ overflow:hidden;/*溢出隐藏*/&#125;","categories":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/categories/css入门/"}],"tags":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/tags/css入门/"}]},{"title":"9 让多个元素的一行显示的方法","slug":"css入门/9 让多个元素的一行显示的方法","date":"2019-04-30T05:19:05.000Z","updated":"2019-06-08T15:01:06.000Z","comments":true,"path":"2019/04/30/css入门/9 让多个元素的一行显示的方法/","link":"","permalink":"http://yoursite.com/2019/04/30/css入门/9 让多个元素的一行显示的方法/","excerpt":"","text":"9.1 让多个元素的一行显示的方法 display:inline; // 转换为行内元素 但是设置宽高属性之后不起作用 display:inline-block; // block可以让元素在一行显示，但是他会受空格/换行建，会产生默认间距 去掉空格和换行建的影响 让标签都在一行 (不推荐 阅读性不好) 给父元素增加一个 font-size:0，然后给子元素增加一个 font-size:14px;（但是我们还会发现一个问题:元素里面如果有文字 文字消失，然后在子元素增加一个属性即可） float:left/rigjt; // 但是我们清浮动 ** [display:inline-block元素的特点]** 让盒子横向排列 vertiacal-align 属性会影响到inline-block元素，你可能会把他的值设置为top 你需要设置每一列的宽度 如果html源代码中元素之间有空格，那么列与列之间会产生空隙 1234567891011121314151617181920212223*&#123; margin:0px; padding:0px;&#125;.content1&#123; display:inline; width:200px; height:100px; backgournd-color:yellow;&#125;.content2&#123; display:inline; width:200px; height:100px; backgournd-color:yellow;&#125;...&lt;div class=\"content1\"&gt;内容1&lt;/div&gt;&lt;div class=\"content2\"&gt;内容2&lt;/div&gt; inline-block 在ie7 不兼容 直接让块元素设置为内联对象呈递（设置属性display:inline），然后触发块元素的layout（如：zoom:1 或float属性等）。代码如下 12345678910111213/*推荐:IE6、7*/ div &#123; display:inline-block; *zoom:1; *display: inline;&#125;/*推荐*/div &#123; display:inline-block; _zoom:1; _display:inline;&#125; 解释: display:inline-block照顾的是ie8+的浏览器，这是正常的设置，在低版本的ie设置下行内块有2个条件，一个行内，一个设置宽高，触发layout即可设置宽度，而div设置了宽度后还是会黄航，layout不是为了水平而设置，所以为了块级元素转行内块上加上”display:inline”属性，但是display:inline不会触发layout，于是加上zoom:1重新触发layout，于是形成了一个跨域设置宽高的行内元素","categories":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/categories/css入门/"}],"tags":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/tags/css入门/"}]},{"title":"8 voerflow:hidden","slug":"css入门/8 voerflow_hidden","date":"2019-04-30T03:19:05.000Z","updated":"2019-06-08T15:01:07.000Z","comments":true,"path":"2019/04/30/css入门/8 voerflow_hidden/","link":"","permalink":"http://yoursite.com/2019/04/30/css入门/8 voerflow_hidden/","excerpt":"","text":"8.1 overflow溢出隐藏 超过内容之外的部分给隐藏起来 12345678p&#123; width:300px; height:10px; overfolw:hidden;&#125;...&lt;p&gt;xxxxxxxxxxxxxxxxxxxxxxxx......xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.....&lt;/p&gt; 用来清楚浮动产生的影响 解决margin-top的传递问题","categories":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/categories/css入门/"}],"tags":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/tags/css入门/"}]},{"title":"7 背景相关","slug":"css入门/7 背景相关","date":"2019-04-29T10:19:05.000Z","updated":"2019-06-08T15:01:07.000Z","comments":true,"path":"2019/04/29/css入门/7 背景相关/","link":"","permalink":"http://yoursite.com/2019/04/29/css入门/7 背景相关/","excerpt":"","text":"7.1 背景属性背景缩写缩写可以卸载一个声明中设置所有的背景属性背景图像支持引入多个图像主要属性有:background-colorbackground-imagebackground-repeatbackground-positionbackgournd-attchmentbackgournd-sizebackgournd-originbackgournd-clip 7.2 背景颜色 background-color 指定要使用的背景颜色 例如:background-color:#ffcc00 可以简写为background backround-color 不能继承，其默认值是trandsparent。trandsparent有透明之意。也就是说，如果一个元素没有指定背景色，那么背景就是透明的，这样其祖先元素的背景才能可见。 transparent 指定背景颜色应该是透明的，默认值。 inherit 指定背景颜色，应该从父元素继承 1234567891011121314151617&lt;style&gt;.box&#123; width:650px; height:32px; background-color:orange;// 颜色 color:#fff; // 字体颜色 text-aligh:center;//字体内容水平居中&#125;div&#123; width:200px; height:200px; backgournd-color:darkbule; margin:0 auto;//上下0 左右auto 块元素水平居中 line-height:200px;//垂直居中&#125;&lt;/style&gt; 7.3 背景图片 background-image url(‘图像的url路径地址’)图像的url none 表示北京上没有防止任何图像，这就是默认值 inherit指定背景图像应该从父元素继承 一个元素可以引入多张背景图片，指定要使用的一个或者多个背景图像，默认情况下background-image放置在元素的左上角，并重复垂直的水平方向。 backgournd image:url(‘pic.png’),url(‘pic2.png’)… … backgournd image 属性不能继承 7.4 背景重复 指定如何重复背景图像，默认情况下，重复background-image的垂直和水平方向 repeat 背景图像向垂直和水平方向垂直。这是默认 repeat-x 只有水平位置会重复背景图像 repeat-y 只有垂直位置会重复背景图像 no-repeat background-image不会重复 inherit 指定背景重复应该从父元素继承 123456.logo&#123; width:300px; height:300px; backgournd-image:url('../xxx/png'); backgournd-repeat:repeat x;//平铺的方式（重复）&#125; 7.5 背景定位 backgournd-position属性设置背景图像的起始位置; xpos ypos 第一个值的水平位置，第二个值是垂直。左上角是0。单位可以是长度值px，关键字和百分数值 关键字成对出现left right top bottom center，如果仅指定一个关键字，其他值将会“center” x% y%第一个值水平位置，第二值是垂直。左上角是0%0%。 inherit 指定background-position属性设置应该从父元素继承 12345678910.logo&#123; width:400px; height:400px; backgournd-color:#3385ff;//背景颜色 backgournd-image:url('./xxx.png'); backgournd-repeat:no-repeat; backgournd-position:50px 50px;//x轴的坐标(水平方向)y轴的坐标方向(垂直方向) x轴越大 越往右 x轴越大 越往下 //50% 50% &gt; center center //中心位置&#125; 经常使用在雪碧图中 7.6 背景关联 backgournd-attachmen 设置背景图像是否固定或者随着页面的其余部分滚动 scroll 背景图片随页面的其余部分滚动。这是默认 fixed 背景图像是固定的 inherit 指定background-attachment的设置应该从父元素继承 12345678910111213141516171819202122232425*&#123; padding:0px; margin:0px;&#125;.banner&#123; width:100%; height:800px; backgournd:url(../xxx.png) no-repeat&#125;.banner01&#123; width:100%; height:800px; backgournd:url(../xxx.png) no-repeat&#125;.banner02&#123; width:100%; height:800px; backgournd:url(../xxx.png) no-repeat backgournd-attachmen:fixed;// 可以固定不动&#125; 7.7 设置对象的背景图像的尺寸大小 background-size 用长度值指定背景图像大小。不允许负值； 用百分比指定背景图像大小。不允许负值。 auto背景图像的真实大小 cover将背景图等比例缩放到完全覆盖容器，背景图像有可能超出容器； contain将背景图像等比例缩放到宽度或高度与容器的宽度或高度相等，背景图像始终被包含在容器内 123456.pic&#123; width:200px; height:1600px; background:url('../xx.png') background-size:300px 300px; // x轴 y轴&#125; 7.8 设置对象的背景图像向外裁剪的区域 background-clip padding-box:从padding区域(不含padding)开始想外裁剪背景; border-box:从border区域(不含border)开始向外裁剪背景 bontent-box:从content区域开始向外裁剪背景 text:从前景内容的形状（比如文字）作为裁剪区域向外裁剪，如此极客实现使用背景作为填充色之类的遮罩效果。 1234567.pic&#123; width:200px; height:1600px; background:url('../xx.png') background-size:300px 300px; // x轴 y轴 backgound-clip:border-box;&#125; 7.9 设置背景图像的参考原点(位置) background-orign padding-box:从padding区域(含padding)开始显示背景图像 border-box:从border区域(含border)开始显示背景图像 content-box:从content区域开始显示背景图像","categories":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/categories/css入门/"}],"tags":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/tags/css入门/"}]},{"title":"6 BFC机制","slug":"css入门/6 BFC机制","date":"2019-04-29T09:19:05.000Z","updated":"2019-06-08T15:01:08.000Z","comments":true,"path":"2019/04/29/css入门/6 BFC机制/","link":"","permalink":"http://yoursite.com/2019/04/29/css入门/6 BFC机制/","excerpt":"","text":"BFC全称是Block Formatting Context，即块格式化上下文。它是CSS2.1规范定义的，关于CSS渲染定位的一个概念。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 6.1 BFC布局规则 内部的Box会在垂直方向，一个接一个地放置； Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠； 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。； BFC的区域不会与float box重叠，常用来清除浮动和布局。； BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。； 计算BFC的高度时，浮动元素也参与计算；6.2 会生成BFC的元素 根元素或其它包含它的元素； 浮动 (元素的float不为none)； 绝对定位元素 (元素的position为absolute或fixed)； 行内块inline-blocks(元素的 display: inline-block)； 表格单元格(元素的display: table-cell，HTML表格单元格默认属性)； overflow的值不为visible的元素； 弹性盒 flex boxes (元素的display: flex或inline-flex)；6.3 BFC的范围BFC的范围在MDN中是这样描述的。 A block formatting context contains everything inside of the element creating it that is not also inside a descendant element that creates a new block formatting context. 中文的意思一个BFC包含创建该上下文元素的所有子元素，但不包括创建了新BFC的子元素的内部元素。插入一段代码方便理解 12345678910&lt;div class='div_1 BFC'&gt; &lt;div class='div_2'&gt; &lt;div class='div_3'&gt;&lt;/div&gt; &lt;div class='div_4'&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class='div_5 BFC'&gt; &lt;div class='div_6'&gt;&lt;/div&gt; &lt;div class='div_7'&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; div_1创建了一个块格式上下文，这个上下文包括了div_2、div_3、div_4、div_5。即div_2中的子元素也属于div_1所创建的BFC。但由于div_5创建了新的BFC，所以div_6和div_7就被排除在外层的BFC之外。这就代表着一个元素不能同时存在于多个BFC中。BFC的一个最重要的效果是，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。这是利用BFC清除浮动所利用的特性。 6.4 BFC的常用方式： 6.4.1 子级浮动导致父级高度塌陷1234567891011121314151617181920212223242526272829&lt;style type=\"text/css\"&gt; .box&#123; width: 900px; background: black; height: 300px; // 增加高度 &#125; .box1&#123; height: 300px; width: 300px; background: red; float: left; &#125; .box2&#123; height: 300px; width: 300px; background: blue; float: left; &#125; &lt;/style&gt;......&lt;div class=\"box\"&gt; &lt;div class=\"box1\"&gt;&lt;/div&gt; &lt;div class=\"box2\"&gt;&lt;/div&gt;&lt;/div&gt; 上面的代码定义了3个块，一个父级包含了两个子集，但是父级的背景颜色无法显示，是因为子集元素浮动导致了父级高度的塌陷。在为box设置BFC后，box的高度才能找回来。从而显示出正确的样式。 #### 6.4.2 子级margin-top将父级带下 为父级触发BFC一个盒子有上边距 另一个有下边距 会出现margin边距的重叠问题并列盒子的margin重写=&gt;双margin的重叠-&gt; 取大值 并不是他们相加之和 也就是谁大听谁的 要将黑色块中的小红块下移一点，直接使用了margin-top，结果黑块一起下移了。 123456789101112131415161718192021&lt;style type=\"text/css\"&gt; .box&#123; width: 300px; height: 300px; background: black; &#125; .box1&#123; height: 100px; width: 100px; background: red; margin-top: 50px; &#125; &lt;/style&gt;......&lt;div class=\"box\"&gt; &lt;div class=\"box1\"&gt;&lt;/div&gt;&lt;/div&gt; 而设置了BFC后，就能正确的下浮红色块 margin的兼容问题:margin top的传递问题 大盒子里面嵌套小盒子 给小盒子加margin-top 不但没有实现和大盒子之间的间距 反而传递给大盒子身上 导致整体下移动解决兼容性问题 overflow:hidden 解决margin-top的传递问题(此处并没有溢出隐藏) padding-方位:1px 这种方法影响最后实际宽高 需要在width/height上基础上减掉才不会影响最后实际的宽高 border-top:1px 这种方法会影响最后实际的高度 需要在高度height上基础上减掉 才不会影响最后实际的高度 给子元素的margin-top的值改成父元素的padding-top,这样就避免使用margin-top值导致传递的问题","categories":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/categories/css入门/"}],"tags":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/tags/css入门/"}]},{"title":"5 css盒子模型","slug":"css入门/5 css盒子模型","date":"2019-04-29T08:19:05.000Z","updated":"2019-06-08T15:01:09.000Z","comments":true,"path":"2019/04/29/css入门/5 css盒子模型/","link":"","permalink":"http://yoursite.com/2019/04/29/css入门/5 css盒子模型/","excerpt":"","text":"5.1 css盒子模型图解 margin:外边距 border:边框 padding:内边距 5.2 css盒子模型之宽度和高度 px 像素写死 2. % 动态计算的单位(自适应 响应式) 1234567*&#123; margin:0; padding:0;&#125;.banner img&#123; width:100%;&#125; 5.3 内边距padding及简写 5.4 边框线border的使用技巧 border:边框的宽度 边框线类型 边框线的颜色 5.4.1 边框线类型 5.4.2 边框线类型 solid 实线 dashed 虚线 dotted 点状线 5.4.3 边框线的颜色 黑色 白色 颜色的英文 black white # #000 #fff rgb rgb(0,0,0) rgb(255,255,255) border:10px solid #000如果没有知名方向的情况下，表示四个方向都相等border-top 上边border-right 右边border-bottom 下边border-left 左边 5.4.4 去掉边框border:0如果border属性只有边框段杜，没有边框的类型和颜色 导致border属性失效 5.4.5 面试题(画个三角形) 1234567891011121314151617181920212223 /* 三角箭头原理：正方形的任意相邻的两条边线 然后旋转一定的角度得到我们需要的任意方向的箭头 deg 角度单位 rotate旋转角度 三角形的大小由正方形的宽高去控制 三角形的粗细是有边框线去控制 三角形的颜色是有边框线的颜色去控制 */&lt;div class=\"arrow\"&gt;&lt;/div&gt;&lt;style&gt;.arrow&#123; width: 0px; height: 0px; margin-top: 50px; margin-left: 50px; border-width:0 30px 30px; border-style:solid; border-color:transparent transparent #333; transform: rotate(90deg);//控制角度&#125;&lt;/style&gt; 5.5 padding 方向上和padding一致 5.6 margin的负值使用技巧结构上不动，可以调换div顺序 5.7 padding和margin的区别padding 是内边距会影响我们在浏览器中看到的元素的实际大小内边距会让元素的内容增大和其它的元素没有关系margin 是外边距不会影响我们在浏览器中看到的元素的实际大小外边距不会让元素的内容增大和另一个元素的间距 5.8 盒子模型的计算公式及使用技巧 元素实际宽度 宽度width + padding-left/padding-right+border-left/border-right 元素实际高度 高度height+padding-top/padding-bottom+border-top/border-bottom 口号: 元素的实际大小智慧padding和border的影响跟margin没有半毛钱的关系如果加了padding和border的值要在width和height的值上减去padding和border的值 否则内容会溢出","categories":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/categories/css入门/"}],"tags":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/tags/css入门/"}]},{"title":"4 CSS的三大特性 (继承属性)","slug":"css入门/4 CSS的三大特性 (继承属性)","date":"2019-04-29T07:19:05.000Z","updated":"2019-06-08T15:01:10.000Z","comments":true,"path":"2019/04/29/css入门/4 CSS的三大特性 (继承属性)/","link":"","permalink":"http://yoursite.com/2019/04/29/css入门/4 CSS的三大特性 (继承属性)/","excerpt":"","text":"4.2 无继承性的属性 4.2.1 display inline block inline-block table-cell none 规定元素应该生成的框的类型 4.2.2 文本属性：vertical-align：垂直文本对齐text-decoration：规定添加到文本的装饰text-shadow：文本阴影效果white-space：空白符的处理unicode-bidi：设置文本的方向 4.3.3 盒子模型的属性：width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left 4.3.4 背景属性background、background-color、background-image、background-repeat、background-position、background-attachment 4.3.5 定位属性float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index 4.3.6 生成内容属性content、counter-reset、counter-increment 4.3.7 轮廓样式属性outline-style、outline-width、outline-color、outline 4.3.8 页面样式属性size、page-break-before、page-break-after 4.3.9 声音样式属性pause-before、pause-after、pause、cue-before、cue-after、cue、play-during 4.3 有继承性的属性 4.3.1 字体系列属性font：组合字体font-family：规定元素的字体系列font-weight：设置字体的粗细font-size：设置字体的尺寸font-style：定义字体的风格font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。font-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。font-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。 4.3.2 文本系列属性text-indent：文本缩进text-align：文本水平对齐line-height：行高word-spacing：增加或减少单词间的空白（即字间隔）letter-spacing：增加或减少字符间的空白（字符间距）text-transform：控制文本大小写direction：规定文本的书写方向color：文本颜色 4.3.3 元素可见性visibility 4.3.4 表格布局属性caption-side、border-collapse、border-spacing、empty-cells、table-layout 4.3.5 列表布局属性list-style-type、list-style-image、list-style-position、list-style 4.3.6 生成内容属性quotes 4.3.7 光标属性cursor 4.3.8 页面样式属性：page、page-break-inside、windows、orphans 4.3.9 声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、pitch、pitch-range、stress、richness、、azimuth、elevation 4.4 所有元素可以继承的属性1、元素可见性：visibility2、光标属性：cursor 4.5 内联元素可以继承的属性1、字体系列属性2、除text-indent、text-align之外的文本系列属性 4.6 块级元素可以继承的属性1、text-indent、text-align","categories":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/categories/css入门/"}],"tags":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/tags/css入门/"}]},{"title":"3 CSS的三大特性（重叠性+优先级）","slug":"css入门/3 CSS的三大特性（重叠性+优先级）","date":"2019-04-29T05:19:05.000Z","updated":"2019-06-08T15:01:11.000Z","comments":true,"path":"2019/04/29/css入门/3 CSS的三大特性（重叠性+优先级）/","link":"","permalink":"http://yoursite.com/2019/04/29/css入门/3 CSS的三大特性（重叠性+优先级）/","excerpt":"","text":"3.1 层叠性浏览器解析CSS是从上至下，当CSS冲突时以最后定义的CSS为准。层叠性是指多种CSS样式的叠加。例如，当使用内嵌式CSS样式表定义标记字号大小为12像素，链入式定义标记颜色为红色，那么段落文本将显示为12像素红色，即这两种样式产生了叠加 3.2 优先级 优先级顺序为：!important&gt;style&gt;权重值 权重记忆口诀:从0开始，一行内样式+1000，一个id+100，一个属性选择器/class或者一个元素名+10，或者伪元素+1 规则:相同的权重:以后面出现的选择器为最后规则 不同的权重，权重值生效 3.1.1 基本选择器 类型 权重 标签选择器/div 1 class/类选择器 .right 10 id 100 内联 1000 * 0-1 后代 子代 交集 并集 相邻兄弟 兄弟 属性 伪类 伪元素 权重:每个单独的选择器的权重相加之和 123456789.header ul li&#123; /* 权重 12 : 10+1+1 */ backgournd:red;&#125;.header .right li&#123; /* 权重 21:10+10+1 */ backgournd:#000;&#125; 权重相等的情况下比较 id&gt;class&gt;标签&gt;* 权重不相等的情况下: 谁的权重大，听谁的 权重相等的情况下:遵循就近原则，下面的覆盖上面的 权重相等,不遵循就近原则,就想听上面的怎么办 !important 1000 3.2.1 权重算法第一等：代表内联样式，如: style=””，权值为1000。第二等：代表ID选择器，如：#content，权值为0100。第三等：代表类，伪类和属性选择器，如.content，权值为0010。第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。通配符、子选择器、相邻选择器等的。如*、&gt;、+,权值为0000。继承的样式没有权值。优先级从高到低：行内选择符、ID选择符、类别选择符、元素选择符。 !important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性important &gt; 内联 &gt; ID &gt; 伪类|类 | 属性选择 &gt; 标签 &gt; 伪对象 &gt; 通配符 &gt; 继承","categories":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/categories/css入门/"}],"tags":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/tags/css入门/"}]},{"title":"2 选择器的世界","slug":"css入门/2 选择器的世界","date":"2019-04-29T03:19:05.000Z","updated":"2019-06-08T15:01:33.000Z","comments":true,"path":"2019/04/29/css入门/2 选择器的世界/","link":"","permalink":"http://yoursite.com/2019/04/29/css入门/2 选择器的世界/","excerpt":"","text":"2.1 基本选择器2.1.1 标签选择器 直接使用元素标签进行选择 p{color:red;} 权重1 2.1.2 类选择器 通过元素的类名，来选择元素，一个元素可以有多个类名，都代表这个元素类名是元素class属性中的属性值，例如 .sum{} =&gt; 此选择器的权重为10 2.1.3 id选择器 通过元素的id名，来选择元素，类名是元素id属性中的属性值，例如 #sum{} =&gt; 此选择器的权重为100 2.1.4 通配符选择器 通过*选择全部元素，包括根元素 *{} =&gt; 权重小于1，可以被覆盖 2.2 并集选择器你可以对选择器进行分组，这样，被分组的选择器就可以分享想相同的声明。用逗号被需要分组的选择器分开。在下面的例子中，我们对所有的标题元素进行了分组。所有的标题元素都是绿色的。 123h1,h2,h3,h4,h5,h6&#123; color:green;&#125; 2.3 交集选择器两种属性同属一个元素的时候，我们可以使用交集选择器来进行元素的准确选择 1234&lt;p class=&apos;name1 name2&apos; id=&apos;id1&apos;&gt;&lt;/p&gt;p.name1&#123;&#125;p#id1&#123;&#125;.name1.name2&#123;&#125; 2.4 派生(后代)选择器 通过依据元素在其位置的上下文关系来定义样式，你可以使标记更加简洁，用空格隔开列表中的strong元素变为斜体字，而不是通常的粗体字，可以这样定义一个派生选择器 后台选择器尽量不要超过3个，没有必要把每一个层级都写出来，只需要写出关键节点极客 12345678910li strong&#123; font-style:italic; font-weight:normal;&#125;&lt;ol&gt; &lt;li&gt; &lt;strong&gt;我是斜体字。这个因为strong元素位于li元素内。&lt;/stong&gt; &lt;/li&gt;&lt;/ol&gt; 2.5 子代选择器 与后代选择器相比，子元素选择器只有选择作为某元素子元素，符号为大括号 123h1 &gt; strong &#123;color:red;&#125;&lt;h1&gt;This is&lt;strong&gt;very&lt;/strong&gt; important.&lt;/h1&gt; 2.6 相邻兄弟选择器 相邻兄弟选择器可选择紧接在另一元素后的元素，且二者有相同父元素 123h1+p&#123; margin-top:50px;&#125; 2.7 属性选择器 对带有指定属性的html元素设置样式 权重10 可以为拥有指定html元素设置样式，而不仅限于class和id属性 下面的例子为title属性的所有元素设置样式 1[title]&#123;color:red;&#125; 属性和值选择器下面的例子为title=’wjw’的所有元素设置样式 1[title=wjw]&#123;color:red;&#125; 设置表单的样式 1input[type=&apos;text&apos;]&#123;width:150px;display:block;background:yellow&#125; 2.8 伪装选择器 a:link{color:#ff000} // 未访问的链接 a:visited{color::#ff000} // 已访问的链接 a:hover{color:#ff000} // 鼠标移动到链接上 a:active{color:#ff000} //选定的链接 10&lt;权重&lt;11 选择器 示例 示例描述 CSS版本 .class .demo 选择 class=”demo” 的所有元素 1 #id #firstname 选择 id=”firstname” 的所有元素 1 * * 选择所有元素 2 element p 选择所有 元素 1 element,element div,p 选择所有 元素和所有 元素 1 element element div p 选择 元素内部的所有 元素 1 element&gt;element div&gt;p 选择父元素为 元素的所有 元素 2 element+element div+p 选择紧接在 元素之后的所有 元素 2 [attribute] [target] 选择带有 target 属性所有元素 2 [attribute=value] [target=_blank] 选择 target=”_blank” 的所有元素 2 [attribute~=value] [title~=flower] 选择 title 属性包含单词 “flower” 的所有元素 2 [[attribute =value]](https://www.html.cn/book/css/selectors/attribute/att7.htm) [lang&#124;=en] 选择 lang 属性值以 “en” 开头的所有元素 :link a:link 选择所有未被访问的链接 1 :visited a:visited 选择所有已被访问的链接 1 :active a:active 选择活动链接 1 :hover a:hover 选择鼠标指针位于其上的链接 1 :focus input:focus 选择获得焦点的 input 元素 2 :first-letter p:first-letter 选择每个 元素的首字母 1 :first-line p:first-line 选择每个 元素的首行 1 :first-child p:first-child 选择属于父元素的第一个子元素的每个 元素 2 :before p:before 在每个 元素的内容之前插入内容 2 :after p:after 在每个 元素的内容之后插入内容 2 :lang(language) p:lang(it) 选择带有以 “it” 开头的 lang 属性值的每个 元素 2 element1~element2 p~ul 选择前面有 元素的每个 元素 3 [attribute^=value] a[src^=”https”] 选择其 src 属性值以 “https” 开头的每个 元素 3 [attribute$=value] a[src$=”.pdf”] 选择其 src 属性以 “.pdf” 结尾的所有 元素 3 [attribute*=value] a[src*=”abc”] 选择其 src 属性中包含 “abc” 子串的每个 元素 3 :first-of-type p:first-of-type 选择属于其父元素的首个 元素的每个 元素 3 :last-of-type p:last-of-type 选择属于其父元素的最后 元素的每个 元素 3 :only-of-type p:only-of-type 选择属于其父元素唯一的 元素的每个 元素 3 :only-child p:only-child 选择属于其父元素的唯一子元素的每个 元素 3 :nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 元素 3 :nth-last-child(n) p:nth-last-child(2) 同上，从最后一个子元素开始计数 3 :nth-of-type(n) p:nth-of-type(2) 选择属于其父元素第二个 元素的每个 元素 3 :nth-last-of-type(n) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数 3 :last-child p:last-child 选择属于其父元素最后一个子元素每个 元素 3 :root :root 选择文档的根元素 3 :empty p:empty 选择没有子元素的每个 元素（包括文本节点） 3 :target #news:target 选择当前活动的 #news 元素 3 :enabled input:enabled 选择每个启用的 元素 3 :disabled input:disabled 选择每个禁用的 元素 3 :checked input:checked 选择每个被选中的 元素 3 :not(selector) :not(p) 选择非 元素的每个元素 3 ::selection ::selection 选择被用户选取的元素部分 3 :out-of-range :out-of-range 匹配值在指定区间之外的input元素 3 :in-range :in-range 匹配值在指定区间之内的input元素 3 :read-write :read-write 用于匹配可读及可写的元素 3 :read-only :read-only 用于匹配设置 “readonly”（只读） 属性的元素 3 :optional :optional 用于匹配可选的输入元素 3 :required :required 用于匹配设置了 “required” 属性的元素 3 :valid :valid 用于匹配输入值为合法的元素 3 :invalid :invalid 用于匹配输入值为非法的元素 3","categories":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/categories/css入门/"}],"tags":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/tags/css入门/"}]},{"title":"1 css引入与规范","slug":"css入门/1 css引入与规范","date":"2019-04-28T10:19:05.000Z","updated":"2019-06-08T14:57:33.000Z","comments":true,"path":"2019/04/28/css入门/1 css引入与规范/","link":"","permalink":"http://yoursite.com/2019/04/28/css入门/1 css引入与规范/","excerpt":"","text":"1.1 导入式导入式会在整个网页装载完后再装载CSS文件，因此这就导致了一个问题，如果网页比较大则会儿出现先显示无样式的页面，闪烁一下之后，再出现网页的样式。这是导入式固有的一个缺陷。 123&lt;style type=\"text/css\" media=\"screen\"&gt; @import url(\"CSS文件\"); &lt;/style&gt; ### 1.2 外链式 引入一个外部的css样式表语言:link标签 href=\"css样式路径名称\" 可以放在head标签或者body标签里面 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"index.css\"&gt; 1.3 外链式和导入式的区别 link和@import虽然都是引入外部的css文件，但是他们是有天差地别的区别的 link是html标签，@import完全是css提供的方式，要写在css文件或者style标签中。 他们的加载顺序也是有区别的，当一个页面被加载的时间，link引用的css文件会被同时加载，而@import引入的css文件会等页面全部下载完后再加载。 当使用JavaScript控制DOM去改变css样式的时间，只能使用link标签，因为import是不能被DOM控制的 1.4 行内式 通过style这个标签属性，将css键值对直接写入标签内 1&lt;p style=\"width:100px;height:100px;background-color:red;\"&lt;/p&gt; 1.5 内嵌式可以放在head或者body里 建议放在head标签里面title标签的下面 1234567&lt;style type=\"text/css\"&gt; 选择器&#123; 声明; 声明; .... &#125;&lt;/style&gt; 1.6 css的代码规范 必须使用英文开头，硬切开头字母一律小写 所有的命名最好都小写 尽量不要用缩写英文，除非可以一目了然的 如果遇到相差不大class或者id，主功能识别字母在钱，位置识别字母在后，位置识别字母第一个可大写（如：navTop，menuLeft） 遵循驼峰命名法:第一个单词的首字母小写，其余每一个有意义的单词的首字母大写(如:studentInfo、getElementById)","categories":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/categories/css入门/"}],"tags":[{"name":"css入门","slug":"css入门","permalink":"http://yoursite.com/tags/css入门/"}]},{"title":"7 服务器","slug":"前端优化方案/7 服务器","date":"2019-04-15T10:10:04.000Z","updated":"2019-06-08T15:10:33.000Z","comments":true,"path":"2019/04/15/前端优化方案/7 服务器/","link":"","permalink":"http://yoursite.com/2019/04/15/前端优化方案/7 服务器/","excerpt":"","text":"7.1 Gzip组件 前端工程师可以想办法明显地缩短通过网络传输HTTP请求和响应的时间。毫无疑问，终端用户的带宽速度，网络服务商，对等交换点的距离等等，都是开发团队所无法控制的。但还有别的能够影响响应时间的因素，压缩可以通过减少HTTP响应的大小来缩短响应时间。从HTTP/1.1开始，web客户端就有了支持压缩的Accept-Encoding HTTP请求头。 1 Accept-Encoding: gzip, deflate 如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过Content-Encoding相应头来通知客户端。 1 Content-Encoding: gzip 尽可能多地用gzip压缩能够给页面减肥，这也是提升用户体验最简单的方法。 7.2 避免图片src属性为空Image with empty string src属性是空字符串的图片很常见，主要以两种形式出现： straight HTML JavaScript var img = new Image();img.src = “”; 这两种形式都会引起相同的问题：浏览器会向服务器发送另一个请求。 7.3 配置ETags 实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器中的组件是否匹配的一种机制（“实体”也就是组件：图片，脚本，样式表等等）。添加ETags可以提供一种实体验证机制，比最后修改日期更加灵活。一个ETag是一个字符串，作为一个组件某一具体版本的唯一标识符。唯一的格式约束是字符串必须用引号括起来，源服务器用相应头中的ETag来指定组件的ETag： 1234 HTTP/1.1 200 OK``Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT``ETag: &quot;10c24bc-4ab-457e1c1f&quot;``Content-Length: 12195 然后，如果浏览器必须验证一个组件，它用If-None-Match请求头来把ETag传回源服务器。如果ETags匹配成功，会返回一个304状态码，这样就减少了12195个字节的响应体。GET /i/yahoo.gif HTTP/1.1 Host: us.yimg.com If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT If-None-Match: “10c24bc-4ab-457e1c1f” HTTP/1.1 304 Not Modified** ** 7.4 对Ajax用GET请求 邮箱团队发现使用XMLHttpRequest时，浏览器的POST请求是通过一个两步的过程来实现的：先发送HTTP头，在发送数据。所以最好用GET请求，它只需要发送一个TCP报文（除非cookie特别多）。IE的URL长度最大值是2K，所以如果要发送的数据超过2K就无法使用GET了。POST请求的一个有趣的副作用是实际上没有发送任何数据，就像GET请求一样。正如HTTP说明文档中描述的，GET请求是用来检索信息的。所以它的语义只是用GET请求来请求数据，而不是用来发送需要存储到服务器的数据。 7.5 尽早清空缓冲区 当用户请求一个页面时，服务器需要用大约200到500毫秒来组装HTML页面，在这期间，浏览器闲等着数据到达。PHP中有一个flush()函数，允许给浏览器发送一部分已经准备完毕的HTML响应，以便浏览器可以在后台准备剩余部分的同时开始获取组件，好处主要体现在很忙的后台或者很“轻”的前端页面上（P.S. 也就是说，响应时耗主要在后台方面时最能体现优势）。 较理想的清空缓冲区的位置是HEAD后面，因为HTML的HEAD部分通常更容易生成，并且允许引入任何CSS和JavaScript文件，这样就可以让浏览器在后台还在处理的时候就开始并行获取组件。例如：… … 7.6 使用CDN（内容分发网络） 用户与服务器的物理距离对响应时间也有影响。把内容部署在多个地理位置分散的服务器上能让用户更快地载入页面。但具体要怎么做呢？ 实现内容在地理位置上分散的第一步是：不要尝试去重新设计你的web应用程序来适应分布式结构。这取决于应用程序，改变结构可能包括一些让人望而生畏的任务，比如同步会话状态和跨服务器复制数据库事务（翻译可能不准确）。缩短用户和内容之间距离的提议可能被推迟，或者根本不可能通过，就是因为这个难题。 记住终端用户80%到90%的响应时间都花在下载页面组件上了：图片，样式，脚本，Flash等等，这是业绩黄金法则。最好先分散静态内容，而不是一开始就重新设计应用程序结构。这不仅能够大大减少响应时间，还更容易表现出CDN的功劳。 内容分发网络（CDN）是一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器。 7.7 添上Expires或者Cache-Control HTTP头这条规则有两个方面： 对于静态组件：通过设置一个遥远的将来时间作为Expires来实现永不失效 多余动态组件：用合适的Cache-ControlHTTP头来让浏览器进行条件性的请求 网页设计越来越丰富，这意味着页面里有更多的脚本，图片和Flash。站点的新访客可能还是不得不提交几个HTTP请求，但通过使用有效期能让组件变得可缓存，这避免了在接下来的浏览过程中不必要的HTTP请求。有效期HTTP头通常被用在图片上，但它们应该用在所有组件上，包括脚本、样式和Flash组件。 浏览器（和代理）用缓存来减少HTTP请求的数目和大小，让页面能够更快加载。web服务器通过有效期HTTP响应头来告诉客户端，页面的各个组件应该被缓存多久。用一个遥远的将来时间做有效期，告诉浏览器这个响应在2010年4月15日前不会改变。 1 Expires: Thu, 15 Apr 2010 20:00:00 GMT 如果你用的是Apache服务器，用ExpiresDefault指令来设置相对于当前日期的有效期。下面的例子设置了从请求时间起10年的有效期：ExpiresDefault “access plus 10 years” 7.8 减少dns查询域名系统建立了主机名和IP地址间的映射，就像电话簿上人名和号码的映射一样。当你在浏览器输入www.shanghai70.com的时候，浏览器就会联系DNS解析器返回服务器的IP地址。DNS是有成本的，它需要20到120毫秒去查找给定主机名的IP地址。在DNS查找完成之前，浏览器无法从主机名下载任何东西。 DNS查找被缓存起来更高效，由用户的ISP（网络服务提供商）或者本地网络存在一个特殊的缓存服务器上，但还可以缓存在个人用户的计算机上。DNS信息被保存在操作系统的DNS cache(微软Windows上的”DNS客户端服务”)里。大多数浏览器有独立于操作系统的自己的cache。只要浏览器在自己的cache里还保留着这条记录，它就不会向操作系统查询DNS。 IE默认缓存DNS查找30分钟，写在DnsCacheTimeout注册表设置中。Firefox缓存1分钟，可以用network.dnsCacheExpiration配置项设置。(Fasterfox把缓存时间改成了1小时 P.S. Fasterfox是FF的一个提速插件) 如果客户端的DNS cache是空的（包括浏览器的和操作系统的），DNS查找数等于页面上不同的主机名数，包括页面URL，图片，脚本文件，样式表，Flash对象等等组件中的主机名，减少不同的主机名就可以减少DNS查找。 减少不同主机名的数量同时也减少了页面能够并行下载的组件数量，避免DNS查找削减了响应时间，而减少并行下载数量却增加了响应时间。我的原则是把组件分散在2到4个主机名下，这是同时减少DNS查找和允许高并发下载的折中方案。 7.9 避免重定向重定向用301和302状态码，下面是一个有301状态码的HTTP头 HTTP/1.1 301 Moved Permanently Location: http://example.com/newuri Content-Type: text/html 浏览器会自动跳转到Location域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。其实额外的HTTP头，比如Expires和Cache-Control也表示重定向。除此之外还有别的跳转方式：refresh元标签和JavaScript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。 牢记重定向会拖慢用户体验，在用户和HTML文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法开始下载，直到HTML文档被送达浏览器。 有一种常见的极其浪费资源的重定向，而且web开发人员一般都意识不到这一点，就是URL尾部缺少一个斜线的时候。例如，跳转到http://www.shanghai70.com/a会返回一个重定向到http://www.shanghai70.com/b的301响应（注意添在尾部的斜线）。在Apache中可以用Alias，mod_rewrite或者DirectorySlash指令来取消不必要的重定向。 重定向最常见的用途是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户帐号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用Alias和mod_rewrite，前提是两个代码路径都在相同的服务器上。如果是因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合Alias或者mod_rewrite指令。 7.10 Json格式传输在客户端和服务器端进行数据通信的时候，我们尽量采用json格式进行数据传输 json格式的数据，能够清晰明了的展示出数据结构，而且也方便我们获取的操作 相对于很早以前的xml格式传输，json格式的数据更加轻量级 客户端和服务器端都支持json格式数据的处理，处理起来非常的方便 真实项目中:并不是所有的数据都基于json，我们尽可能这样做，但是对于某些特殊的需求(例如文件流的传输或者文档传输)，使用json就不合适了","categories":[{"name":"前端优化方案","slug":"前端优化方案","permalink":"http://yoursite.com/categories/前端优化方案/"}],"tags":[{"name":"前端优化方案","slug":"前端优化方案","permalink":"http://yoursite.com/tags/前端优化方案/"}]},{"title":"6 cookie","slug":"前端优化方案/6 cookie","date":"2019-04-15T09:10:04.000Z","updated":"2019-06-08T15:10:37.000Z","comments":true,"path":"2019/04/15/前端优化方案/6 cookie/","link":"","permalink":"http://yoursite.com/2019/04/15/前端优化方案/6 cookie/","excerpt":"","text":"6.1 给Cookie减肥使用cookie的原因有很多，比如授权和个性化。HTTP头中cookie信息在web服务器和浏览器之间交换。重要的是保证cookie尽可能的小，以最小化对用户响应时间的影响。 清除不必要的cookie 保证cookie尽可能小，以最小化对用户响应时间的影响 注意给cookie设置合适的域级别，以免影响其它子域 设置合适的有效期，更早的有效期或者none可以更快的删除cookie，提高用户响应时间 6.2 把组件放在不含cookie的域下当浏览器发送对静态图像的请求时，cookie也会一起发送，而服务器根本不需要这些cookie。所以它们只会造成没有意义的网络通信量，应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署在那儿。如果域名是www.example.org，可以把静态组件部署到static.example.org。然而，如果已经在顶级域example.org或者www.example.org设置了cookie，那么所有对static.example.org的请求都会含有这些cookie。这时候可以再买一个新域名，把所有的静态组件部署上去，并保持这个新域名不含cookie。Yahoo!用的是yimg.com，YouTube是ytimg.com，Amazon是images-amazon.com等等。 把静态组件部署在不含cookie的域下还有一个好处是有些代理可能会拒绝缓存带cookie的组件。有一点需要注意：如果不知道应该用example.org还是www.example.org作为主页，可以考虑一下cookie的影响。省略www的话，就只能把cookie写到*.example.org，所以因为性能原因最好用www子域，并且把cookie写到这个子域下。","categories":[{"name":"前端优化方案","slug":"前端优化方案","permalink":"http://yoursite.com/categories/前端优化方案/"}],"tags":[{"name":"前端优化方案","slug":"前端优化方案","permalink":"http://yoursite.com/tags/前端优化方案/"}]},{"title":"5 移动端","slug":"前端优化方案/5 移动端","date":"2019-04-15T08:10:04.000Z","updated":"2019-06-08T15:10:38.000Z","comments":true,"path":"2019/04/15/前端优化方案/5 移动端/","link":"","permalink":"http://yoursite.com/2019/04/15/前端优化方案/5 移动端/","excerpt":"","text":"5.1 保证所有组件都小于25K这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是未压缩的大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。 5.2 把组件打包到一个复合文档里把各个组件打包成一个像有附件的电子邮件一样的复合文档里，可以用一个HTTP请求获取多个组件（记住一点：HTTP请求是代价高昂的）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）。","categories":[{"name":"前端优化方案","slug":"前端优化方案","permalink":"http://yoursite.com/categories/前端优化方案/"}],"tags":[{"name":"前端优化方案","slug":"前端优化方案","permalink":"http://yoursite.com/tags/前端优化方案/"}]},{"title":"4 优化html","slug":"前端优化方案/4 优化html","date":"2019-04-15T07:10:04.000Z","updated":"2019-06-08T15:10:39.000Z","comments":true,"path":"2019/04/15/前端优化方案/4 优化html/","link":"","permalink":"http://yoursite.com/2019/04/15/前端优化方案/4 优化html/","excerpt":"","text":"4.1 audio或者video标签如果当页面中出现audio或者video标签，我们最好设置它们的preload=:页面加载的时候，音视频资源不进行加载，播放的时候再开始加载(减少页面首次加载http请求的次数) preload=auto 页面首次加载的时候就把音频资源进行加载 preload=metadata 页面首次加载的时候只能音视资源的头部信息进行加载 4.2 尽量少用iframe 用iframe可以把一个HTML文档插入到父文档里，重要的是明白iframe是如何工作的并高效地使用它。&lt;iframe&gt;的优点： 引入缓慢的第三方内容，比如标志和广告 安全沙箱 并行下载脚本 &lt;iframe&gt;的缺点： 代价高昂，即使是空白的iframe 阻塞页面加载 非语义 4.3 杜绝404 HTTP请求代价高昂，完全没有必要用一个HTTP请求去获取一个无用的响应（比如404 Not Found），只会拖慢用户体验而没有任何好处。 有些站点用的是有帮助的404——“你的意思是xxx？”，这样做有利于用户体验，，但也浪费了服务器资源（比如数据库等等）。最糟糕的是链接到的外部JavaScript有错误而且结果是404。首先，这种下载将阻塞并行下载。其次，浏览器会试图解析404响应体，因为它是JavaScript代码，需要找出其中可用的部分。","categories":[{"name":"前端优化方案","slug":"前端优化方案","permalink":"http://yoursite.com/categories/前端优化方案/"}],"tags":[{"name":"前端优化方案","slug":"前端优化方案","permalink":"http://yoursite.com/tags/前端优化方案/"}]},{"title":"3 优化js","slug":"前端优化方案/3 优化js","date":"2019-04-15T06:10:04.000Z","updated":"2019-06-08T15:10:02.000Z","comments":true,"path":"2019/04/15/前端优化方案/3 优化js/","link":"","permalink":"http://yoursite.com/2019/04/15/前端优化方案/3 优化js/","excerpt":"","text":"3.1 去除重复脚本页面含有重复的脚本文件会影响性能，这可能和你想象的不一样。在对美国前10大web站点的评审中，发现只有2个站点含有重复脚本。两个主要原因增加了在单一页面中出现重复脚本的几率：团队大小和脚本数量。在这种情况下，重复脚本会创建不必要的HTTP请求，执行无用的JavaScript代码，而影响页面性能。 IE会产生不必要的HTTP请求，而Firefox不会。在IE中，如果一个不可缓存的外部脚本被页面引入了两次，它会在页面加载时产生两个HTTP请求。即使脚本是可缓存的，在用户重新加载页面时也会产生额外的HTTP请求。 除了产生没有意义的HTTP请求之外，多次对脚本求值也会浪费时间。因为无论脚本是否可缓存，在Firefox和IE中都会执行冗余的JavaScript代码。 避免不小心把相同脚本引入两次的一种方法就是在模版系统中实现脚本管理模块。典型的脚本引入方法就是在HTML页面中用SCRIPT标签： 1&lt;script type=\"text/javascript\" src=\"menu_1.0.17.js\"&gt;&lt;/script&gt; 3.2 尽量减少DOM访问一个复杂的页面意味着要下载更多的字节，而且用JavaScript访问DOM也会更慢。举个例子，想要添加一个事件处理器的时候，循环遍历页面上的500个DOM元素和5000个DOM元素是有区别的。操作dom的弊端 dom存在映射在机制(js中的dom元素对象和页面中dom结构是存在映射机制的，一改则都改)，这种映射机制，是浏览器安卓w3c标准完成对js语言的构建和dom的构建(其实就是构建一个监听机制)，操作dom是同事修改两个地址，相对于一些其他的js编程来说消耗性能的。 页面中的dom结构改变或者样式改变，会触发浏览器的回流(浏览器会把dom结构重新进行计算，这个操作很耗性能)和重绘(吧一个元素的样式重新渲染) 在做dom事件绑定的时候，尽量避免一个个的事件绑定，二采用性能更高的事件委托来实现 事件委托(事件代理)把时间板顶给外层容器，当里面的后代元素相关行为被处罚，外层容器绑定的方法也会被触发执行(冒泡传播机制导致)，通过的事件源是谁，我们做不同的操作即可 用JavaScript访问DOM元素是很慢的，所以，为了让页面反应更迅速，应该： 缓存已访问过的元素的索引 先“离线”更新节点，再把它们添到DOM树上 避免用JavaScript修复布局问题 DOM元素的数量很容易测试，只需要在控制台里输入 1document.getElementsByTagName('*').length 3.3 用智能的事件处理器 有时候感觉页面反映不够灵敏，是因为有太多频繁执行的事件处理器被添加到了DOM树的不同元素上，这就是推荐使用事件委托的原因。如果一个div里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮都添加一个。事件能够冒泡，所以可以捕获事件并得知哪个按钮是事件源。 3.4 更多异步操作编译 同步编程会导致:上面东西完不成，下面任务也做不了，我们开发的时候，可以把某一个区域模块都设置为异步编程，这样只要模块之间没有必然的先后顺序，都可以独立进行加载，不会受到上面模块的堵塞影响(用的不多) 尤其是ajax数据请求，我们一般都要使用异步编程，最好是基于promise设计模式进行管理(项目中经常使用fetch、vue、axios)等插件进行ajax请求处理，因为这些插件中就是基于promise设计模式对ajax进行了封装处理 在真实的项目中，我们尽可能避免一次性循环过多数据(因为循环操作是同步编程)，尤其是要避免while导致的死循环操作### 3.5 JS中避免使用eval 性能消耗大 代码压缩后，容易出现代码执行错乱问题 3.6 JS中尽量减少闭包的使用 闭包会形成一个不销毁的栈内存，过多的栈内存累积影响页面的性能 还会容易导致内存的泄露 闭包也有自己的优势:保存和保护，我们只能尽量减少，但是无法避免####3.7 尽量使用css3动替代js动画css3的动画或者变形都开启了硬件加速，性能比js动画好 3.8 缓存做处理对于不经常更新的数据，最好采用浏览器的304缓存做处理例如:第一次请求css和js下拉，浏览器会把请求的内容缓存起来，如果做了304处理，用户再次请求css和js直接从缓存中读取，不需要再去服务器获取了(减少了http请求次数)当用户强制刷新页面(ctrl+f5)或者当前缓存的css或者js发生了变动，都会从新从服务器端拉取对于客户端来讲，我们还可以基于localStronge来做一些本地存储，例如:第一次请求的数据或者不经常更新的css和js，我们都可以吧内容存储在本地，下一次页面加载，我们从本地中获取即可，我们设定一定的期限或者一些标识，可以控制在某个阶段重新从服务器获取 3.9 设计模式编写js代码的时候尽可能使用设计模式来构建体系，方便后期的维护，也提高了扩充性等 3.10 把脚本放在底部脚本会阻塞并行下载，HTTP/1.1官方文档建议浏览器每个主机名下并行下载的组件数不要超过两个，如果图片来自多个主机名，并行下载的数量就可以超过两个。如果脚本正在下载，浏览器就不开始任何其它下载任务，即使是在不同主机名下的。 有时候，并不容易把脚本移动到底部。举个例子，如果脚本是用document.write插入到页面内容中的，就没办法再往下移了。还可能存在作用域问题，在多数情况下，这些问题都是可以解决的。 一个常见的建议是用推迟（deferred）脚本，有DEFER属性的脚本意味着不能含有document.write，并且提示浏览器告诉他们可以继续渲染。不幸的是，Firefox不支持DEFER属性。在IE中，脚本可能被推迟，但不尽如人意。如果脚本可以推迟，我们就可以把它放到页面底部，页面就可以更快地载入。 3.11 压缩js 使用在线网站进行压缩 使用html-minifier 对html 中的css 进行压缩 使用uglifjs2对js进行压缩 webpack,gulp打包工具","categories":[{"name":"前端优化方案","slug":"前端优化方案","permalink":"http://yoursite.com/categories/前端优化方案/"}],"tags":[{"name":"前端优化方案","slug":"前端优化方案","permalink":"http://yoursite.com/tags/前端优化方案/"}]},{"title":"2 优化图片","slug":"前端优化方案/2 优化图片","date":"2019-04-15T05:10:04.000Z","updated":"2019-06-08T15:09:56.000Z","comments":true,"path":"2019/04/15/前端优化方案/2 优化图片/","link":"","permalink":"http://yoursite.com/2019/04/15/前端优化方案/2 优化图片/","excerpt":"","text":"2.1 图片格式尝试把GIF格式转换成PNG格式，看看是否节省空间。在所有的PNG图片上运行pngcrush（或者其它PNG优化工具） 2.2 优化CSS Sprite 采用css雪碧图(css sprit/css 图片精灵)技术，吧一些小图合并在一张大图上面，使用的时候，通过北京图片定位，定位到具体的某一张小图上 在Sprite图片中横向排列一般都比纵向排列的最终文件小 组合Sprite图片中的相似颜色可以保持低色数，最理想的是256色以下PNG8格式 “对移动端友好”，不要在Sprite图片中留下太大的空隙。虽然不会在很大程度上影响图片文件的大小，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。100×100的图片是1万个像素，而1000×1000的图片就是100万个像素了。 12345678.pubBg&#123; background:url('../img/sprit.png') no-repeat; background-size:x y; // 和原图的大小保持一致&#125;.box&#123; background-position:x y; // 通过背景定位，定位到具体的位置，展示不同的图片极客&#125; 页面中没法送一次http请求，都需要完成请求+响应这个完整的http事务，会消耗一些时间，也可能会导致http链接通道的堵塞,为了提高页面的加载速度和运行的性能，我们应该减少http的请求次数和减少请求内容的大小。 2.3 图像映射可以把多张图片合并成单张图片，总大小是一样的，但减少了请求数并加速了页面加载。图片映射只有在图像在页面中连续的时候才有用，比如导航条。给image map设置坐标的过程既无聊又容易出错，用image map来做导航也不容易，所以不推荐用这种方式。 2.4 行内图片（Base64编码）用data: URL模式来把图片嵌入页面。这样会增加HTML文件的大小，把行内图片放在（缓存的）样式表中是个好办法，而且成功避免了页面变“重”。但目前主流浏览器并不能很好地支持行内图片。减少页面的HTTP请求数是个起点，这是提升站点首次访问速度的重要指导原则。 2.5 不要用HTML缩放图片 不要因为在HTML中可以设置宽高而使用本不需要的大图。如果需要 1&lt;img width=\"100\" height=\"100\" src=\"mycat.jpg\" alt=\"My Cat\" /&gt; 那么图片本身（mycat.jpg）应该是100x100px的，而不是去缩小500x500px的图片。 2.6 用小的可缓存的favicon.ico（P.S. 收藏夹图标）favicon.ico是放在服务器根目录的图片，它会带来一堆麻烦，因为即便你不管它，浏览器也会自动请求它，所以最好不要给一个404 Not Found响应。而且只要在同一个服务器上，每次请求它时都会发送cookie，此外这个图片还会干扰下载顺序，例如在IE中，当你在onload中请求额外组件时，将会先下载favicon。所以为了缓解favicon.ico的缺点，应该确保： 足够小，最好在1K以下 设置合适的有效期HTTP头（以后如果想换的话就不能重命名了），把有效期设置为几个月后一般比较安全，可以通过检查当前favicon.ico的最后修改日期来确保变更能让浏览器知道。 2.7 压缩image 使用雪花图 使用雪花图 http://www.spritecow.com/ 使用矢量图 使用矢量图字体 http://fontawesome.dashgame.com/ 使用阿里矢量图库 http://www.iconfont.cn/ 使用矢量图转成字体 https://icomoon.io/ 使用base64转换 使用网站压缩 使用无损压缩 https://tinypng.com/ png转换webp http://zhitu.isux.us/ 合理使用格式图片 jpg有损压缩，压缩率搞，不支持透明 png支持透明，浏览器兼容好 webp压缩程度更好，在ios webview有兼容性问题 svg矢量图，代码内嵌，相对于较小，图片样式相对简单的场景 在使用webp的过程中，会产生一些浏览器兼容问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function checkWebp() &#123; try&#123; return (document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0); &#125;catch(err) &#123; return false; &#125;&#125;$(document).ready(function() &#123; var webp_good = checkWebp(); if(webp_good == false) &#123; $('img').each(function() &#123; var src = $(this).attr('src'); if(typeof src != 'undefined') &#123; src = src.replace('/format,webp', '/format,jpg'); //将webp格式转换成jpg格式 $(this).attr('src', src); &#125; var original = $(this).attr('original'); //针对用了懒加载的情况 if(typeof original != 'undefined') &#123; original = original.replace('/format,webp', '/format,jpg'); //将webp格式转换成jpg格式 $(this).attr('original', original); &#125; &#125;) &#125;&#125;) 2.8 图片懒加载采用图片懒加载技术，在页面开始加载时候，不请求真实的图片地址，而是默认图占位，当页面加载完成后，在根据相关的条件依次加载真实的图片(减少页面首次加载http请求的次数)真实项目中，我们开始图片都不加载，页面首次加载完成，先把第一屏幕中看见的图片进行加载，随着页面的滚动，在下面区域中能够呈现出来的图片进行加载 根据图片懒加载技术，我们还可以扩充出，数据懒加载 开始加载页面的时候，我们只把首屏或者前两屏的数据从服务器进行请求(有些网站首屏数据是后台渲染好，整体返回给客户端呈现的) 当页面下拉，滚动到哪个区域，在把这个区域需要的数据进行请求(请求回来数据绑定以及图片延迟加载等) 分页展示技术采用的也是数据懒加载思想实现的:如果我们开始请求获取的数据是很多的数据，我们最好分批请求，开始只请求第一页的数据，当页面点击第二页(微博是下拉到一定距离后，再请求第二页数据)的时候请求第二页数据。","categories":[{"name":"前端优化方案","slug":"前端优化方案","permalink":"http://yoursite.com/categories/前端优化方案/"}],"tags":[{"name":"前端优化方案","slug":"前端优化方案","permalink":"http://yoursite.com/tags/前端优化方案/"}]},{"title":"1 优化css","slug":"前端优化方案/1 优化css","date":"2019-04-15T03:10:04.000Z","updated":"2019-06-08T15:09:17.000Z","comments":true,"path":"2019/04/15/前端优化方案/1 优化css/","link":"","permalink":"http://yoursite.com/2019/04/15/前端优化方案/1 优化css/","excerpt":"","text":"1.1 避免使用CSS表达式用CSS表达式动态设置CSS属性，是一种强大又危险的方式。从IE5开始支持，但从IE8起就不推荐使用了。例如，可以用CSS表达式把背景颜色设置成按小时交替的 尽量减少标签选择器的使用 尽可能少使用id选择器，多使用样式选择器(通用性强) 减少选择器前缀，例如.headerBox .nav .left a{} 选择器是从右向左查询的 避免使用css表达式 1background-color: expression( (new Date()).getHours()%2 ? \"#B8D4FF\" : \"#F08A00\" ); 1.2 减少页面中的冗余代码尽可能提高方法的重复使用率：“低耦合高内聚” 1.3 选择舍弃@import 前面提到了一个最佳实践：为了实现逐步渲染，CSS应该放在顶部。在IE中用@import与在底部用&lt;link&gt;效果一样，所以最好不要用它。 1.4 避免使用滤镜IE专有的AlphaImageLoader滤镜可以用来修复IE7之前的版本中半透明PNG图片的问题。在图片加载过程中，这个滤镜会阻塞渲染，卡住浏览器，还会增加内存消耗而且是被应用到每个元素的，而不是每个图片，所以会存在一大堆问题。最好的方法是干脆不要用AlphaImageLoader，而优雅地降级到用在IE中支持性很好的PNG8图片来代替。如果非要用AlphaImageLoader，应该用下划线hack：_filter来避免影响IE7及更高版本的用户。 ### 1.5 把样式表放在顶部把样式表放到文档的HEAD部分能让页面看起来加载地更快。这是因为把样式表放在head里能让页面逐步渲染。 关注性能的前端工程师想让页面逐步渲染。也就是说，我们想让浏览器尽快显示已有内容，这在页面上有一大堆内容或者用户网速很慢时显得尤为重要。给用户显示反馈（比如进度指标）的重要性已经被广泛研究过，并且被记录下来了。在我们的例子中，HTML页面就是进度指标！当浏览器逐渐加载页面头部，导航条，顶部logo等等内容的时候，这些都被正在等待页面加载的用户当作反馈，能够提高整体用户体验。 1.6 压缩 css 使用在线网站进行压缩 使用html-minifier 对html 中的css 进行压缩 使用clean-css 对css进行压缩 webpack,gulp打包工具","categories":[{"name":"前端优化方案","slug":"前端优化方案","permalink":"http://yoursite.com/categories/前端优化方案/"}],"tags":[{"name":"前端优化方案","slug":"前端优化方案","permalink":"http://yoursite.com/tags/前端优化方案/"}]},{"title":"11.函数基础","slug":"JavaScript基础入门/11 函数基础","date":"2019-04-10T08:10:04.000Z","updated":"2019-06-06T15:51:28.000Z","comments":true,"path":"2019/04/10/JavaScript基础入门/11 函数基础/","link":"","permalink":"http://yoursite.com/2019/04/10/JavaScript基础入门/11 函数基础/","excerpt":"","text":"函数是指一段在一起的、可以做某一件事儿的程序。也叫做子程序、(OOP中)方法 函数实现某一个功能的方法 创建函数1234functoin [函数名]()&#123; // =&gt; [函数体] // 实现功能的具体js代码&#125; 执行函数12函数名(); // 创建的函数执行，而且这个函数可以执行很多次函数名(); 每一次执行都相当于把函数体重实现功能的js代码重复执行了一遍 在真实的项目中，我们一般都会把实现一个具体功能的代码封装到函数中 如果当前这个功能需要在页面中执行多次，不封装成为函数，每一次实现这个功能，都需要重新吧代码写一遍，浪费时间；而封装在一个函数中，以后想实现多次这个功能，我们就没有必要在重新写代码，只需要把函数重新的执行即可，提高了开发效率 封装在一个函数，页面中就基本上很难重复一样的代码了，减少了页面中代码的冗余度，提高了代码的重复利用率: 低耦合高内聚 我们把以上的特点成为函数封装 (OOP面向对象编程思想，需要我们掌握的就是类的继承、封装、多态) JS中函数的核心原理 函数作为js中引用数据类型中的一种，也是按照引用地址操作的 123456function sum()&#123; var total = 1+1; total *= 20; console.log(total.toFixed(2));&#125;sum(); 创建函数 首先会在当前作用中声明一个函数名(声明的函数和使用var声明变量是一样的操作:var sum;function cum;这两个名字算重复了) 浏览器首先会开辟一个新的内存空间(奉陪一个16进制地址)，把函数体重写好的代码当做普通字符串存储在这个内存空间(创建一个函数如果不执行，函数没有意义) 把内存空间的地址赋值给之前声明的那个函数名 函数执行 目的:把之前存储的实现具体功能的js代码执行 函数执行，浏览器首先会为其开辟新的私有作用域(只能执行函数中之前编写的js代码) 形参赋值 私有作用中的变量升级 把之前穿件时间存储的那些js代码字符串，拿到自由作用域中，然后把题目变成js表达式从上到下执行 私有作用域是否销毁的问题 ![image.png](https://cdn.nlark.com/yuque/0/2019/png/271124/1553076800854-5e22d4eb-aa50-40a1-a8de-6abbd5cf8939.png#align=left&display=inline&height=203&name=image.png&originHeight=406&originWidth=986&size=115231&status=done&width=493) 闭包 函数执行会形成一个私有的作用域，让里面的私有变量和外界互不影响(相互干扰、外面的无法直接获取里面的变量值)，此时我们可以理解为私有作用域把私有变量保护起来，我们把这种保护机制称为为闭包 栈内存 作用域(全局作用域/私有作用域):提供一个供js代码执行的环境 堆内存 所有的引用数据类型，他们需要存储的内容都是堆内存中(相当于一个仓库，目的是存储信息) 对象会吧键值队存储起来 函数会把代码当做字符串存储起来 函数中形参和实参 形参:相当于生成洗衣机的时候提供的入口，需要用户执行函数的时候把需要的值传递进来，形参是个变量，用来春初和接口那些值 实参:用户执行的时候传递给形参的具体指 1234567891011// 随便求出两个数的和function sum(num1,num2)&#123; //num1/num2就是形参变量(类似于var了一下) var total = num1 + num2; total*=10; total=total.toFixed(2); console.log(total);&#125;sum(10,20);//10/20是实参 num1=10 num2=20sum(10); // num1=10 num2=undefined 定义了形参但是执行的时候，没有传递实参，默认实参就是undefined arguments实参集合 当我们不知道用户具体要传递几个值的时候(传递几个值都行)，此时我们无法设置形参的个数:遇到此类需要，需要使用函数内置的实参集合：arguments argument 只有函数才有 不管执行函数的时候是否传递实参，arguments天生就纯在，没有传递实参ARG是个空的集合传递了ARG中包含了所有传递的实参值 不管是否设置了形参，ARG中始终存储了所有的实参信息 1234function sum()&#123; console.log(arguments)&#125;sum(10,20,'wjh',&#123;name:'wjw'&#125;); arguments 是个类数组集合 以数字作为索引(属性名)，从0开始 arguments[0] 第一个实参信息 arguments[2] 第三个实参信息 arguments[n] 第n+1个实参信息 有一个length的属性，存储的是当前几个的长度(当前传递实参的个数) arguments.length arguments[‘length’] arguments.calle 存储的是当前函数本身 arguments.calle.caller 存储的是当前函数只在哪执行的(宿主函数)，在全局作用域下执行的，结果是null 1234567function sum()&#123; console.log(arguments.callee.caller);//f&#125;function fn()&#123; sum(10,20,'wjh',&#123;name:'wjw'&#125;);&#125;fn(); // arguments.call或者arguments.call.caller一般真正项目中很少使用，因为是在严格js模式下不允许我们直接使用这两个属性，然而现有项目大部分都是基于严格模式来的 123456789101112131415161718// 任意数求和function sum()&#123; var total = null; for(var i =0;i&lt;arguments.length;i++)&#123; var cur = Number(arguments[i]); !isNaN(cur)?total += cur : null &#125; consloe.log(total); return total; // return 后面跟着的都是值(返回的都是值):此处不少TOTAL变量返回，而是吧total存储到值返回而已 // return 60;&#125;sum(10,20,20);sum();sum(10,20,30,'wjw')// console.log(total); //=&gt;Uncaught ReferenceError: total is not defined 闭包的保护机制导致作用域会保护里面的私有变量 JS中的返回值return 返回值是函数提供的一个出口:我们如果想在外面使用函数私有的一些信息，那么就需要通过return，把这些信息返回出来供外面使用 sum:代表的是函数本身sum() 让函数先执行，代表的是当前函数返回的结果(return)后面是啥，相当于函数返回的是啥 123456function sum()&#123; var total = 0; renturn&#125;console.log(sum());// 如果函数中没有return或者return后面啥也没有，默认返回的结果是undefined 123456function sum()&#123; var total = 0; renturn; console.log(sum()); // 函数体重遇到return后，return后面的代码都不在执行了&#125; js中匿名函数 没有名字的函数 函数表达式 自执行函数 1234oBox.onclick = function()&#123; // 把一个码云名字的函数(有名字的也无所谓)作为值赋值给一个变量或者一个元素的某一个事件等,函数表达式&#125; 12345678910(function(n)&#123; // 创建函数和执行函数放在一起，穿件完成立马之执行:自执行函数 // n 形参 n=10&#125;)(10)// 以下都是自执行函数，符号只有控制语法规范~function()&#123;&#125;(10)-function()&#123;&#125;(10)+function()&#123;&#125;(10)!function()&#123;&#125;(10)","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"10.数组的函数","slug":"JavaScript基础入门/10 数组的函数","date":"2019-04-10T07:10:04.000Z","updated":"2019-06-06T15:50:01.000Z","comments":true,"path":"2019/04/10/JavaScript基础入门/10 数组的函数/","link":"","permalink":"http://yoursite.com/2019/04/10/JavaScript基础入门/10 数组的函数/","excerpt":"","text":"数组的基础结构 数组也是对象数据类型 typeof [] -&gt; ‘object’ 数组也是属性名，只不过属性名是数字，我们把数字属性名称之为它的索引:数组是以数字为索引，索引从零开始，有一个length属性代表数组的长度 类数组：类似于数组，但是不是数组 通过getElementsByTageName 获取的元素集合是类数组 函数中的实参集合argument也是类数组 123456789101112// for 循环操作for(var i =0;i&lt;ary.length;i++)&#123; console.log(ary[i])&#125;// for in 循环操作for(var key in ary)&#123; // key:属性名(数组中的属性名是索引) console.log(ary[key]);&#125;// for 循环只能遍历到数组私有的一些属性，而for in 循环可以吧一些自定义的公共属性也能遍历到 数组中的常用方法 数组中有很多方法 1console.dir(Array.prototype) 方法的意义和作用 方法的形参 方法的返回值 通过此方法，原来的数组是否发生了改变 实现数组的增加、修改、删除 增加push : 向数组的末尾追加新内容参数:一到多个，任何数据类型都可以，想要给数组末尾追加什么，直接传递到push方法中极客，传递多个逗号隔开返回值:新增后数组的长度原有数组改变了 unshift:向数组开头追加新内容参数:需要追加的内容(可以是多个任何数据类型的值)返回值:新增后 数组的长度原来数组改变了 把数组当做一个普通的对象，使用对象键值对的操作，给其设置新的属性(索引)ary[ary.length]=xxx 向数组的末尾追加了新的内容 删除pop 删除数组最后一项参数:无返回值:被删除的那一项内容原有数组改变了 shift:删除数组第一项参数:无返回值:被删除那一项的内容原有数组改变了使用shift删除第一项之后，后面每一项的索引都要向前进一位(导致后面项的索引发生了改变) 把数组当做一个普通对象操作delete删除:delete ary[索引]删除指定索引这一项(当前项被删除后),原有数组其它项的索引不会改变:当前数组的length也不会改变 ary.length–:删除数组最后一项 splice:数组中内置的方法，可以实现数组的增加、修改、删除splice实现删除splice(n,m):从索引n开始删除m个(m不写是个删除列数组的末尾，n也不写)返回值:被删除的内容(以一个新数组保存)原有数组改变了splice(0) 清空数组splice() 一项都不删除，返回一个新的空数组splice(0,1)删除第一项 splice实现修改splice(n,m,x):在原有删除的基础上，用x代替删除的内容 splice实现增加splice(n,0,x):在修改的基础上，我们一项都不删除，把x插入到索引n的前面ary.splice(0,0,x) 向数组末尾追加新元素 数组的查询 slice 数组的查询 参数:slice(n,m) 从索引n开始找到索引m处(不包含m) 返回值:吧找到的部分已一个新数组返回 原来的数组不变 slice(n) 从索引n开始找到末尾slice(0) /slice() 数组克隆，克隆一份和原来数组一模一样的的新数组slice支持负载索引，如果传递的索引为负数，浏览器解析的时候是按照总长度+负数索引 来处理的 将两个数组进行拼接concat:将多个数组拼接在一起 参数:要拼接的内容(把内容放在原数组的后面)，可以是一个数组 返回:拼接后的新数组 原有数组不变 数组的查询slice: 数组的查询参数: slice(n,m) 从索引n开始找到索引为m处(不包含m)返回值:把找到的部分已一个新数组返回原来的数组不变 123slice(n) 从索引n开始找到末尾slice(0) / slice() 数组克隆，克隆一份和原来数组一模一样的新数组slice 支持负数索引，如果传递的索引为负数，浏览器解析的时候是按照，总长度+负数索引 来处理的 数组的拼接concat:将多个数组拼接在一起参数:要拼接的内容(把内容放在原数组的后面),可以是一个数组，也可以是一些数据值返回:拼接后的新数组原有的数组不变 12let arr = [0,100]arr.concat([100,200],[200,300],12) concat() 什么都没有拼接，相当于吧原有数组克隆一份一模一样的出来 数组转字符串toString 实现吧数组转化为字符串(转换后的字符串逗号分隔每一项) 参数:无返回值:转换的字符串原有数组不变 join 把数组按照指定的分隔符转换为字符串，和字符串中的split相对应 参数:指定的链接符号 返回值:转换后的字符串 原有数组不变 已知数组的每一项都是数字，想事先数组求和，我们如何实现？ 循环实现 1234var total = null;for(var i=0;i&lt;ary.length;i++)&#123; total+=ary[i];&#125; 利用join 1var total = eval(ary.join('+')) // evel:把字符串变为js表达式执行 实现数组中每一项的排序和排列reverse 把数组中每一项倒过来排序 参数:无返回值:排序后的数组原有数组改变 sort 实现数组的排序 参数:无或者回调函数返回值:排序后的数组原有数组改变 不传递参数的情况下:可以给10以内的数字进行升序排列，但是超过10的就无法处理(多位数值识别第一位) 1234ary.sort(function(a,b)&#123; return a-b; //升序 return b-a; //降序&#125;) 验证数组中是否包含某一项indexOf / lastindexOf 获取当前现在数组中第一次或者最后一次出现的位置索引 数组的这两个方法在IE6-IE8下不兼容 字符串的这两个方法兼容所有的浏览器 123if(ary.indexOf(12)&gt;-1)&#123; // 数组中包含12&#125; 原理12345678910Array.prototype.myIndexOf = function myIndexOf(value)&#123; var result = -1; for(var i =0;i&lt;this.length;i++)&#123; if(value===this[i])&#123; result = i; break; &#125; &#125; return result;&#125; 遍历数组每一项的方法 以下方法ie6-8下都不兼容 forEach 遍历数组中的每一项 12345ary.forEach(function(value,index)&#123; /* 数组中有多少项，当前回调函数执行多少次，妹妹一次传进来的value就是当前遍历数组这一项的值，index 就是遍历这一项的索引 */&#125;) map 遍历数组中的每一项，在forEach的基础上，可以修改每一项的值 1234567ary.map(function(value,index)&#123; /* 数组中有多少项，当前回调函数执行多少次，妹妹一次传进来的value就是当前遍历数组这一项的值，index 就是遍历这一项的索引 */ return xxx; // return 后面返回的结果就是当前遍历的这一项修改为xxx&#125;) filterfindreduceevery… 数组去重 var ary = [1,2,3,4,5,6,7,1,3,4,5]; 方案一 最简单数组去重法遍历数组的每一项，拿每一项和它后面的项依次比较,如果相同了，则把相同的这一项在原来数组中删除即可 12345678910111213141516/** 新建一新数组，遍历传入数组，值不在新数组就push进该新数组中* IE8以下不支持数组的indexOf方法* */function uniq(array)&#123; var temp = []; //一个新的临时数组 for(var i = 0; i &lt; array.length; i++)&#123; if(temp.indexOf(array[i]) == -1)&#123; temp.push(array[i]); &#125; &#125; return temp;&#125;var aa = [1,2,2,4,9,6,7,5,2,3,5,6,5];console.log(uniq(aa)); 方案二 对象键值法去重123456789101112131415161718192021222324252627/** 速度最快， 占空间最多（空间换时间）** 该方法执行的速度比其他任何方法都快， 就是占用的内存大一些。* 现思路：新建一js对象以及新数组，遍历传入数组时，判断值是否为js对象的键，* 不是的话给对象新增该键并放入新数组。* 注意点：判断是否为js对象键时，会自动对传入的键执行“toString()”，* 不同的键可能会被误认为一样，例如n[val]-- n[1]、n[\"1\"]；* 解决上述问题还是得调用“indexOf”。*/function uniq(array)&#123; var temp = &#123;&#125;, r = [], len = array.length, val, type; for (var i = 0; i &lt; len; i++) &#123; val = array[i]; type = typeof val; if (!temp[val]) &#123; temp[val] = [type]; r.push(val); &#125; else if (temp[val].indexOf(type) &lt; 0) &#123; temp[val].push(type); r.push(val); &#125; &#125; return r;&#125;var aa = [1,2,\"2\",4,9,\"a\",\"a\",2,3,5,6,5];console.log(uniq(aa)); 方案三 排序后相邻去除法123456789101112131415161718/** 给传入数组排序，排序后相同值相邻，* 然后遍历时,新数组只加入不与前一值重复的值。* 会打乱原来数组的顺序* */function uniq(array)&#123; array.sort(); var temp=[array[0]]; for(var i = 1; i &lt; array.length; i++)&#123; if( array[i] !== temp[temp.length-1])&#123; temp.push(array[i]); &#125; &#125; return temp;&#125;var aa = [1,2,\"2\",4,9,\"a\",\"a\",2,3,5,6,5];console.log(uniq(aa)); 方案四 数组下标法12345678910111213141516171819/*** 还是得调用“indexOf”性能跟方法1差不多，* 实现思路：如果当前数组的第i项在当前数组中第一次出现的位置不是i，* 那么表示第i项是重复的，忽略掉。否则存入结果数组。* */function uniq(array)&#123; var temp = []; for(var i = 0; i &lt; array.length; i++) &#123; //如果当前数组的第i项在当前数组中第一次出现的位置是i，才存入数组；否则代表是重复的 if(array.indexOf(array[i]) == i)&#123; temp.push(array[i]) &#125; &#125; return temp;&#125;var aa = [1,2,\"2\",4,9,\"a\",\"a\",2,3,5,6,5];console.log(uniq(aa)); 方案五 优化遍历数组法123456789101112131415161718192021222324252627// 思路：获取没重复的最右一值放入新数组/** 推荐的方法** 方法的实现代码相当酷炫，* 实现思路：获取没重复的最右一值放入新数组。* （检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）*/function uniq(array)&#123; var temp = []; var index = []; var l = array.length; for(var i = 0; i &lt; l; i++) &#123; for(var j = i + 1; j &lt; l; j++)&#123; if (array[i] === array[j])&#123; i++; j = i; &#125; &#125; temp.push(array[i]); index.push(i); &#125; console.log(index); return temp;&#125;var aa = [1,2,2,3,5,3,6,5];console.log(uniq(aa));","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"9.Date的基础知识","slug":"JavaScript基础入门/9 Date的基础知识","date":"2019-04-10T06:10:04.000Z","updated":"2019-06-06T15:46:06.000Z","comments":true,"path":"2019/04/10/JavaScript基础入门/9 Date的基础知识/","link":"","permalink":"http://yoursite.com/2019/04/10/JavaScript基础入门/9 Date的基础知识/","excerpt":"","text":"Data 是日期类 通过它可以对时间进行处理 1234567891011121314151617var time = new Date();// 获取当前客户端本机时间(当前获取的时间不能作为重要的参考依据)// 获取结果是一个日期格式的对象// Wed Mar 20 2019 17:37:16 GMT+0800 (中国标准时间)typeof new Date() -&gt; objecttime.getFullYear() 获取四位数整年time.getMonth() 获取月份time.getDate() 获取日time.getDay() 获取星期(0-6代表周日-周六)time.getHours() 获取小时time.getMinutes() 获取分钟time.getSeconds() 获取秒time.getMilliseconds() 获取毫秒time.getTime() 获取当前日期距离'1970-01-01 00:00:00'的毫秒差 123var time = new Date('2017-10-22'); // 当new Date 中传递一个时间格式的字符串，相当于把这个字符串换位标准时间对象// (转换完成后，就可以调取上面我们讲的那些方法) // 时间格式的字符串‘2017-10-22’ (IE下识别不了)‘2017/10/22 16:15:34’‘1508659621314’(如果传递的是距离1970年那个毫秒查，也可以识别转换的,但是只能是数字，不能是字符串)","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"8.字符串及常用的方法","slug":"JavaScript基础入门/8 字符串及常用的方法","date":"2019-04-10T05:10:04.000Z","updated":"2019-06-06T15:45:14.000Z","comments":true,"path":"2019/04/10/JavaScript基础入门/8 字符串及常用的方法/","link":"","permalink":"http://yoursite.com/2019/04/10/JavaScript基础入门/8 字符串及常用的方法/","excerpt":"","text":"在js中用单(双)引号包裹起来的都是字符串 1var str = &apos;welcome to credan!&apos; 字符串就是由零到多个字符串组成的 第一个字符索引0第二个字符索引1…有length的属性，存储的是当前字符串中字符的个数(字符串的长度) 以数字作为索引，从零开始的 str[0] -&gt; ‘w’ 第一个字符strlength-&gt; 46str[str.length-1] -&gt; ‘!’ 最后一个字符str[100] -&gt; undefined 如果指定的索引不存在获取的结果是undefined 真实项目中，我们经常操作字符串，此时我们需要掌握常用的一些字符床操作方法 console.dir(String.prototype) charAt &amp;&amp; charCodeAt str.charCodeAt(索引)在charAt 基础上，把获取的字符变为Unicode编码值(对应ASCll码表) 48-57 0-9 65-90 A-Z 97-122 a-z … String.fromCharCode(十进制的Unicode值)，把值按照ascll码表中的信息，转为原有字符，charCodeAt正好对应 substr &amp;&amp; substring &amp;&amp; slice 实现字符串截取的三个办法 str.substr(n.m) : 从索引n开始，截取m个字符 str.substring(n,m):从索引n开始，截取到索引为m处(包含m)，把找到的部分截取 str.slice(n,m):和substring语法意义，区别在于slice支持一负数做索引 当索引是负数的时候，浏览器在处理的时候，是用字符串的总长度加上负数索引，然后按照正数处理操作 细节: 如果只传递了n(str.substr(n)/str.substring(n)),相当于索引n开始的一直截取到字符串的末尾 如果传递的索引超出最大限制，也是吧能截取的部分截取掉即可 如果一个参数都不传递:相当于吧证书字符串都截取(字符串的克隆) indexOf &amp;&amp; lastIndexOf str.indexOf 获取当前字符在字符串中第一次出现位置的索引 str.lastIndexOf 获取的是最后一次出现位置的索引 如果当前字符在字符串中没有出现过，结果是-1:我们根据这个规律可言验证一下当前字符串中是否包含某个字符 1234567if(str.indexOf(&apos;?&apos;)===-1)&#123; // =&gt; 没有出现过&#125;if(str.indexOf(&apos;?&apos;)&gt;=-1)&#123; // =&gt; 出现过&#125; split str.split 按照某个字符串分成数组中的某一项，和数组中的join方法是对应 replace str.replace 实现字符的替换执行一次replace 只能替换一次，如果有好几个都需要替换，在不适用正则的情况下，我们需要执行很多次replace 有些需求及时执行很多次repalce也实现不了，此时需要使用正则处理，真实项目中replace一般都是和正则搭配使用的 trim &amp;&amp; trimLeft &amp;&amp; trimRight str.trimLeft : 去除字符串开始的口空格 str.trimRight : 去除字符串结尾的口空格 str.trim 去除字符串首位的空格 获取地址栏的值 123456789101112131415function queryURLPrameter(url)&#123; // =&gt; url 传递的参数 var quesIndex = url.indexOf('?'), obj = &#123;&#125; if(quesIndex === -1)&#123; // url中没有问号传参 直接返回空 retrun obj; &#125; url = url.substr(quesIndex + 1); var ary = url.split('&amp;'); for(var i =0;i&lt;ary.length;i++)&#123; var curAry = ary[i].split('='); obj[curAry[0]] = curAry[i]; &#125; return obj&#125; 123456789101112String.prototype.myQueryURLParameter = function myQueryURLParamter()&#123; var obj = /([^=?&amp;]+)=([^=?&amp;]+)/g; this.replace(reg,function()&#123; var arg = argments; obj[arg[1]] = arg[2] &#125;) return obj;&#125;var str = 'https://www/baidu.com/s?wd=1233213&amp;issp=1';console.log(str.myQueryURLParameter());","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"1 安装与配置","slug":"mongoose/1 安装与配置","date":"2019-04-10T03:10:04.000Z","updated":"2019-06-08T14:39:37.000Z","comments":true,"path":"2019/04/10/mongoose/1 安装与配置/","link":"","permalink":"http://yoursite.com/2019/04/10/mongoose/1 安装与配置/","excerpt":"","text":"1.0 介绍MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组 1.1 mac电脑安装教程 1.1.1 安装homebrewhomebrew的安装查看官网，安装完成后，在终端中输入以下命令更新homebrew的package数据库 1brew update 提示：brew update升级brew的版本库，brew outdated 查看outdated的库和应用，brew upgrade 升级outdated的库和应用，brew cleanup 清理调过期的库和应用 ### 1.1.2 安装mongodb使用homebrew安装mongodb，在MAC的终端中输入 1cd / 1brew install mongodb 若要查看安装信息 1brew info mongodb 查看mongodb的版本 1mongo --version 1which mongod /usr/local/bin/mongod 如果这样了就安装成功了 启动服务 1sudo mongod 1.2 手动部署服务器 1.2.1 下载安装包1wget http://fastdl.mongodb.org/linux/mongodb-linux-i686-1.8.2.tgz 下载完成后解压缩压缩包 1tar zxf mongodb-linux-i686-1.8.2.tgz 1.2.2. 安装准备 将mongodb移动到/usr/local/server/mongdb文件夹 1mv mongodb-linux-i686-1.8.2 /usr/local/mongodb 创建数据库文件夹与日志文件 12mkdir /usr/local/mongodb/datatouch /usr/local/mongodb/logs 1.2.3. 设置开机自启动 将mongodb启动项目追加入rc.local保证mongodb在服务器开机时启动 1echo \"/usr/local/mongodb/bin/mongod --dbpath=/usr/local/mongodb/data –logpath=/usr/local/mongodb/logs –logappend --auth -–port=27017\" &gt;&gt; /etc/rc.local 1.2.4. 启动mongodb cd到mongodb目录下的bin文件夹启动mongodb 下面这个是需要权限的登录方式, 用户连接需要用户名和密码 1/usr/local/mongodb/bin/mongod --dbpath=/usr/local/mongodb/data --logpath=/usr/local/mongodb/logs --logappend --auth --port=27017 --fork 这个是不需要密码的(不建议) 1/usr/local/mongodb/bin/mongod --dbpath=/usr/local/mongodb/data --logpath=/usr/local/mongodb/logs --logappend --port=27017 --fork 1.3 宝塔一键完成 1.4 设置密码 1.4.1 进入安装路径的bin目录1cd /www/server/mongodb/bin 1.4.2 输入命令行mongo，进入mongodb环境1mongo 1.4.3 切换到 admin 数据库1use admin 1.4.4 给admin设置用户密码 user: 用户名 pwd: 用户密码 roles: 用来设置用户的权限，比如读，读写 等等 1db.createUser(&#123;user: &apos;root&apos;, pwd: &apos;admin_mima&apos;, roles: [&apos;root&apos;]&#125;) 1.4.5 验证是否添加成功，db.auth(用户名，用户密码)1db.auth(&apos;root&apos;, &apos;admin_mima&apos;) 如果返回 ‘1’表示验证成功， 如果是 ‘0’ 表示验证失败。 1.4.6 创建一个新的数据库，例如asGiant1use asGiant 1.4.7 接下来为asGiant库添加一个用户，并且赋予权限，1db.createUser(&#123; user: 'aaaa', pwd: 'graphql_mima', roles: [&#123; role: 'readWrite', db: 'asGiant' &#125;] &#125;) 这行代码意思是 创建一个cccc用户 给予读写权限 db表示该用户操作的数据库名。 Read：允许用户读取指定数据库 readWrite：允许用户读写指定数据库 dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile userAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户 clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。 readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限 readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限 userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限 dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。 root：只在admin数据库中可用。超级账号，超级权限 1.4.8 开启安全登录 一切搞定，重新开机mongodb，通过增加 --auth 开启安全登录 1mongod --dbpath /www/server/mongodb/data --auth 如果你是手动安装，那么需要以下操作 mongodb，MongoDB默认是没有开启访问控制，我们通过--auth参数重启mongod服务。 mongod –dbpath 存放数据库文件夹路径 –auth 1mongod --dbpath usr/local/mongodb/bin --auth 一旦开启了，用户连接mongod必须指定用户名和密码。 如果你采用的是宝塔一键完成的 可以通过修改mongodb的配置文件来实现 修改为 12345678910net: port: 27017 bindIp: 0.0.0.0 #operationProfiling:#replication:# replSetName: bt_main security: authorization: enabled javascriptEnabled: false bindIp修改为 0.0.0.0 允许外网访问 authorization 修改为 enabled 开启认证重启一下mongodb 1.5 放行端口","categories":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/categories/mongoose/"}],"tags":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/tags/mongoose/"}]},{"title":"11 限制返回结果的数量（limit）","slug":"mongoose/11 限制返回结果的数量（limit）","date":"2019-04-10T03:10:04.000Z","updated":"2019-06-08T14:42:23.000Z","comments":true,"path":"2019/04/10/mongoose/11 限制返回结果的数量（limit）/","link":"","permalink":"http://yoursite.com/2019/04/10/mongoose/11 限制返回结果的数量（limit）/","excerpt":"","text":"1this.ctx.model.Article.limit(3); 对Article表中的数据进行返回，返回为前面3条数据","categories":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/categories/mongoose/"}],"tags":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/tags/mongoose/"}]},{"title":"4 egg-mongoose 配置","slug":"mongoose/4 egg-mongoose 配置","date":"2019-04-10T03:10:04.000Z","updated":"2019-06-08T14:40:08.000Z","comments":true,"path":"2019/04/10/mongoose/4 egg-mongoose 配置/","link":"","permalink":"http://yoursite.com/2019/04/10/mongoose/4 egg-mongoose 配置/","excerpt":"","text":"4.1 安装1$ npm install egg-mongoose --save 4.2 配置 改变Egg项目中的配置文件{workplace}/config/plugin.js中来启用 egg-mongoose 插件: 1234exports.mongoose = &#123; enable: true, package: &apos;egg-mongoose&apos;,&#125;; ## 4.3 Egg连接mongoose 在Egg项目中的配置文件{workplace}/config/default.js配置项config添加属性 12345678config.mongoose = &#123; url: process.env.EGG_MONGODB_URL || 'mongodb://127.0.0.1/website', options: &#123; server: &#123; poolSize: 40, &#125;, &#125;, &#125;; 连接方法 123456config.mongoose = &#123; client: &#123; url: 'mongodb://账号:密码@服务器:端口/库名', options: &#123;&#125;, &#125;, &#125;;","categories":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/categories/mongoose/"}],"tags":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/tags/mongoose/"}]},{"title":"3 数据备份还原","slug":"mongoose/3 数据备份还原","date":"2019-04-10T03:10:04.000Z","updated":"2019-06-08T14:39:56.000Z","comments":true,"path":"2019/04/10/mongoose/3 数据备份还原/","link":"","permalink":"http://yoursite.com/2019/04/10/mongoose/3 数据备份还原/","excerpt":"","text":"当mongodb 数据库打开了 auth认证 以后 就不能直接使用 dump 而需要提供对应的账号密码 如下 1mongodump -h 127.0.0.1:27017 -d asGiant -u 'myz' -p '123456' -o /usr/local/mongodb/dump -h 地址-d 数据库名称-u 用户名-p 密码-o 输出地址–authenticationDatabase admin 验证账户的数据库 mongorestore命令脚本语法如下： 1mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt; –host &lt;:port&gt;, -h &lt;:port&gt;：MongoDB所在服务器地址，默认为： localhost:27017 –db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2 –drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！ ：mongorestore 最后的一个参数，设置备份数据所在位置，例如：/usr/local/mongodb/dump。你不能同时指定 和 –dir 选项，–dir也可以设置备份目录。 –dir：指定备份的目录你不能同时指定 和 –dir 选项。 1mongorestore -h localhost:27017 -d asGiant -c user --dir /usr/local/mongodb/dump -u myz -p 12346 mongodump -u root -p 123456 mongorestore -u root -p 123456","categories":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/categories/mongoose/"}],"tags":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/tags/mongoose/"}]},{"title":"2 工具连接","slug":"mongoose/2 工具连接","date":"2019-04-10T03:10:04.000Z","updated":"2019-06-08T14:39:46.000Z","comments":true,"path":"2019/04/10/mongoose/2 工具连接/","link":"","permalink":"http://yoursite.com/2019/04/10/mongoose/2 工具连接/","excerpt":"","text":"2.1 下载robo 3t 创建一个连接 点击test 安装完成 2.2 连接加密数据库xxx.db(&#39;mongodb://your name: your pwd@ip:27017/asgiant&#39;);your name：为用户名your pwd:为密码","categories":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/categories/mongoose/"}],"tags":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/tags/mongoose/"}]},{"title":"12 跳过前3个文档,返回其余的（skip）","slug":"mongoose/12 跳过前3个文档,返回其余的（skip）","date":"2019-04-10T03:10:04.000Z","updated":"2019-06-08T14:42:30.000Z","comments":true,"path":"2019/04/10/mongoose/12 跳过前3个文档,返回其余的（skip）/","link":"","permalink":"http://yoursite.com/2019/04/10/mongoose/12 跳过前3个文档,返回其余的（skip）/","excerpt":"","text":"1this.ctx.model.Article.skip(3); 对Article表中的数据进行返回，跳过前面3条数据，返回其余数据 附：综合使用最后三个方法进行分页查询 1this.ctx.model.Article.find(&#123; _id：5c4a819fb87ba4002a47bc4f &#125;).skip(pageSize * (pageNum - 1)).limit(parseInt(pageSize)).sort(&#123; isSetTop: -1, sort: 1, editTime: -1 &#125;); 其中pageSize和pageNum为动态传递数据，返回Article表中特定_id在每页数据为pageSize条件下的第pageNum页中的数据，并按照“isSetTop”降序，再按“sort”升序，最后按“editTime”降序进行排序。","categories":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/categories/mongoose/"}],"tags":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/tags/mongoose/"}]},{"title":"6 增加数据","slug":"mongoose/6 增加数据","date":"2019-04-10T03:10:04.000Z","updated":"2019-06-08T14:40:35.000Z","comments":true,"path":"2019/04/10/mongoose/6 增加数据/","link":"","permalink":"http://yoursite.com/2019/04/10/mongoose/6 增加数据/","excerpt":"","text":"1this.ctx.model.Article.create(post,callback); 备注：其中post为json数据结构，callback为操作后的回调函数","categories":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/categories/mongoose/"}],"tags":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/tags/mongoose/"}]},{"title":"10 排序（sort）","slug":"mongoose/10 排序（sort）","date":"2019-04-10T03:10:04.000Z","updated":"2019-06-08T14:42:00.000Z","comments":true,"path":"2019/04/10/mongoose/10 排序（sort）/","link":"","permalink":"http://yoursite.com/2019/04/10/mongoose/10 排序（sort）/","excerpt":"","text":"1this.ctx.model.Article.sort(&#123; isSetTop: -1, sort: 1, editTime: -1 &#125;); 对Article表中的数据进行排序，先按“isSetTop”降序，再按“sort”升序，最后按“editTime”降序 备注：键对应数据中的键名，值代表排序方向，1 升序, -1降序。","categories":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/categories/mongoose/"}],"tags":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/tags/mongoose/"}]},{"title":"8 删除数据","slug":"mongoose/8 删除数据","date":"2019-04-10T03:10:04.000Z","updated":"2019-06-08T14:41:06.000Z","comments":true,"path":"2019/04/10/mongoose/8 删除数据/","link":"","permalink":"http://yoursite.com/2019/04/10/mongoose/8 删除数据/","excerpt":"","text":"1this.ctx.model.Article.remove(conditions,callback); 备注：conditions为查询条件，与查询数据介绍的一样，eg：{ _id：5c4a819fb87ba4002a47bc4f }，找到_id为5c4a819fb87ba4002a47bc4f的数据，callback为操作成功后的回调函数","categories":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/categories/mongoose/"}],"tags":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/tags/mongoose/"}]},{"title":"9 更新数据","slug":"mongoose/9 更新数据","date":"2019-04-10T03:10:04.000Z","updated":"2019-06-08T14:41:51.000Z","comments":true,"path":"2019/04/10/mongoose/9 更新数据/","link":"","permalink":"http://yoursite.com/2019/04/10/mongoose/9 更新数据/","excerpt":"","text":"9.1 更新数据1this.ctx.model.Article.update(conditions, update, callback) 参数1:查询条件, 参数2:更新对象,可以使用MondoDB的更新修改器 备注：conditions与查询数据中介绍的一样 9.2 update为更新对象12345678let post = &#123; wid: '5c492c57acbe363fd4824446', column: [ '新闻' ], titleHead: '', img: '', isAbstract: 'false',&#125;this.ctx.model.Article.update(&#123; _id: '5c4a819fb87ba4002a47bc4f ' &#125;, post) 查询Article表中特定_id，并对post中所包含的属性进行更新。 update使用MondoDB的更新修改器，有以下几种使用场景 9.2.1 “$inc”增减修改器,只对数字有效1this.ctx.model.Article.update(&#123;\"age\":22&#125;, &#123;$inc:&#123;\"age\":1&#125; &#125; ); 找到age=22的文档,修改文档的age值自增1 9.2.2 ‘$set’ 指定一个键的值,这个键不存在就创建它.可以是任何MondoDB支持的类型.1this.ctx.model.Article.update(&#123; _id：5c4a819fb87ba4002a47bc4f &#125;, &#123; $set: &#123; isDelete: true &#125; &#125;); 对5c4a819fb87ba4002a47bc4f 表进行软删除，找到特定_id数据，增加或者修改isDelete属性 9.2.3 “$unset”同上取反,删除一个键1this.ctx.model.Article.update(&#123;age:22&#125;, &#123;$unset:&#123;age:18&#125; &#125; ); 执行后age键不存在 9.2.4 ‘$push’给一个键push一个数组成员,键不存在会创建,对数组有效1this.ctx.model.Article.update(&#123;name:'wxw'&#125;, &#123;$push:&#123;array:10&#125; &#125; ); 返回Article表中name为wxw的数据，增加一个array键,类型为数组,有一个成员 10 9.2.5 ‘$addToSet’向数组中添加一个元素,如果存在就不添加1this.ctx.model.Article.update(&#123;name:'wxw'&#125;,&#123;$addToSet:&#123;array:10&#125; &#125; ); 返回Article表中name为wxw的数据，array中有10所以不会添加 9.2.6 ‘$each’遍历数组和 $push 修改器配合可以插入多个值1this.ctx.model.Article.update(&#123;name:'wxw'&#125;, &#123;$push:&#123;array:&#123;$each: [1,2,3,4,5]&#125;&#125; &#125; ); 返回Article表中name为wxw的数据，执行后array : [10,1,2,3,4,5] 9.2.7 ‘$pop’ 向数组中尾部删除一个元素1this.ctx.model.Article.update(&#123;name:'wxw'&#125;, &#123;$pop:&#123;array:1&#125; &#125; ); 返回Article表中name为wxw的数据，其中array : [10,1,2,3,4,5]，执行后 array : [10,1,2,3,4] tip:将1改成-1可以删除数组首部元素 9.2.8 ‘$pull’ 向数组中删除指定元素1this.ctx.model.Article.update(&#123;name:'wxw'&#125;, &#123;$pull:&#123;array:10&#125; &#125;); 返回Article表中name为wxw的数据，匹配到array中的10后将其删除。","categories":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/categories/mongoose/"}],"tags":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/tags/mongoose/"}]},{"title":"7 查询数据","slug":"mongoose/7 查询数据","date":"2019-04-10T03:10:04.000Z","updated":"2019-06-08T14:40:52.000Z","comments":true,"path":"2019/04/10/mongoose/7 查询数据/","link":"","permalink":"http://yoursite.com/2019/04/10/mongoose/7 查询数据/","excerpt":"","text":"7.1 获取所有数据，返回是一个数组1this.ctx.model.Article.find() 7.2 获取一个数据，返回是一个对象1this.ctx.model.Article.findOne() ### 7.3 条件查询1this.ctx.model.Article.find(conditions,callback); condition有以下几种类型 7.3.1 根据具体数据进行查询1this.ctx.model.Article.find(&#123;_id：5c4a819fb87ba4002a47bc4f,title:\"123\"&#125;,callback); 返回_id为5c4a819fb87ba4002a47bc4f，title为123的结果 7.3.2 条件查询 “$lt” 小于 “$lte” 小于等于 “$gt” 大于 “$gte” 大于等于 “$ne” 不等于 1this.ctx.model.Article.find(&#123;“sort”:&#123; $get:18 , $lte:30 &#125;); 返回Article表中sort 大于等于18并小于等于30的结果 7.3.3 或查询 OR “$in” 一个键对应多个值 “$nin” 同上取反, 一个键不对应指定值 “$or” 多个条件匹配, 可以嵌套 $in 使用 “$not” 同上取反, 查询与特定模式不匹配的文档 1this.ctx.model.Article.find(&#123;\"title\":&#123; $in:[20,21,22.\"haha\"]&#125; ); 返回Article表中title等于20或21或21或”haha”的结果 1this.ctx.model.Article.find(&#123;\"$or\" : [ &#123;\"age\":18&#125; , &#123;\"name\":\"wxw\"&#125; ] &#125;); 返回Article表中age等于18或 name等于”wxw”的结果 7.3.4 类型查询（”$exists”条件判定）123this.ctx.model.Article.find(&#123;name: &#123;$exists: true&#125;&#125;,function(error,docs)&#123; //返回Article表中所有存在name属性的结果&#125;); 123this.ctx.model.Article.find(&#123;telephone: &#123;$exists: false&#125;&#125;,function(error,docs)&#123; //返回Article表中所有不存在telephone属性的结果&#125;); 7.3.5 匹配正则表达式查询MongoDb 是使用 Prel兼容的正则表达式库来匹配正则表达式 1this.ctx.model.Article.find( &#123;\"name\" : /joe/i &#125; ); 返回Article表中name为 joe 的结果, 并忽略大小写 7.3.6 查询数组1this.ctx.model.Article.find(&#123;\"array\":10&#125; ); 返回Article表中array(数组类型)键中有10的文档, array : [1,2,3,4,5,10] 会匹配到 1this.ctx.model.Article.find(&#123;\"array[5]\":10&#125; ); 返回Article表中array(数组类型)键中下标5对应的值是10, array : [1,2,3,4,5,10] 会匹配到 1this.ctx.model.Article.find(&#123;\"array\":[5,10]&#125;); 返回Article表中查询匹配array数组中既有5又有10的结果 1this.ctx.model.Article.find(&#123;\"array\":&#123;$size : 3&#125; &#125;); 返回Article表中查询匹配array数组长度为3 的的结果 1this.ctx.model.Article.find(&#123;\"array\":&#123;$slice : 10&#125; &#125;); 返回Article表中查询匹配array数组的前10个元素 1this.ctx.model.Article.find(&#123;\"array\":&#123;$slice : [5,10]&#125; &#125;); 返回Article表中查询匹配array数组的第5个到第10个元素 7.3.7 where用它可以执行任意javacript语句作为查询的一部分,如果回调函数返回 true 文档就作为结果的一部分返回 12this.ctx.model.Article.find( &#123;\"$where\" : \"this.x + this.y === 10\" &#125; );this.ctx.model.Article.find( &#123;\"$where\" : \" function()&#123; return this.x + this.y ===10; &#125; \" &#125; ) 其中this为数据表中的数据，上述返回Article表中属性x+属性y=10的所有数据","categories":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/categories/mongoose/"}],"tags":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/tags/mongoose/"}]},{"title":"5 设计数据库模型","slug":"mongoose/5 设计数据库模型","date":"2019-04-10T03:10:04.000Z","updated":"2019-06-08T14:40:26.000Z","comments":true,"path":"2019/04/10/mongoose/5 设计数据库模型/","link":"","permalink":"http://yoursite.com/2019/04/10/mongoose/5 设计数据库模型/","excerpt":"","text":"5.1 定义模型，也就是数据表 在{workplace}/app/model/article.js定义数据表 123456789101112131415161718192021222324'use strict';module.exports = app =&gt; &#123; const mongoose = app.mongoose; const Schema = mongoose.Schema; const RoleSchema = new Schema(&#123; role: &#123; type: String, index: &#123; unique: true, &#125;, // 该字段为唯一字段 require: true, // 必填项 &#125;, roleName: &#123; type: String, require: true, &#125;, // 备注 note: &#123; type: String, require: true, &#125;, &#125;); return mongoose.model('Role', RoleSchema, 'role');&#125;; 5.2 数据类型 数据类型 Number 数字 String 字符串 Boolean 布尔值 ObjectId 对象ID Array 数组 Date 日期 Buffer 二进制 Mixed 混合类型","categories":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/categories/mongoose/"}],"tags":[{"name":"mongoose","slug":"mongoose","permalink":"http://yoursite.com/tags/mongoose/"}]},{"title":"7.Math的常用方法","slug":"JavaScript基础入门/7 Math的常用方法","date":"2019-04-10T03:10:04.000Z","updated":"2019-06-06T15:42:55.000Z","comments":true,"path":"2019/04/10/JavaScript基础入门/7 Math的常用方法/","link":"","permalink":"http://yoursite.com/2019/04/10/JavaScript基础入门/7 Math的常用方法/","excerpt":"","text":"数学函数 但是他是对象数据类型的 ‘object’ Math对象中给我们提供了很多常用操作数字的方法 console.dir(Math) // 查看所有方法 abs Math.abs 取绝对值 cell / floor cell: 向上取整floor: 向下取整 round round: 四舍五入 random random: 获取一个[0,1]之间的一个随机小数 max/minx max 获取一组值中的最大值minx 获取一组值中的最小值 PI Math.PI 获取圆周率 pow / sqrt pow 获取一个值的多少幂sqrt 获取一个值的开平方","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"6.JS的DOM获取节点","slug":"JavaScript基础入门/6 JS的DOM获取节点","date":"2019-04-09T09:10:04.000Z","updated":"2019-06-06T15:40:50.000Z","comments":true,"path":"2019/04/09/JavaScript基础入门/6 JS的DOM获取节点/","link":"","permalink":"http://yoursite.com/2019/04/09/JavaScript基础入门/6 JS的DOM获取节点/","excerpt":"","text":"DOM:document object model 文档对象模型，提供一些属性和方法可以让我们去操作DOM元素 节点介绍 node 节点，浏览器默认在一个html页面中的所有内容都是节点(包括标签、注解、文字文本等) 元素节点:HTML标签 文本节点:文字内容(大部分浏览器会把空格和换行也当做文本节点) 注解节点 document文档节点 元素节点 nodeType:1 属性含有某个节点的名称 nodeName: 大写标签名(在部分浏览器的怪异模式下，我们写的标签名是小写，它获取的就是小写…) 对于元素节点，因为本身不直接包含文本，所以nodeValue是不可用的。当然你也可以在示例中自己写试试看有什么结果出现。 对于文本节点，nodeValue=文本值 对于属性节点，nodeValue=属性值 nodeValue:null 对于元素节点，nodeType=1 对于文本节点，nodeType=3 对于属性节点，nodeType=2 对于注释元素，nodeType=8 对于文档元素，nodeType=9 [curEle].tagName:获取当前元素的标签名(获取的标签名一般都是大写) 文本节点 nodeType:3nodeName:#textnodeValue:文本内容 注释节点 nodeType:8nodeName:#commentnodeValue:注释内容 文档节点 nodeType:9nodeName:#documentnodeValue:null 1234567891011&lt;-- div#box&gt;(ul&gt;li&#123;0$&#125;*3)+div&#123;内容$&#125;*3--&gt;&lt;div id=\"box\"&gt; &lt;ul&gt; &lt;li&gt;01&lt;/li&gt; &lt;li&gt;02&lt;/li&gt; &lt;li&gt;03&lt;/li&gt; &lt;/ul&gt; &lt;div&gt;内容1&lt;/div&gt; &lt;div&gt;内容2&lt;/div&gt; &lt;div&gt;内容3&lt;/div&gt; &lt;/div&gt; 获取dom元素document.getElementById 一个元素 此方法的上下文只能document 一个html页面中元素的id理论上是不能重复的,如果页面中ID重复了，我们获得结果第一个id对应的元素对象 在ie7更低的版本浏览器中，会把表单元素的name值当做id来识别使用(项目中尽量不要让表单的name和其他元素的id相同) 如果我们把js放在结构的下面，我们可以直接使用id值获取这个元素(不需要通过getElementById获取)，而且这种方式会把页面中所有id是他的元素都获取到(元素对象，或者集合) =&gt; 不推荐 1234&lt;div id=\"box1\"&gt;&lt;/div&gt;&lt;div id=\"box2\"&gt;&lt;/div&gt;&lt;div id=\"box1\"&gt;&lt;/div&gt;&lt;script&gt; console.log(box1) // -&gt; [div#box1, div#box1, box1: div#box1]&lt;/script&gt; 1234&lt;input id=\"myInput\" type=\"text\" size=\"20\"/&gt;&lt;br /&gt;&lt;script&gt; var x=document.getElementsByName(\"myInput\");&lt;/script&gt; document.getElementClassName 元素集合 上下文是可以自己来指定 获取到的结果是一个元素集合(类数组集合) 获取的结果是集合，哪怕集合中只有一项，我们想要操作的是这一项(元素对象)，需要先从集合中获取出来，然后再操作 但是真实的项目中我们经常会通过样式类名获取元素，getElementClassName这个方法在ie6-8不兼容的 1234567&lt;input name=\"myInput\" type=\"text\" size=\"20\"/&gt;&lt;br /&gt;&lt;script&gt; var x=document.getElementsByName(\"input\");&lt;/script&gt;var bodyBox = document.getElementsByTagName('body');bodyBox[0].getElementsByTagName('div'); document.getElementsTagName 元素集合1234&lt;input name=\"myInput\" type=\"text\" size=\"20\"/&gt;&lt;br /&gt;&lt;script&gt; var x=document.getElementsByName(\"input\");&lt;/script&gt; document.getElementsByName 节点集合 通过元素的NAME属性值获取一组元素（类数组：节点集合NodeList）他的上下文只能是document IE浏览器只能识别表单元素的name属性值，所以我们这个方法一般都用来操作表单元素的 获取html获得body的元素对象1234&lt;input name=\"myInput\" type=\"text\" size=\"20\"/&gt;&lt;br /&gt;&lt;script&gt; var x=document.getElementsByName(\"myInput\");&lt;/script&gt; domcument.domcumentElement 获取整个html的对象123document.documentElement.clientWidth||document.body.clientWidth// 获取当前浏览器可视区域的宽度(当前页面一个屏幕的宽度)// =&gt;clientHieght 获取高度 domcument.body 获取body对象domcument.head 获取整个head对象[context]querySelector 一个元素对象 / [context]querySelectorAll 获取元素集合 ie6-8不兼容，而且没有特别好的办法处理他的兼容，所以这两个方法一般多用于移动端开发使用 querySelector 获取一个元素对象querySelectorAll 获取的一个元素集合只要css支持的选择器，这里大部分都支持 12345document.querySelector('#box1');document.querySelectorAll('.box1');document.querySelectorAll('div');document.querySelectorAll('body&gt;div');document.querySelectorAll('#box1 li'); 节点关系属性 节点是用来描述页面中每一部门之间关系的,只要我可以获取页面中的一个页面，那么我就可以通过相关的属性和方法获取页面中所有的节点 childNodes 获取当前元素所有的子节点(节点集合:类数组)注:不仅仅是元素子节点，文本、注释等都会包含在内:子节点说明只是在儿子辈分中查找 children 获取所有的元素子节点(元素集合)在IE6-8下获取的结果和标准浏览器中有区别(IE6-8中会把注释点当做元素节点获取到) pareNode 获取当前元素的父节点(元素对象) previousibing 获取当前节点的上一个各个节点上一个哥哥节点(不一定是元素节点也可能是文本或者注释) nextibling 获取当前节点的下一个弟弟节点 previousElementbling 获取当前节点的上一个哥哥元素节点 nextElementsIbling 获取当前节点下一个弟弟元素节点IE6-8不兼容 firstChild 当前元素所有子节点中的第一个(也不一定是元素节点，可能是文本和注释) lastChild 当前元素多有子节点中的最后一个fistElementChild lastElementChild(IE6-8兼容) 创建和增加DOM元素 真实项目中，我们偶尔会在js中动态创建html标签，然后把其增加到页面中 document.createElement 在js中动态创建一个html标签 appendChild 容器.appendChild(新元素)把当前创建的新元素添加到容器的末尾位置 inserBefore 容器.inserBefore(新元素、老元素)在当前容器中，把新创建的元素增加到老元素之前 12345678// 创建var oDiv = document.createElement('div');oDiv.id='div1';oDiv.className = 'box';// 添加到页面中document.body.appendChild(oDiv);document.body.inserBefore(oDiv,box2); 123456789var link = document.createElement('a');link.href = 'http://www.baidu.com?name=1&amp;age=2#haha'consloe.dir(link);// hash:存储饿哈希值 '#haha'// hostname:域名 'www.baidu.com'// pathname:路径 '/stu/'// protocol:协议 'http:'// search:问号传递参数值 '?nname=1&amp;age=2' 真实项目中很多需要通过动态创建元素来完成的，其中有一个需求:解析一个url地址每一部分的信息(包括问号传值的参数值) 纯字符串拆分截取 编写强大的正则，捕获到需要的结果 通过动态创建一个a标签，利用a标签的一些内置属性来分别获取每一部分的内容 12345678910111213141516function queryURLParameter(url)&#123; var link = document.createElement('a'); link.href=url; var search = link.search, obj = &#123;&#125;' if(search.length===0) return; search = search.substr(1).split(/&amp;|=/g); for(var i=0;i&lt;search.length;i+=2)&#123; var key = search[i], value = search[i+1]; obj[key]=value; &#125; link = null; return obj;&#125; 修改删除克隆DOM元素removeChild 容器.removeChild(元素) 在当前容器中把每一个元素移出掉 replaceChild 容器.removeChild(新元素，老元素) 把原有的元素克隆一份一模一样的，false:只克隆当前元素本身，true:深度克隆，吧当前元素本身以及元素的所有后代都进行克隆[set/get/remove]Attribute 1234给当前元素设置/获取/移出属性的(一般操作的都是它的自定义属性)box.setAttribute('myIndex',0)box.getAttribute('myIndex')box.removeAttribute('myIndex') 使用xxx.index=0 和xxx.setAttribute(‘index’,0)这两种设置自定义属性的区别 xxx.index : 是吧当前操作的元素当做一个普通对象，为其设置一个属性名xxx.setAttribute:把元素当做特殊的元素对象来处理，设置的自定义属性是和页面结构中的DOM元素映射在一起的 JS中获取的元素对象，我们可以把他理解为两种角色: 与页面HTML结构无关的普通对象 与页面HTML结构存在映射关系的元素对象 元素对象中的内置属性，大部分都和页面的标签存在映射关系:xxx.style.backgroundColor = ‘xxx’ 此时不仅把js中对象对应的属性值改变了，而且也会映射到页面的html标签上(标签中有一个style行内样式，元素的样式改变了)xxx.className = ‘xxx’此时不仅是吧js对象中的属性值改变了，而且页面中的标签增加了class样式类(可以看见的) 元素对象中的自定义属性: xxx.index=0仅仅是吧js对象中增加了一个属性名(自定义的)，和页面中的html没啥关系(在结构上看不见) xxx.setAttribute:通过这种方式设置的自定义属性和之前提到的内置属性差不多，都是和html结构存在映射关系的(设置的自定属性可以呈现在结构上) 6.6 面试题 把当前页面中所有id叫做box1的都获取到 1234567var allList = document.getElementsByTagName(*);var result = []for(var i=0;i&lt;allList.length;i++)&#123; var item = allList[i]; item.id === 'box1'?result.push(item)&#125;console.log(result) 获取当前元素的上一个哥哥元素节点(兼容所有的浏览器)curEle:current element 123456789101112131415161718// 首先获取当前元素的上一个哥哥节点，判断当前获取的节点是否为元素节点(nodeType===1)// 如果不是基于当前获取的节点，找他的上一个哥哥节点..(找几次不知道)一直到找到的节点是元素节点为止// 如果在查找过程中，发现没有上一个哥哥节点，找到头了，则不再继续查找function prev(curEle)&#123; var p = curEle.previousSibling; // 属性返回同一树层级中指定节点的前一个节点。 while(p&amp;&amp;p.nodeType!==1)&#123; //p:p!=null p = p.previousSibling; &#125; return p;&#125;// 扩展// next: 获取下一个弟弟元素节点// prevAll:获取所有的哥哥元素节点// nextAll:获取所有的弟弟元素节点// siblings:获取所有的兄弟元素节点// index:获取当前元素的兄弟中排名索引","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"4.JS数据类型","slug":"JavaScript基础入门/4 JS数据类型","date":"2019-04-09T08:10:04.000Z","updated":"2019-06-06T15:33:16.000Z","comments":true,"path":"2019/04/09/JavaScript基础入门/4 JS数据类型/","link":"","permalink":"http://yoursite.com/2019/04/09/JavaScript基础入门/4 JS数据类型/","excerpt":"","text":"数据类型基本数据类型（值类型） Number 数字 String 字符串 单引号包裹起来的都是字符串(单双号没有区别) Boolean 布尔 true false =&gt; 布尔值只有两个值 null 空对象指针 undefined 未定义 引用数据类型 {} 普通对象 [] 数组 /^$/ 正则 … function数据类型 funciotn fn (){} 数据类型检查 typeof 用来检测数据类型的运算符 instanceod 检测某个实例是否属于这个类 constructor 获取当前实例的构造器 Object prototype.toSting.call() 获取当前实例的所属类信息 typeof操作符typeof 是用来检测给定变量的数据类型的操作符。对一个值使用 typeof 操作符可能返回下列某个字符串： 12345\"undefined\"\"boolean\"\"string\"\"number\"\"object\" // 如果这个值是对象或者null \"function\" 布尔值 Boolean() 把其他数据类型的值转化为布尔类型 只有0、Nan、null、undefined这五个数据值转换为布尔类型的false，其余的都会变成true 叹号在JS中海油一个作用：取反，先把值转换为布尔类型，然后再去取反 !! 在叹号取反的基础上取反，取反两次相当于没有操作，但是却已经其他类型值转化为布尔类型了，和Boolean是相同的效果 字符串 在JS中单引号和双引号包起来的都是字符串 12312 - &gt; number'12' -&gt; string'[12,23]' -&gt; string toString()第一种是使用几乎每个值都有的 toString()方法。多数情况下，调用 toString() 方法不必传递参数，但在调用数值的 toString()方法时，可以传递一个参数：输出数值的基数。默认情况下，toString() 方法以十进制格式返回数值的字符串表示。而通过传递基数，toString() 可以输出二进制、八进制、十六进制等。 123456var num = 10;alert(num.toString()); // \"10\"alert(num.toString(2)); // \"1010\"alert(num.toString(8)); // \"12\"alert(num.toString(10)); // \"10\"alert(num.toString(16)); // \"A\" 常用方法 number数字 0 12-22 12.5 js中多增加了一个number类型的数据NaN typeof NaN -&gt; Number 12345var intNum = 55; // 十进制整数 var octalNum1 = 070; // 八进制的56var octalNum1 = 079; // 无效的八进制数值——解析为79 var octalNum1 = 08; // 无效的八进制数值——解析为8 var hexNum1 = 0xA; // 十六进制的10var hexNum2 = 0x1F; // 十六进制的31 注意，八进制字面量在严格模式下是无效的，会导致抛出错误。 数值范围ECMAScript 能够表示的最小数值保存在 Number.MIN_VALUE 中——在多数浏览器中，这个值是 5e-324；能够 Number.MAX_VALUE 中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果某次计算的结果得到了一个超过JavaScript 数值范围的值，那么这个数值将会自动转换为 Infinity 值，如果这个数值是负数，则会转换成 -Infinity（负无穷），如果这个数值是正数，则会转换成Infinity（正无穷）。要确定一个数值是不是有穷的，可以使用 isFinite() 函数。 NaN not a numer : 不是一个数，但是属于number类型 NaN == NaN ： false , NaN 和任何其他值都不相等 isNaN() 用来检测当前这个值是否是非有效数字，如果不是有效数字，检测的结果是true , 反之是有效数字则为false 12isNaN(0) // -&gt;falseisNaN(NaN) // -&gt;true 当我们使用isNaN检测值的时候，检测的值不是number类型的，浏览器默认的吧值先转换为number类型，任何再去检测 1isNaN('12') //-&gt;false Number() 把其他数据类型值转化成number类型的值 12345678Number('12') // -&gt; 12Number('12px') // -&gt;NaN// 在使用Number转换的时候只要字符串中出现任何一个非有效数字字符，最后的结果都是NaNNumber(true) //-&gt; 1 Number(false) //-&gt; 0Number(null) // -&gt; 0Number(undefined) //-&gt;NaN 把引用数据类型转换成number，首先需要吧引用数据类型转为字符串（toString)，在把字符串转换为number即可 12345Number([]) // -&gt; \"\"Number([12]) // -&gt; 12Number([12,13]) // -&gt; 12,13 (,是非有效字符) -&gt; NaNNumber(&#123;age:12&#125;) // -&gt;NaNNumber(&#123;&#125;) // -&gt; NaN pareInt 也是吧其他数据类型值转换为number，和Number方法在处理字符串的时候有所区别 12Number('12px') // -&gt; NaNparseInt('12px') // -&gt; 12 提取规则：从左到右依次查找有效数字字符，知道遇到非有效数字字符为止（不管后端是否还有，都不找了） 1parseInt('12px13') // -&gt; 12 数值转换处理整数最常用的还是 parseInt() ，它会忽略字符前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt() 就会返回 NaN；也就是说，用 parseInt() 转换空字符串会返回 NaN 。如果第一个字符是数字字符， parseInt() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。如果字符以“0x”开头且后面跟数字字符，会被解析为 16 进制整数；以“0”开头且后面跟数字字符，会被解析为 8 进制整数。下面给出一些例子： 123456var num1 = parseInt(\"1234blue\"); // 1234var num2 = parseInt(\"\"); // NaNvar num3 = parseInt(\"0xA\"); // 10(十六进制)var num4 = parseInt(22.5); // 22var num5 = parseInt(\"70\"); // 70var num6 = parseInt(\"0xf\"); // 15(十六进制) pareFloat 在pareInt的基础上可以识别小数点 12pareInt('12.5px') -&gt; 12pareFloat('12.5px') -&gt; 12.5 null 和undefined null : 空，没有 undefined ：未定义，没有 “” : 空字符串，没有 0: 也可以理解为没有 空字符串和null的区别 都是去去种树 空字符串属于去挖了个坑，但是没有种任何东西 null属于连坑都没挖 空字符串相对于null来说开辟了内存地址，消耗了那么一丢丢的性能 null和undefined的区别 null一般都是暂时没有，预期中以后会有的(可能以后也没有达到预期)，在js中null都是手动先赋值为null，后期我们在给其赋具体值 undefined:完全没有预料之内的 Object 对象 ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性和（或）方法，就可以创建自定义对象，如下所示： 1var o = new Object(); 每一个对象都是由零到多组 属性名（key键）：属性值(value值) 组成的,或者说有多组键值对组成的，每一组键值对中间用逗号分隔 属性 描述这个对象特点特征的 1var obj =&#123;name:'wjw',age:8&#125;; 获取 某个属性名对应的属性值或者数字格式的 12obj.nameobj['name'] 存储 属性值可以是任何数据类型 对象名.属性名：忽略属性名的单双引号 对象名[属性名]：不能忽略单双引号 123// 如果属性名是数字如何操作obj.0 语法不支持obj[0] / obj['0'] 两种都支持 如果操作的属性名在对象中不存在，获取的结果是undefined 1obj.sex // -&gt;undefined 设置/修改 一个对象的属性名是不能重复的（唯一性），如果之前存在就是修改属性值的操作，反之不存在就是新的设置属性的操作 12obj.sex = '男';obj['age'] = 9; 删除假删除:让其属性赋值为null，但是属性还是对象1obj.sex = null; 真删除:把整个属性都在对象中暴力移出1delete obj.sex 基本数据类型 和 引用数据类型的区别 JS是运行在浏览器中的(内核引擎)，浏览器会为JS提供赖以生存的环境（提供给js代码执行的环境）=&gt; 全局作用域window(global) 123456789var a = 12;var b = a; // 把A变量存储的值赋值给Bb = 13;console.log(a);var n =&#123;name:'wjh'&#125;;var m = n;m.name = 'wjw'console.log(n.name) 基本数据类型是按值操作的：基本数据类型的赋值的时候，是直接把值赋值给变量即可 引用数据类型是按照空间地址（引用地址）来操作的: var n = {name:’wjw’} 先创建一个变量n 浏览器首先会吧开辟一个新的存储控件（内存控件），目的是吧对象中需要存储的内容（键值对）分别的存储在这个空间中，为了方便后期找到这个空间，浏览器给空间设定一个地址（16进制） 把空间的地址赋值给了变量 4.9 function数据类型 函数数据类型也要按照引用地址来操作的 函数:具备一定功能的方法 123456// =&gt; 创建函数:function 函数名()&#123; //=&gt; 函数体:实现某一个功能的具体JS代码&#125;// =&gt; 执行函数:相当于使用洗衣机洗衣服(如果函数只创建了，但是没有去执行，函数没有任何的意义)// 函数名() 12345function fn()&#123; console.log(1+1);&#125;fn; // =&gt; 输出函数本身fn(); // =&gt; 把函数执行（吧函数体重实现功能的代码执行） 形参：形式参数(变量)，函数的入口当我们创建一个函数想要实现个功能的时候，发现有一些材料不清楚，只有当函数运行的时候，别人传递给我，我才知道，此时我们就需要设定入口,让用户执行的时候通过入口把值把我们 123456function fn(num1,num2)&#123; console.log(num1+num2)&#125;// 实参:函数执行传递给函数的具体值就是实参fn(1,2);fn(10,20); 数据类型转换把其他数据类型转换为number类型-&gt; isNaN、Number、pareInt、parseFloat-&gt; 在进行数据加减乘除数学运算的时候 1234567891011// true -&gt; 1 false-&gt;0// ''-&gt;0 '12'-&gt;12 '12px'-&gt;NaN/12// '小伙子'-&gt;NaN// null -&gt; 0 // undefined-&gt; NaN&#123;&#125; /^$/ function() -&gt;NaN[][12]-&gt;'12'-&gt;12['12,13']-&gt;'12,23'-&gt;NaN// =&gt; 引用数据类型转换为数字// 通过toString方法把数组转换为字符串，然后在调用Number转换为数字 JS中的数据运算 +、-、*、/加减乘除 除了加法有特殊性，其余的运算符都是数学运算，也是遇到非数字类型，需要把其转换为number再运算 12341-&apos;1&apos; -&gt; 010*null -&gt; 010/undefined -&gt; NaN10*[10]-&gt;100 加法的特殊性: 在遇到字符串的时候，+不是数学运算，而是字符串拼接，只要不遇到字符串就是数学运算 121+&apos;1&apos; -&gt; &apos;11&apos;null+&apos;1&apos; -&gt; ‘null1’ 字符串拼接:是把其它的值转换为字符串然后再拼接(toString) 其它数据类型的toString是直接的把值用单(双)引号包起来极客，只有对象的特殊性，对象的有特殊性，对象.toStirng===’[Object Object] 将其它数据类型转换为布尔类型 Boolean、！、！！ 在条件判断的时候、也是转换为布尔类型，然后验证条件的真假 只有0、NaN、空字符串、null、undefined五个转换为false、其余的都是转换为true 12345678910111213[] -&gt; true-1 -&gt; trueif(box)&#123; // =&gt; 首先把box变量存储的值获取到，转化为布尔类型，如果为true条件成立，反之不成立&#125;if(3+&apos;3px&apos;)&#123; // 条件成立: 3 + &apos;3px&apos; = &apos;33px&apos; &#125;if(3-&apos;3px&apos;)&#123; // 条件不成立: 3-&apos;3px&apos; = NaN&#125; 在使用==进行比较的时候 在使用==进行比较的时候，如果左右两边的数据不相同，浏览器默认转换为相同的类型，然后在比较(‘===’不会这样操作) 12345// 对象和对象: 应用数据类型比较的空间地址不一样，不是一个空间[] == [] -&gt; falsevar a =&#123;&#125;var b = a;a==b -&gt; true 对象和数字:吧对象转换成数字123[]== 0 -&gt; true(&#123;&#125;)=== NaN -&gt; falseNaN和自己不相等和其它任何值都不相等 对象和字符串:把两边都转换为数字比较的1[]===&apos;&apos; -&gt; true 对象和布尔值:把两边都转换成数字1234[]==true -&gt; 0==1 -&gt;false[]==false -&gt; 0==0 -&gt;true![]==false -&gt; ![] -&gt;把数组变成为布尔在取反=falsefalse=false -&gt; true 字符串和数字:字符串转换为数字字符串和布尔:都转为数字布尔和数字:布尔转换为数字 规律:两个等于号比较，左右两边数字值的类型不一样，浏览器会吧两边的类型都转换为数字然后再比较，但是null和undefined除外null==undefined -&gt; truenull===undefined -&gt; falsenull 和 undefined 和其它任何都不相等null==0 -&gt; false null以及undefined和其它任何值都不相等","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"5.JS中常见的操作的语句","slug":"JavaScript基础入门/5 JS中常见的操作的语句","date":"2019-04-09T08:10:04.000Z","updated":"2019-06-06T15:36:09.000Z","comments":true,"path":"2019/04/09/JavaScript基础入门/5 JS中常见的操作的语句/","link":"","permalink":"http://yoursite.com/2019/04/09/JavaScript基础入门/5 JS中常见的操作的语句/","excerpt":"","text":"if、else if 、else 判断操作语句 123456789if(条件1)&#123; //=&gt;条件1成立执行的操作&#125;else if(条件2)&#123; //=&gt;上面条件不成立，条件2成立，执行的操作&#125;...else&#123; // =&gt; 以上条件都不成立执行的操作&#125; 如果好几个条件都成立了，只吧第一个成立的条件执行，后面成立的条件忽略不管条件: 123456789A==B、A!=B、A&gt;B、A&lt;Bif(A)&#123;&#125; // 先把A转换为布尔类型，判断真假以此来决定是否成立//否成立if(A&gt;B&amp;&amp;A&lt;10)&#123;&#125; //只有两个小条件都是真，整体条件为真if(A&gt;B||A&lt;10)&#123;&#125; // 只要其中一个小条件成立，整体条件是真 BAT 面试题 12345678910var num = parseFloat('width:12.5px');if(num==12.5)&#123; // =&gt;NaN alert(12.5);&#125;else if(num==NaN)&#123; // NaN!=NaN alert(NaN);&#125;else if(typeof num=='number')&#123; // alert(0)&#125;else&#123; alert(\"啥也不是\")&#125; 三元运算符 条件？条件成立执行：条件不成立执行 if(条件){}else : 三元运算符就是这种简单if..else..的另一种写法 123456789var num = 10;if(num&gt;5&amp;&amp;num&lt;10)&#123; num++;//累加1&#125;else&#123; num--;&#125;// 修改成为三元运算符,如果条件成立或者不成立的某一种情况并不需要什么处理// 我们空着语法不符合，我们使用null、undefined、void 0(就是undefined)占位就可以num&gt;5&amp;&amp;num&lt;10?num++:num--; 123456789var num = 10;if(num&gt;5 &amp;&amp; num&lt;10)&#123; num++; break;/continue;/return;&#125;// =&gt; 修改成为三元运算符// 在三元运算符的操作中不能出现break、continue、return这样的关键词，所以我们无法用三目代替if、elsenum&gt;5 &amp;&amp; num&lt;10?(num++,return):null; swith case swith case应用于if、else中一个变量在不同值情况下的不同操作 123456789101112131415var num =10;switch(num)&#123; //switch后面小括号中存放的是一个值(一般我们都写变量;把变量存储的值拿来用，有时候也可能是一个计算) case 1: // case后面放的都是值，目的验证switch后面的值和哪一种case后面的值相等，相等的进行对应的处理 ... break; // 每一种case借宿后都要加break借宿当前的判断 case 10: ... break; default: // switch后面的值和每一种case情况对应的值都不相等，执行最后的default，类似于false ...&#125; 案例分析 123456789101112var num = 5;switch(num%2)&#123;//=&gt;先把取余操作进行运算，拿运算结果case比较 case 0: num++; break; //不加break，不管后面的条件是够成立，都会继续向下执行，知道遇到break为止 // 不加break，就可以实现||这样的操作 case: 2-1: //case后面也应该是值，此处先把2-1计算，把计算的结果和switch值比较 num--; // 最后一项可以不加break，不加也能跳出判断 break;&#125;num%2:让num存储的值除以2去余数(0或者1) swich case 中的比较实用的”===” =:赋值，等号左边是变量，右边是值 ==:比较，如果左边两边的类型不一样，浏览器默认转换为一样的然后再进行比较 ‘6’==6 =&gt; 6==6 =&gt;true ===:绝对相等，不仅要求值一样，并且类型也要完全一样 循环操作语句 循环，重复做一件事情 123for(设置循环起始值；设置循环执行的条件；步长累加)&#123; // 循环体:重复做的事情都是在循环体重&#125; 设置初始值 验证条件 条件成立，执行循环体:不成立，循环借宿 步长累加 12345for(;i&lt;5;;)&#123; consloe.log(i); //没有步长累加，我们的i永远是0，循环条件永远成立“死循环”; //项目中不能出现死循环，一旦出现,循环下面的事情都做不了&#125; continue 结束本轮循环，继续执行下一轮:循环体重continue后面的代码都不会在执行，它会直接的去执行步长，然后进行下一轮 1234for(var i=0;i&lt;5;i+=2)&#123; console.log(i) continue;&#125; break 结束整个循环:循环体重一旦遇到break首先后面代码不执行了，而且步长累加也不执行了，循环都结束了 1234for(var i=0;i&lt;5;i+=2)&#123; console.log(i) break;&#125; BAT面试题 1234567891011for(var i=1;i&lt;10;i+=2)&#123; if(i&lt;5)&#123; i++; continue; &#125;else&#123; i+=3; break; &#125; console.log(i)&#125;console.log(i) // =&gt;10 for in 用来遍历(循环)对象键值对的 var key;var attr(attribute); 对象中有多少键值对，我们的for in 循环遍历多少次(多少次) 第一次循环key这个遍历存储的都是当前循环这个组键值队的属性名 key存储的值都是字符串格式的(不管属性名是否为数字) 在for in 循环的遍历时候，大部分浏览器都是先把对象中的键值对进行排序(把数字属性的排在前面，并且排列的时候安卓数字由小达大排列),其次在把非数字的属性名按照之前编写的顺序，循环的时候按照重新排列循序一次遍历(小数算作字母不要做数字) 123456789101112131415var obj = &#123;name:wjw,age:8,0:'wjh',3:'ylp',1:'cx'&#125;for(var key in obj)&#123; console.log('ok') // key 属性名 string console.log(obj.key) //获取obj中key这个属性对应的值 -&gt;undefined &lt;=&gt; obj['key'] console.log(obj[key]); //-&gt;每一次循环把key变脸存储的值(当前遍历的属性名)获取到放在中括号中，获取obj对应的属性值&#125;for(var key in obj)&#123; if(obj.hasOwnProperty(key))&#123; &#125; &#125;","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"3.JS定义值","slug":"JavaScript基础入门/3 JS定义值","date":"2019-04-09T07:10:04.000Z","updated":"2019-06-06T15:27:25.000Z","comments":true,"path":"2019/04/09/JavaScript基础入门/3 JS定义值/","link":"","permalink":"http://yoursite.com/2019/04/09/JavaScript基础入门/3 JS定义值/","excerpt":"","text":"语法ECMAScript 的语法大量借鉴了 C 及其他类 C 语言（如 Perl 和 Java）的语法。区分大小写 注释123456// 单行注释/** 这是一个多行* （块级）注释*/ 严格模式严格模式ES5 引入了严格模式的概念，在严格模式下，ES3 中的一些不确定行为将得到处理，而且队某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码：这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的JavaScript引擎切换到严格模式。在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行: 123function doSomething()&#123; \"use strict\"; //函数体&#125; 变量、常量 变量是可以变得常量是不可变的 变量 变量其实只是一个无意义的名字，它所代表的意义都是其存储的那个值 让原有的num变量存储的值修改为13（变量只能代表一值） js定义变量的方法 1234// var 变量名 = 值;var num = 12;var name = 'wjw' 常量 任何一个具体的数据都是常量，例如12是个常量 和变量累死，我们设置一个常量（也就是一个名字），给其存储一个值，但是这个存储的值不能修改 1const num = 12; JS中命名规范 JS中严格区分大小写 1234var test = 'wjw';var Test = 'wjh';console.log(test);// 输出test 遵循国际命名规则”驼峰命名法” 第一个单词首字母小写，其余每一个有意义单词首字母大写 123456789101112var studentInfo; // 学生信息// 所见即所得// 例子:/** info : information 信息* init : initlization 初始化* add/insert/create 增加插入创建* remove/rm/clear/del/delete 删除* update 修改* get/query/select : 查询获取*/ 命名的时候可以使用$、_、数字、字母，但是数字不能作为名字的第一位 123var student_info;var $xxx; //=&gt; 一般都是应用jq获得到的值var _xxx; //=&gt; 一般这样的情况代表变量是一个局或者公共的变量 JS中很多字都是有特殊含义的，我们这些词，叫做关键词；现在没有特殊含义，以后可能会作为关键的，我们叫做保留字；二关键词和保留字不可以随便用来命名；","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"2.JS常用的输出方式","slug":"JavaScript基础入门/2 JS常用的输出方式","date":"2019-04-09T06:10:04.000Z","updated":"2019-06-06T15:26:37.000Z","comments":true,"path":"2019/04/09/JavaScript基础入门/2 JS常用的输出方式/","link":"","permalink":"http://yoursite.com/2019/04/09/JavaScript基础入门/2 JS常用的输出方式/","excerpt":"","text":"弹窗输出alert 在浏览器中弹出一个提示框(提供确定按钮，点击确定弹窗消失) 使用alert弹窗信息，提示的内容最后都会转换成字符串(调用了toSring这个方法)123alert(1)alert(&#123;name:'wjw'&#125;) //=&gt; '[object Object]'alert([13,14]) //=&gt; '12,13' confirm 在alert基础上增加了让用户选择的操作(提供两个按钮:确定和取消) 当用户点击确定按钮的时候，我们接收到的结果是true，点击是取消按钮我们接受到的结果是false，此后我们可以根据结果来处理即可 12var wjw = confirm(\"are you sure\");alert(wjw); prompt 在confirm 基础上增加让用户增加输入的效果 用户点击取消按钮，我们获取到的结果是null,如果用户点击是确定按钮，我们将获取用户输入的信息 在真实的项目中，一般性会使用二次封装的弹窗，不会使用这种弹窗 123var flag = prompt(\"are you sure\");alert(flag) 控制台输出 控制台输出，方便开发调试 console 在控制台输出，优势不会转换数据类型，输出什么格式的数据都可以 1234console.log(&#123;name:'wjw'&#125;);console.dir() //比log输出更加详细一些console.table //把json数据展示成一个表格","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"1.导入JS","slug":"JavaScript基础入门/1 导入JS","date":"2019-04-09T05:10:04.000Z","updated":"2019-06-06T15:26:09.000Z","comments":true,"path":"2019/04/09/JavaScript基础入门/1 导入JS/","link":"","permalink":"http://yoursite.com/2019/04/09/JavaScript基础入门/1 导入JS/","excerpt":"","text":"三种常见导入行内导入JS(慎重：不安全)1&lt;div onclick=\"alert('hello world')\"&gt;&lt;/div&gt; 内嵌式123&lt;script&gt; alert('hello world')&lt;/script&gt; 外链式123456// 新建一个js文件&lt;script src=\"./js/demo.js\"&gt;&lt;/script&gt;// or&lt;script src=\"./js/demo.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 内嵌与外链不能同时操作 内嵌导入和外链导入不能合并在一起，如果当前是外链导入的，那么在script脚本块找那个编写的所有代码都不会被执行。 123&lt;script src=\"./js/demo.js\"&gt; alert('hello world')&lt;/script&gt; 位置编写位置 我们一般性会把css放在body的上面，把js放在body末尾(约定速成的规范) 但是如果放在了标签前面那么将如何处理? 页面加载完所有资源之后执行操作 在js中 123window.onload=function()&#123;&#125; 在jq中 12345678910$(document).ready(function()&#123;&#125;)window.addEventListener('load',function()&#123;&#125;,false);// ie8以下window.attachEvent('onreadystatechange',function()&#123;&#125;)","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"0.介绍","slug":"JavaScript基础入门/0 介绍","date":"2019-04-09T03:10:04.000Z","updated":"2019-06-06T15:21:28.000Z","comments":true,"path":"2019/04/09/JavaScript基础入门/0 介绍/","link":"","permalink":"http://yoursite.com/2019/04/09/JavaScript基础入门/0 介绍/","excerpt":"","text":"ECMAScriptECMA-262 的第 5 版是 JS 的第一个稳定版本，得到了各浏览器厂商的支持。 语法 类型 语句 关键词 保留字 操作符 对象 DOM 文档对象模型是针对 XML 但经过扩展用于 HTML 的 API 。DOM 把整个页面映射为一个多层次节点结构。HTML 或 XML 页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。document object model 文档对象模型，里面提供了一些属性和方法，可以让我们操作页面的元素 BOM 原则上讲，BOM只处理浏览器窗口和框架，但下面一些针对浏览器的 JS 扩展也被看做是BOM的一部分。browser object model 浏览器对象模型，里面提供了一些属性和方法，可以让我们操作浏览器。","categories":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/categories/JavaScript基础入门/"}],"tags":[{"name":"JavaScript基础入门","slug":"JavaScript基础入门","permalink":"http://yoursite.com/tags/JavaScript基础入门/"}]},{"title":"3. 内容编码和加密解密方法","slug":"http与ajax入门笔记/3. 内容编码和加密解密方法","date":"2019-04-08T06:10:04.000Z","updated":"2019-06-06T14:55:06.000Z","comments":true,"path":"2019/04/08/http与ajax入门笔记/3. 内容编码和加密解密方法/","link":"","permalink":"http://yoursite.com/2019/04/08/http与ajax入门笔记/3. 内容编码和加密解密方法/","excerpt":"","text":"正常的编码解码(非加密)escape/uescape 主要就是把中文汉字进行编码的(一般只有js语言支持,也经常应用于前端页面通讯时间的中文汉字编码) encodeURL/decodeURL 基本上所有的编码语言都支持 encodeURlComponent/decodeURIComponent 和第二种方法非常的累死，区别在于 需求:我们url问号传递参数的时候，我们传递的参数值还是一个url或者包含很多特殊字符，此时为了不影响住要的url，我们需要把传递的参数值进行编码，使用encodeURLComponent处理 12345678910111213let str = 'http://www.baidu.com/?', obj=&#123; name:'wjw', age:9, url:'http://www.sogou.com/?x=1' &#125;// =&gt; 把obj中的每一项属性名和属性值拼接到url的末尾(问号传参的方式)for(let key in obj)&#123; str +=`$&#123;key&#125;=$&#123;obj[key]&#125;`; // =&gt; 不能使用encodeURL必须使用encodeURlComponent,原因是encodeURL不能编码&#125;console.log(str.replace(/&amp;$/g,'')); 也可以通过加密的方法进行编码解码1、可逆转加密(一般都是团队自己玩的规则)2、不可逆加密(一般都是基于MD5加密完成的，可能会把md5加密后的结果二次加密) 12345&lt;script src='js/md5.min.js'&gt;&lt;/script&gt;&lt;script&gt; hex_md5('0000') // \"c6f057b86584942e415435ffb1fa93d4\"&lt;/script&gt;","categories":[{"name":"http与ajax入门笔记","slug":"http与ajax入门笔记","permalink":"http://yoursite.com/categories/http与ajax入门笔记/"}],"tags":[{"name":"http与ajax入门笔记","slug":"http与ajax入门笔记","permalink":"http://yoursite.com/tags/http与ajax入门笔记/"}]},{"title":"2. AJAX","slug":"http与ajax入门笔记/2. AJAX","date":"2019-04-08T05:10:04.000Z","updated":"2019-06-06T15:16:43.000Z","comments":true,"path":"2019/04/08/http与ajax入门笔记/2. AJAX/","link":"","permalink":"http://yoursite.com/2019/04/08/http与ajax入门笔记/2. AJAX/","excerpt":"","text":"什么是ajax？async javastctip and xml,异步的js和xml xml:可扩展的标记语言 作用是通过存储数据的(通过自己扩展的标记名称清晰的展示出来数据结构) ajax值所以称为异步的js和xml,主要原因是:当初最开始用ajax实现客户端和服务器端数据通信的时候，传输的数据格式一般都是xml格式的数据，我们把他们称为异步js和xml(现在一般都是基于json格式进行数据传输) 123456789101112&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;root&gt; &lt;student&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;25&lt;/age&gt; &lt;score&gt; &lt;english&gt;90&lt;/english&gt; &lt;math&gt;90&lt;/math&gt; &lt;chinese&gt;90&lt;/chinese&gt; &lt;/score&gt; &lt;/student&gt;&lt;/root&gt; 异步的js 这里的异步不是ajax只能基于异步进行请求(虽然建议都是使用异步变成)，这里的异步特指的是局部刷新 局部刷新 vs 全局刷新 在非完全前后端分离项目中，前端开发只需要完成页面的制作，并且把一些基础的人机交互效果使用js完成即可，页面中需要动态呈现内容的部分，都是交给后台开发工程师做数据绑定和基于服务器进行渲染的(服务器端渲染) [优势] 动态展示的数据在页面的原代码中可以看见，有利于seo优化推广(有利于搜索引擎的收录和抓取) 从服务器获取的结构就已经是最后要呈现的结果了，不需要客户端做额外的事情，所以也没加速快(前提是服务器端处理的速度够快，能够处理过来)，所以类似于京东、淘宝这些网站，首屏数据一般都是由服务器渲染的 [弊端] 实时更新的数据，每一次想要展示最新的数据，页面都要重新的刷新一次，这样肯定不行 都交给服务器端做数据渲染，服务器端的压力太大，如果服务器处理不过来，页面呈现的速度更慢(所以京东、淘宝这类网站,除了首屏是服务器端渲染的，其他屏一般都是客户端做数据渲染绑定) 这种模式不利于开发(开发效率低) 目前市场上大部分项目都是前后端完全分离的项目(也有非完全前后端分离的) 前后端完全分离前后端完全分离的项目，页面中需要动态绑定的数据是交给客户端完全渲染的 想服务器端发送ajax请求 把从服务器端获取的数据解析处理，拼接成为我们需要展示的html字符串 把拼接好的字符串替换页面中某一部分的内容(局部刷新),页面整体不需要重新加载，局部渲染极客 [优势] 我们可以根据需求，任意修改页面中某一部分的内容(例如实时刷新),整体页面不刷新，性能好，体验好(所有表单验证，需要实时刷新的等需求都要基于ajax实现) 有利于开发，提高开发的效率 前后端的完全分离，后台不需要考虑前端如何实现，前端也不需要考虑后台用什么技术，真正意义上实现了技术的划分 可以同时进行开发:项目开发开始，首先制定前后端数据交互的结构文档(文档中包含了，调用哪个接口或者那些数据等协议规范),后台吧接口线写好(目前很多公司也需要前端自己拿node来模拟这些接口)，客户端按照接口调取极客，后端再去实现接口功能极客 [弊端] 不利于seo优化:第一次从服务器端获取的内容不包含需要动态绑定的数据，所以也没的原代码中没有这些内容，不利于seo收录，后期听过js添加到页面中的内容，并不会写在页面的源代码中(是源代码不是页面结构) 交由客户端渲染，首先需要把页面呈现，然后通过js的异步ajax请求获取数据，然后数据绑定，浏览器在动态增加部分重新渲染，无形中浪费了一些时间，没有服务器端渲染页面呈现速度快 ajax请求12345678910111213141516let xhr = new XMLHttpRequest();// 不兼容ie6以及更低版本的浏览器(ie6 activeXobject)// 打开请求地址(可以理解为一些基础配置，但是并没有发送请求呢)xhr.open([method],[url],[async],[username],[user password]);// 监听ajax改变，获取响应信息(获取响应头信息，获取响应主体信息)xhr.onreadystatechange=()=&gt;&#123; if(xhr.readyState===4 &amp;&amp; xhr.readyState===200)&#123; let result = xhr.responseText;// 获取响应主体中的内容 &#125;&#125;// 发送ajax请求(括号中传递的信息内容是请求主体的内容)xhr.send(null) 分析第二部分的细节点 1xhr.open([method],[url],[async],[username],[user password]); ajax请求方式（method） get系列的请求 get delete head … post系列的请求(推送) post put:想服务器中增加指定的资源文件 … 不管哪一种请求方式,客户端可以吧信息传递给服务器，服务器也可以吧信息返回给客户端，只要get系列一般以获取为主(给的少) 我们想获取一些动态展示的信息，一般使用GET请求，因为只需要向服务器发送请求，告诉服务器端想要什么，服务器端就会把需要的数据返回 在实现注册功的时候，我们需要把客户端输入信息发送给服务器进行存储，服务器一般返回成功是成功等状态，此时我们一般都基于post请求完成 …. get系列请求和post系列请求，在项目是在中存在很多的区别 get请求传递给服务器的内容一般贸易post请求传递给服务器的内容多 原因:get请求传递给服务器内容一般都是基于url地址问号传递参数 来实现的，而实现的，而post请求一般都是基于设置请求主体来实现的。浏览器都已自己的关于url的最大长度限制(谷歌:8kb、火狐:7kb、ie:2kb)超过限制长度的部分，浏览器会自动截取掉，导致传递给服务器的数据缺失 理论上post请求通过主体传递是没有大小限制，真实项目中为了保证传输的速度，我们会限制大小(例如:上传的资料或者图片我们会做大小的限制) get请求容易出现缓存(这个缓存不可控:一般我们都不需要)，而post不会出现缓存(除非自己做特殊处理) 原因:get是通过url问号传参传递给服务器信息，二post是设置请求主体 设置请求主体不会出现缓存，但是url传递参数就会了 1234567891011121314151617181920setTimeout(()=&gt;&#123; $.ajax(&#123; url:'getList?lx=news', success:result=&gt;&#123; // 第一次请求数据回来，间隔一分钟后，浏览器又发送一次请求， // 但是新发送，不管是地址还是传递的参数都和第一次不一样， // 浏览器很有可能会把上一次数据获取，而不是获取新的数据 &#125; &#125;);&#125;,60000)// 解决方案:每一次重新请求的时候，在URL的末尾追加一个随机数，保证每一次请求的地址不完全一直// 就可以避免是从缓存中读取的数据setTimeout(()=&gt;&#123; url:'getList?lx=news_='+Math.random() success:result=&gt;&#123; &#125;&#125;) GET请求没有post请求安全(post也并不是十分安全，只是相对安全)原因:还是因为get是url传递给服务器有一种比较简单的黑客技术:url劫持，也就是可以客户端传递给服务器劫持掉，导致信息泄露 2.4.2 url 请求数据的地址(api地址)，真实项目中，后台开发工程师会编写一个api文档，在api文档中汇总了获取那些数据需要使用哪些地址，我们按照文档操作即可 2.4.3 async 异步(sync同步)，设置当前ajax请求是异步还是同步的，不写默认是异步(true)，如果设置false，则代表当前请求是同步的 用户名和密码这两个参数一般不用，如果你请求的url地址所在服务器设定了访问权限，则需要我们提供通行的用户名和密码才可以(一般服务器都可以允许匿名访问的) AJAX状态码xhr.readyState unsent 未发送，只要创建一个ajax对象，默认值是零 opened 我们已经执行了xhr,open这个操作 headers_resceived 当前ajax的请求已经发送，并且已经接收到服务器端返回的响应头信息了 loading 响应主体内容正在返回的路上 done 响应主体内容已经返回到客户端 HTTP网络状态码 记录了当前服务器返回信息的状态 xhr.status 200成功，一个完整的http事务完成了(以2开头的状态码一般性都是成功) 3开头一般也是成功，只不过是服务器做了特殊的处理 301 moved permanently 永久转移(永久重定向) 302 move temporarily 临时转移(临时重定向，新的http版本中任务307是临时重定向) 一般用于服务器的负载均衡:当前服务器处理不了，我把当前请求临时交给其他的服务器处理(一般图片请求经常出现302,很多公司都有单独的图片服务器) 304 not modified 从浏览器缓存中获取数据 把一些不经常更新的文件或者内容缓存到浏览器中，下一次从缓存中获取，减轻服务器压力，也提高页面加载的速度 4开头的，一般性都是失败的，而且客户端的问题偏大 400:请求参数错误 401:无权限访问 404:访问地址不存在 5开头的，一般都是失败，而且服务器的问题偏大 500:internal Server Error 未知的服务器错误 503:Service Unavailable 服务器超负债 … 面试题 ajax中总共支持几个方法let xhr = new xmlHttpReques();console.dir(xhr); [属性]readyState:存储的是当前ajax的状态response/responseText/responseXML : 都是用来接收服务器返回的响应主体的内容，只是更具服务器返回内容的格式不一样，我们使用不同的属性接收即可responseText是最常见的，接收到结果是字符串格式的(一般服务器返回的数据都是json格式字符串)responXML:偶尔会用到，如果服务器返回的是xml文档数据，我们需要使用这个属性接收status:记录了服务器返回的http状态码statusText:对返回状态码的描述timeout:设置当前ajax请求的超时时间，假设我们设置时间为3000(MS)，从AJAX请求发送开始，3秒后响应主体内容还没有返回，浏览器会把当前ajax请求强行断开 [方法]abor():强行终端ajax请求getAllResponseHeaders():获取全部的响应头信息(获取的结果是一丢字符串文本)getResponseHeader(key):获取指定属性名的响应头部信息，例如:xhr.getResponseHeader(‘data’)获取响应头中存储的服务的时间open():打开一个url地址overridMimeType():重写数据的MIME类型send():发送ajax请求(括号中书写的内容是客户端请求主体吧信息传递给服务器)setRequestHeader(key,value):设置请求头信息(可以是设置自定义请求信息) [事件]onabort:当ajax被终端请求触发这个时间onreadstatechange:ajax状态发烧改变，会触发这个事件ontimeout:当AJAX请求超时，会触发这个事件… 12345678910111213141516171819202122232425262728293031323334let xhr = new XMLHttpRequest(();xhr.open('get','temp.json?_='+Math.random(),true);xhr.setRequesHeader('cookie','xxx'); // =&gt; 设置请求内容不能出现中文汉字xhr.timeout = 10;xhr.ontimeout=()=&gt;&#123; console.log('当前请求已经超时'); xhr.abort();&#125;xhr.onreadystatechange = () =&gt;&#123; let &#123;readyState:state,status&#125; = xhr; // 说明请求数据成功了 if(!/^(2|3)\\d&#123;2&#125;$/.test(status)) return // 在状态为2的时候就获取响应头信息 if(state === 2)&#123; let headerAll = xhr.getAllResponseHeaders(), serverDate = xhr.getResponseHeader('date');// 获取的服务时间是格林尼治时间(相比北京时间差不多差8小时) console.log(headerAll,new Date(serverDate)); return; &#125; // 在状态为4的时候就获取响应头信息已经回来了 if(state === 4)&#123; let valueText = xhr.responseText,// 获取到的结果一般都是json字符串(可以时间json.parse把其转换成json对象) valueXML = xhr.responseXML; // 获取到的结果是xml格式的数据，(可以通过xml的一些常规操作获取存储的指定信息) // 如果服务器返回的是xml文档，responseText获取的结果是字符串，而responseXML获取的是标准xml文档 console.log(valueText,valueXML); &#125;&#125;xhr.send('name=wjw&amp;age=23&amp;sex=man') AJAX中的同步和异步编程1234567let xhr = new XMLHttpRequest();xhr.open('get','temp.json',false);xhr.onredystatechange=()=&gt;&#123; console.log(xhr.readySate);&#125;xhr.send();// 只输出一次结果4 12345678910let xhr = new XMLHttpRequest();xhr.open('get','temp.json',false);xhr.send();// =&gt; 同步开始发送ajax请求，开启ajax任务，在任务没有完成之前，什么事情都做不了// 下面绑定时间也做不了 =&gt; loading =&gt; 当readyState ===4 的是ajax任务完成，开始执行下面的操作xhr.onreadystatechange=()=&gt;&#123; console.log(xhr.readySate);&#125;// 绑定方法之前状态已经为4了，此时ajax的状态不会再改吧其他值，所以事件永远不会被处罚// 一次都没有执行方法(使用ajax同步编程，不要把send放在事件监听前// 这样我们无法在绑定方法中获取响应主体的内容) let xhr = new XMLHttpRequest(); // 下面绑定时间也做不了 =&gt; loading =&gt; 当readyState ===4 的是ajax任务完成，开始执行下面的操作 xhr.onreadystatechange=()=&gt;{ console.log(xhr.readySate); if(xhr.readySate===1) { xhr.setRequestHeader('aaa','bbb'); } } xhr.open('get','temp.json',false); // xhr.readyState === 1 AJAX特殊处理的一件事:执行OPEN状态变为1,会主动把之前监听的方法执行一次 // 然后再去执行SEND xhr.send(); // xhr.redayState === 4 AJAX任务借宿，主任务队列完成 AJAX类库的封装 JQ中的AJAX url 请求api地址 method 请求方法get/post..在老板的jq中使用是type，使用type和method相同效果 dataType dataType只是我们预设获取结果的类型不会影响服务器的返回(服务器端一般给我们返回的都是json格式的字符串),如果我们预设是json,那么类库中将吧服务器返回的字符串转换为json对象，如果我们预设是text(默认值)，我们把服务器获取的结果直接拿过来操作即可，我们预设的值还可以xml等 cache 设置是否清楚缓存，只对get系列请求有作用，默认是true不清除缓存，手动设置false，jq类库在请求url的末尾最佳一个随机数来清楚缓存 data 我们通过data可以把一些信息传递给服务器，get系列请求会把data中的内容拼接在url的末尾通过问号传参的方式给服务器，post系列请求会把内容请求放在主题传递给服务器;data的值可以设置为两种格式，字符串、对象，如果是字符串，设置的值是传递给服务器的就是什么，如果设置成对象，jq会把对象变为xxx=xxx&amp;xx=xx,这样来数据传递 async 设置同步或者异步，默认是true代表异步，false代表同步 success dangajax请求成功后redayState===4&amp;&amp;statue是以2或者3开头的请求成功后jq会把传递的回调函数执行，并且获取的结果当做实参传递给回调函数(result就是我们从服务器获取的结果) error 请求错误触发回调函数 complate 不管请求还是错误的还是正确的都会触发这个回调函数(他就是完成的意思) …. 封装自己的AJAX库 url method/type data dataType async cache success ~funcction(){ class ajaxClass { // send ajax init() { let xhr = new XMLHttpRequest(); xhr.onreadustatechange = () =&gt; { if (!/^[23]\\d{2}$/.test(xhr.status)) return; if (xhr.redayState === 4) { let result = xhr.responseText; // DATA-TYPE switch (this.dataType.toUpperCase()) { case 'TEXT': break; case 'JSON': result = JSON.parese(result); break; case 'XML': result = xhr.responseXML; break; } this.success(result); } } // DATA if (this.data !==null) { this.formatData(); if (this.idGET) { this.url +=this.querySymbol()+this.data; this.data = null; } } // CACHE this.isGET ? this.cache(); xhr.open(this.method, this.url, this.async); xhr.send(); } cacheFn() { // THIS:EXAMPLE !this.cache ? this.url += `${this.querySymbol()}_=${Math.random()}` : null; } querySymbol() { // THIS:EXAMPLE return this.url.indexOf('?') &gt; -1 ? '&amp;' : '?'; } formatData(){ // THIS:EXAMPLE if(Object.prototype.toString.call(this.data)==='[Object Object]'){ let obj = this.data, str = ``; for (const key in obj) { if (object.hasOwnProperty(key)) { str +=`${key}=${obj[key]}`; } } str = str.replace(/&amp;$/g,''); this.data = str; } } } let ajax = function () {}; // init parameters window.ajax = function ({ url = null, method = 'GET', type = 'GET', data = null, dataType = 'JSON', cache = true, async = ture, suceess = null } = {}) { let _this = new ajaxClass(); // 创建实例 ['url', 'method','data','dataType','cache','async','success'].forEach((item)=&gt;{ if (item === 'method') { _this.method = type === null ? method : type; return; } if (item==='success') { _this.suceess = typeof success === 'function' ? success : new Function(); } _this[item] = eval(item); }) _this.isGET = /^(GET|DELETE|HEAD)$/i.test(example.method); _this.init(); return _this; }; }(); ajax({})","categories":[{"name":"http与ajax入门笔记","slug":"http与ajax入门笔记","permalink":"http://yoursite.com/categories/http与ajax入门笔记/"}],"tags":[{"name":"http与ajax入门笔记","slug":"http与ajax入门笔记","permalink":"http://yoursite.com/tags/http与ajax入门笔记/"}]},{"title":"1. HTPP","slug":"http与ajax入门笔记/1. HTPP","date":"2019-04-08T03:10:04.000Z","updated":"2019-06-06T14:47:05.000Z","comments":true,"path":"2019/04/08/http与ajax入门笔记/1. HTPP/","link":"","permalink":"http://yoursite.com/2019/04/08/http与ajax入门笔记/1. HTPP/","excerpt":"","text":"前端和后端如何通讯 前端:客户端后端:服务端 职业规划建议 培养自己的人脉圈，以及建立自己的影响力 状态自己的总和能力 经常参加一些活动 开放分享(做讲师分享自己的智慧、写组件的个人博客做技术分享) 当我们在浏览器地址中输入URL地址，到最后看到页面，中间经历了哪些事情？假设我们访问的是 https://www.baidu.com这个地址，按下enter建后，我们可以看到百度首页 百度页面并没有在我们自己的客服端本地，我们是输入地址后，才请求过来的 输入不同的域名可以看到不同的页面 有的网页是https，有的是http(也有的是ftp) 需要客户端联网才能完成这些事情 DNS服务器 域名解析服务1.www.baidu.com 220.163.18.24域名和服务器关联在一起，是通过DNS解析完成，所谓的DNS解析就是在dns服务上生成一条解析记录，标注了域名和对应的外网ip地址 都经历了哪些事情？ 首先根据客户端输入的域名，到DNS服务器上进行反解析(通过域名找到对应服务器的外网ip) 通过找到外网的ip，找到对应的服务器 通过地址栏中输入的端口号(没输入是因为不同协议有自己默认的端口号)找到服务器上发布的对应项目 服务器获取请求资源的地址，例如/stu/index.html，把资源文件中的原代码找到 response 响应阶段 服务器端会把找的原代码返回给客户端(通过http等传输协议返回) 客户端接收到原代码后，会交给浏览器的内核(渲染引擎)进行渲染，最后由浏览器绘制出对应的页面 服务器自主渲染 客户端和服务端交互(通讯)模型 第一部分 传输协议URL、URI、URN URI : 统一资源标识符 URL: 统一资源路径地址 URN：统一资源名称 URI=URL+URN 一个完整的url包含很多部分https://www.yuque.com/as-giant/dz5g6s/eh4kdu/edit?name=wang&amp;age=2 传输协议是用来完成客户端和服务端的数据(内存)传输的，类似于快递小哥、负责把客户和商家的物品来回床底 客户端不仅可以向服务器发送请求，而且还可以吧一些内容传递给服务器 服务器端也可以把内容返回给客户端 客户端和服务端传输的内容总称:http报文，这些报文信息都是基于传输协议完成传输的，客户端传递给服务器叫做请求(Request),服务器返回给客户端叫做响应(Response) , request+response两个阶段统称为一个HTTP事务(事务:一个完整的事情) HTTP事务 当客户端想服务器端发送请求，此时客户端和服务器端会简历一个传输通道(链接通道)，传输协议就是基于这个通道吧信息进行传输的 当服务器端接受到请求信息，把内容返回给客户端后，传输通道会自动销毁关闭 传输协议分类 http:超文本传输协议(客户端和服务器端传输的内容除了文本以外)，还可以传输图片，音视频等文件流[二进制编码/base64],以及传输xml格式的数据等，是目前市场上应用最广泛的传输协议 https:http ssl,它比http更加安全，要往数据内容的传输通道是经过ssl加密的(它需要在服务器端惊醒特殊的处理)，所以涉及资金类的网站一般都是https协议的 ftp:资源文件传输协议，一般用客户端把资源文件(不是代码)上传到服务端，或者从服务器端下载一些资源文件（ftp传输的内容会http这类传输协议传输的内容多) http报文1、起始行 请求起始行 响应起始行 2、首部(头) 请求头：内置请求头、自定义请求头 响应式：内置响应头、自定义响应头 通用头：请求和响应都有的 3、主体 请求主体 响应主体 请求xxx都是客户端设置的信息，服务器获取这些信息响应xxx都是服务器端设置的信息，客户端用来接受这些信息 域名设置域名其实就给不好记忆的服务器外网ip设置了一个好记忆的名字顶级域名(一级域名):qq.com二级域名:www.qq.com、v.qq.com、sports.qq.com三级域名:kbs.sports.qq.com 端口号在服务器发布项目的时候，我们可以通过端口号区分当前服务器上不同的项目一台服务器的端口号取值范围:0~65535之间，如果电脑上安装了很多程序，有一些端口号是被占用了 HTTP:默认端口号80HTTP:默认端口号443FTP:默认端口号21 对于上述三个端口号其实是很重要的，如果被其它程序占用的，我们则不能使用了，所以服务器上一般是禁止安装其它程序的 第四部分 请求资源文件的路径名称/stu/index.html在服务器中发布项目的时候，我们一般都会配置一些默认文档:用户即使不输入请求文件的名称，服务器也会找到默认文档(一般默认文档都是index/default…)我们通常为了做seo优化，会把一些动态页面的地址(xxx.php、xxx.aspx、xxx.asp、xxx.jsp…)进行伪URL重写(需要服务器处理的)https://item.jd.com/432527.html不可能是有一个商品，自己就单独写一个详情页面，肯定是同一个详情页做的不同处理 第一种方案由后台语言很久详情页模板动态生成具体的详情页面 第二种方案当前页面就是一个页面，例如:detail.html/detail.php…,我们做详情页面的时候，开发是按照detail.html?id=432527 来开发的，但是这种页面不方便做seo优化，此时我们把真实的地址进行重写，重写为了让我们看到的是4325427.html 第五部分 问号传承?name=zf&amp;age=9把一些通过xxx=xxx的方式，放在一个url的末尾，通过问号传递 【作用】1.在ajax请求中，我们可以通过问号传递参数的方式，客户端吧一些信息传递给服务器，服务器更具传递信息的不一样，返回不同的数据 12345678910// $.ajax(url,&#123;&#125;);// $.get(url,function()&#123;&#125;);// 对于ajax请求的特殊写法，原理还是基于ajax方法实现 $.post $.script$.ajax(&#123; url:'getPersonInfo?id=12' ...&#125;)// 当前案例，我们传递给服务器的编号是多少，服务器端就会把对应编号人员信息给返回 2.消除ajax请求中get方式缓存 12345$.ajax(&#123; url:'xxx?_=0.123456' method:'get'&#125;)// 我们会在请求url的末尾最佳一个随机数_=随机数，保证每一次请求的url都是不一样的，以此来消除get请求一流的缓存问题 3.通过url传递传输的方式，可以实现页面之间信息的通讯，例如:我们有两个页面A/B,A是列表页面、B是详情页，点击A中的某一条信息，进入到唯一的详情页B，如果展示不同的信息，这种操作就可以基于URL问号传递参数来实现了 例如:http://sports.qq.com/kbsweb/game.htm?mid=10000:1471087http://sports.qq.com/kbsweb/game.htm?mid=10000:1471086在进入game.htm页面的时候，我们可以获取URL传递的参数值，更具传递参数值的不一样从服务器端获取不同的数据展示 在列表页面进行页面跳转的时候，我们需要记住的是跳转的同事传递不同的参数值 第六部分 HASH值#xxxURL末尾传递的井号什么，就是HASH值(哈希值) [作用]1、页面中锚点定位2、前端路由(SPA单页面开发) –&gt;","categories":[{"name":"http与ajax入门笔记","slug":"http与ajax入门笔记","permalink":"http://yoursite.com/categories/http与ajax入门笔记/"}],"tags":[{"name":"http与ajax入门笔记","slug":"http与ajax入门笔记","permalink":"http://yoursite.com/tags/http与ajax入门笔记/"}]},{"title":"7 HTML 字符的使用","slug":"html入门/7 HTML 字符的使用","date":"2019-03-06T13:50:18.000Z","updated":"2019-06-08T14:54:50.000Z","comments":true,"path":"2019/03/06/html入门/7 HTML 字符的使用/","link":"","permalink":"http://yoursite.com/2019/03/06/html入门/7 HTML 字符的使用/","excerpt":"","text":"在 HTML 中，某些字符是预留的。大部分人最常用的就是&amp;nbsp,因为这个是我们目前使用最平凡的字符。还有一些不是很好的字符。例如&lt;，虽然说浏览的解析上是没有问题，单idea对于它的处理，则不会太友善。例如这样。 有用的字符实体 显示结果 描述 实体名称 实体编号 空格 &nbsp; &#160; &lt; 小于号 &lt; &#60; &gt; 大于号 &gt; &#62; &amp; 和号 &amp; &#38; “ 引号 &quot; &#34; ‘ 撇号 &apos; (IE不支持) &#39; ￠ 分 &cent; &#162; £ 镑 &pound; &#163; ¥ 元 &yen; &#165; € 欧元 &euro; &#8364; § 小节 &sect; &#167; © 版权 &copy; &#169; ® 注册商标 &reg; &#174; ™ 商标 &trade; &#8482; × 乘号 &times; &#215; ÷ 除号 &divide; &#247;","categories":[{"name":"html入门","slug":"html入门","permalink":"http://yoursite.com/categories/html入门/"}],"tags":[{"name":"html入门","slug":"html入门","permalink":"http://yoursite.com/tags/html入门/"}]},{"title":"6 HTML 文本语义化","slug":"html入门/6 HTML 文本语义化","date":"2019-03-06T12:50:18.000Z","updated":"2019-06-08T14:54:51.000Z","comments":true,"path":"2019/03/06/html入门/6 HTML 文本语义化/","link":"","permalink":"http://yoursite.com/2019/03/06/html入门/6 HTML 文本语义化/","excerpt":"","text":"6.1 介绍很多人在写一个文本的时候，都会用上不少的css，这些都属于不利于语义化的html，你加上了不少的css，最后蜘蛛爬虫获取你代码的时候，你以为是长成，要字体斜就斜，要字体加粗就加粗，啥样没有啊，还能空几格。但是爬虫可以不是自带编辑器，就是你的浏览器。人家看到的一团文字。 6.2 HTML 文本格式化标签 标签 描述 定义粗体文本 定义着重文字 定义斜体字 定义小号字 定义加重语气 定义下标字 定义上标字 定义插入字 定义删除字 6.3 HTML “计算机输出” 标签 标签 描述 定义键盘码 定义计算机代码样本 定义变量 定义预格式文本 定义计算机代码 6.4 HTML 引文, 引用, 及标签定义 标签 描述 定义缩写 定义地址 定义文字方向 定义长的引用 定义短的引用语 定义引用、引证 定义一个定义项目","categories":[{"name":"html入门","slug":"html入门","permalink":"http://yoursite.com/categories/html入门/"}],"tags":[{"name":"html入门","slug":"html入门","permalink":"http://yoursite.com/tags/html入门/"}]},{"title":"5 HTML基本结构","slug":"html入门/5 HTML基本结构","date":"2019-03-06T11:50:18.000Z","updated":"2019-06-08T14:55:34.000Z","comments":true,"path":"2019/03/06/html入门/5 HTML基本结构/","link":"","permalink":"http://yoursite.com/2019/03/06/html入门/5 HTML基本结构/","excerpt":"","text":"5.1 html基本结构 HTML文档标记： 头标签： 标题标签： 页面元信息：,一般设置为utf-8 主题标记： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 5.2 HTML文档的后缀名 .html与.htm均是静态网页后缀名，网页文件没有区别与区分，html与htm后缀网页后缀可以互换，对网页完全没有影响同时也没有区别。可以认为html与htm没有本质区别，唯一区别即多与少一个“L”。 5.3 元素语法 HTML 元素以开始标签起始 HTML 元素以结束标签终止 元素的内容是开始标签与结束标签之间的内容 某些 HTML 元素具有空内容（empty content） 空元素在开始标签中进行关闭（以开始标签的结束而结束） 大多数 HTML 元素可拥有属性 5.4 嵌套的 HTML 元素 HTML 文档由嵌套的 HTML 元素构成。大多数 HTML 元素可以嵌套（可以包含其他 HTML 元素）。 5.5 空元素 没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。 就是没有关闭标签的空元素（ 标签定义换行）。 在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。 在开始标签中添加斜杠，比如 ，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。 即使 在所有浏览器中都是有效的，但使用 其实是更长远的保障。 5.6 HTML 标签大小写 HTML 标签对大小写不敏感： 等同于 。许多网站都使用大写的 HTML 标签。 PHP中文网使用的是小写标签，因为万维网联盟（W3C）在 HTML 4 中推荐使用小写，而在未来 (X)HTML 版本中强制使用小写。 5.7 HTML属性虽然世界上存在一个万能标签div，但是还是需要一些特别的标签去完成一些特别的事情,例如 a标签中href属性 img标签中的src属性。","categories":[{"name":"html入门","slug":"html入门","permalink":"http://yoursite.com/categories/html入门/"}],"tags":[{"name":"html入门","slug":"html入门","permalink":"http://yoursite.com/tags/html入门/"}]},{"title":"4 标签分为两种等级","slug":"html入门/4 标签分为两种等级","date":"2019-03-06T10:50:18.000Z","updated":"2019-06-08T14:55:35.000Z","comments":true,"path":"2019/03/06/html入门/4 标签分为两种等级/","link":"","permalink":"http://yoursite.com/2019/03/06/html入门/4 标签分为两种等级/","excerpt":"","text":"4.1 行内元素 简介 例子: span a b strong i em s br u textarea input select lable img sup big small 内联元素是指本身属性为display:inline的元素。因为它自身的特点，我们通常使用行内元素进行文字、小图标（小结构）的搭建。 行内元素的特点 1.不独占一行 2.排列方式:从左往右 3.设置宽高不起作用 如要起作用 需要转换为块/行内块 4.不设置宽高是它的本身内容的宽高 5.天数自带 display:inline 6.行内元素里不能嵌套块级元素（特殊a） 4.2 块级元素 简介 例子: div h1-h6 hr menu ol ul li dl dt dd table p form 本身属性为 display:block的元素；因为它自身的特点，我们通常使用块级元素进行大布局（大结构的搭建） 块级元素的特点 1.独占一行,每一个块级元素都会从新的一行重新开始 2.排列方式:从上往下 3.可以设置宽高以及盒子模型的其他属性 4.不设置宽高的情况下 他的宽度和父元素的宽度 它的高度是本身内容的高度 5.天生自带display：block 6.ul ol 下面只能是li dl 下面只能是dt dd 7.p里面不能嵌套任何的块级元素 包括它自己本身 可以嵌套行内元素 4.3 行内块 简介 行内块状元素综合了行内元素和块状元素的特性，但是各有取舍。因此行内块状元素在日常的使用中，由于其特性，使用的次数也比较多。 行内块元素的特点 (1)不自动换行 (2)能够识别宽高 (3)默认排列方式为从左到右 4.4 元素之间的互相转换行内元素 =&gt; display:inline 块级元素 =&gt; display:block 行内块元素 =&gt; display:inline-block","categories":[{"name":"html入门","slug":"html入门","permalink":"http://yoursite.com/categories/html入门/"}],"tags":[{"name":"html入门","slug":"html入门","permalink":"http://yoursite.com/tags/html入门/"}]},{"title":"3 一场升级","slug":"html入门/3 一场升级","date":"2019-03-06T09:50:18.000Z","updated":"2019-06-08T14:55:36.000Z","comments":true,"path":"2019/03/06/html入门/3 一场升级/","link":"","permalink":"http://yoursite.com/2019/03/06/html入门/3 一场升级/","excerpt":"","text":"从XHTML 1.1 到 htm5 这个故事要从 DOCTYPE 开始 从html部队的第一代长官之后，历经了几代长官，一代代升级迭代。最终市面上留下的也就是html4与html5,老百姓喜欢称他们为h4与h5。 HTML 4.01 Strict 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; HTML 4.01 Transitional 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; HTML 4.01 Frameset 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt; HTML 5 &lt;!DOCTYPE html&gt; 在这场标签的战役中，首领的不同，也就意味着使用的html的版本设置不同，这也就是html的标签不同。 这场战役中，也要出现一些不能出现，但是舍不得删的。 &lt;!-- --&gt; 快捷键: ctrl + / 在这里我们认识一个编译工具。 工欲善其事必先利其器，所以先下个vscode总是没错的，我辈总有些人是说记事本也能，但是有人和你说了，别别理他了，工作场合。没人那么用。也有人和说过webstorm，在jetbrains公司大旗下，也不错，但是我觉得功能太重，不好用。sublime在vscode出现之前绝对是神器，但是插件上还是慢慢逊了一筹。","categories":[{"name":"html入门","slug":"html入门","permalink":"http://yoursite.com/categories/html入门/"}],"tags":[{"name":"html入门","slug":"html入门","permalink":"http://yoursite.com/tags/html入门/"}]},{"title":"2 认识html标签","slug":"html入门/2 认识html标签","date":"2019-03-06T08:50:18.000Z","updated":"2019-06-08T14:55:37.000Z","comments":true,"path":"2019/03/06/html入门/2 认识html标签/","link":"","permalink":"http://yoursite.com/2019/03/06/html入门/2 认识html标签/","excerpt":"","text":"2.1 入门篇 世界观 在张鑫旭大神将前端的世界比喻成一个王国，而我认为可能这就分为3个部队，差不多可以理解成为，html部队，css部队，js部队。有一个叫产品经理的怪，需要三家合理才能打赢。 这第一仗就是html，负责把骨架搭好了，再上颜料和动态效果。骨架搭的好，有什么好处呢，大家都知道只要div+css，那么这个页面除了几个特殊标签，比如a，viode啊，其他的都可以伪装出来。这个牵扯到一个标签语义化的作用，语义化有两种好处。 2.2 权重(蜘蛛)骨架好，百度蜘蛛会爬取收录。这个作用，可以帮助很多公司，获取百度权重的排名。百度蜘蛛，它的功能其实就和抄书一样。那么就意味着他不能解析css。所以，他看到了img就知道是图片，但是你写一个div+background:url(&apos;./img.png&apos;)。它可就不认识了。 2.3 障碍解析器使用特殊的阅读器。 那么如何判断骨架的好坏呢？ 我们拿慕课网举例子，原图如下 我们把网页的css删除了，标签的格式还不乱，这就是好的骨架。 改呗收录的都被收录了这就是语义化。 按下不表: 接下来我们将根据 html，css，js的基本和升级探究，前端的世界。","categories":[{"name":"html入门","slug":"html入门","permalink":"http://yoursite.com/categories/html入门/"}],"tags":[{"name":"html入门","slug":"html入门","permalink":"http://yoursite.com/tags/html入门/"}]},{"title":"1 认识浏览器","slug":"html入门/1 认识浏览器","date":"2019-03-06T07:50:18.000Z","updated":"2019-06-08T14:53:30.000Z","comments":true,"path":"2019/03/06/html入门/1 认识浏览器/","link":"","permalink":"http://yoursite.com/2019/03/06/html入门/1 认识浏览器/","excerpt":"","text":"谷歌浏览器（chrome）:Webkit内核（v8引擎） 火狐浏览器（firefox）：Gecko内核 IE浏览器：Trident内核 欧朋浏览器 (opera):Presto内核 safari (苹果浏览器) 大部分国产浏览器（360、搜狗、QQ、UC、猎豹、百度） 认知的浏览器世界 浏览器因为内核不同，将会导致很多问题，比如说js的适配问题，解决es6的兼容问题，比如说css3的兼容问题，这些势必都会成功很多比较麻烦的问题。;因为最早期的设计中，在我的认知中，div+css的拼图模式。但是根据移动端的出现，和各自的核心浏览器适配问题，而又没有统一的局势和方案。 加上最近的node(v8)环境的出现，js代码的生存空间(解释器)的扩张，面对前端的适配问题，也将层出不穷。","categories":[{"name":"html入门","slug":"html入门","permalink":"http://yoursite.com/categories/html入门/"}],"tags":[{"name":"html入门","slug":"html入门","permalink":"http://yoursite.com/tags/html入门/"}]},{"title":"13. promise","slug":"es6/13.promise","date":"2019-03-06T03:12:06.000Z","updated":"2019-06-06T14:25:45.000Z","comments":true,"path":"2019/03/06/es6/13.promise/","link":"","permalink":"http://yoursite.com/2019/03/06/es6/13.promise/","excerpt":"","text":"异步回调回调地狱在需要多个操作的时间，会导致多个回调函数嵌套，导致代码不够直观，就常说的回调地域 并行结果如果几个异步操作之间并没有前后顺序之分，但需要等多个异步完成操作完成后才能执行后续的任务，无法实现并行节约时间 Promisepromise本意是承诺，在程序中的意思就是承诺我过一段时间后会给你一个结果。什么时间会用到过一段时间？答案是异步操作，异步是指可能比较长时间才有结果的才做，例如网络请求、读取本地文件等 Promise的三种状态 Pending Promise对象势力创建时候的初始化状态 Fulfilled 可以理解为成功的状态 Rejected 可以理解为失败的状态 then方法就是用来指定Promise 对象的状态改变时确定执行的操作，resolve时执行第一个函数（onFulfilled）,reject时执行第二函数（onRejected） 构造一个Promise使用Promise123456789let promise = new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; if(Math.random()&gt;0.5) resolve('This is resolve!') else reject('This is reject') &#125;,1000);&#125;);promise.then(Fulfilled,Rejected) 构造一个Promise实例需要给Promise构造函数传入一个函数 传入的函数需要有两个形参，两个形参都是function类型的参数。 第一个形参运行后会让Promise实例处于resolve状态，所以我们一般给第一个形参命名为resolve，使 Promise对象的状态改变成成功，同时传递一个参数用于后续成功后的操作 第一个形参运行后悔让Promise实例处于reject状态，所以我们一般给第一个形参命名为reject，将Promise对象的状态改变为失败，同事将错误的信息传递到后续错误处理的操作 es5模拟Promise1234567891011121314function Promise(fn)&#123; this.success(data);&#125;,(error)=&gt;&#123; this.error();&#125;Promise.prtotype.resolve = function (data)&#123; this.success(data);&#125;Promise.prototype.then = function (success,error)&#123; this.success = success; this.error = error;&#125; es5模拟Promise123456789101112131415161718192021222324class Promise&#123; constructor(fn)&#123; fn((data)=&gt;&#123; this.success(data); &#125;,(error)=&gt;&#123; this.error(); &#125;) &#125; resolve(data)&#123; this.success(data); &#125; reject(error)&#123; this.error(error); &#125; then(success,error)&#123; this.success = success; this.error = error; console.log(this); &#125;&#125; promise 做为函数的返回值123456789101112131415161718192021222324function ajaxPromise(queryUrl)&#123; return new Promise((resolve,reject)=&gt;&#123; xhr.open('GET',queryUrl,ture); xhr.send(null); xhr.onreadystatechange = () =&gt;&#123; if(xhr.readyState === 4 )&#123; if(xhr.status === 200)&#123; resolve(xhr.responseText); &#125;else&#123; reject(xhr.responseText); &#125; &#125; &#125; &#125;)&#125;ajaxPromise('http://www.baidu.com') .then((value)=&gt;&#123; console.log(value); &#125;) .catch((err)=&gt;&#123; console.error(err); &#125;); promise的链式调用 每次调用返回的都是一个新的Promise实例 链式调用的参数通过返回值传递 then 可以使用链式调用的写法原因在于，每一次执行该方法时总是会返回一个 Promise 对象 12345678910readFile('1.txt').then(function(data)&#123; console.log(data);&#125;).then(function (data)&#123; console.log(data); return readFile(data);&#125;).then(function (data)&#123; console.log(data);&#125;).catch(function (err)&#123; console.log(err);&#125;) promise APIPromise.all 参数:接受一个数组，数组内都是Promise实例 返回值: 返回一个 promise 实例，这个promise 实例的状态转移取决于参数的 promise实例的状态变化。当参数处于resolve状态时，返回resolve状态。如果参数中任意一个实例处于reject状态，返回的promise实例变为reject状态。 123Promise.all([p1,p2]).then(function(result)&#123; console.log(result); //[ '2.txt', '2' ]&#125;) 不管两个promise谁先完成，Promise.all 方法会按照数组里面的顺序将结果返回 Promise.race 参数:接受一个数组，数组内都是Promise实例 返回值: 返回一个 promise 实例，这个promise 实例的状态转移取决于参数的 promise实例的状态变化。当参数处于resolve状态时，返回resolve状态。如果参数中任意一个实例处于reject状态，返回的promise实例变为reject状态。 123Promise.race([p1,p2]).then(function(result)&#123; console.log(result); //[ '2.txt', '2' ]&#125;) Promise.resolve返回一个Promise 实例，这个实例处于resolve状态。根据传入的参数不同有不同的功能: 值(对象、数组、字符串等):作为resolve传递出去的值 Promise 实例 : 原封不动返回 Promise.reject返回一个Promise实例，这个实例处于reject状态 参数一般就是抛出的错误信息。 qQ是一个在Javascrip中实现promise的模块 13.8.1 q的基本用法123456789101112131415161718var Q = require('q');var fs = require('fs');function read(filename)&#123; var deferred = Q.defer(); fs.readFile(filename,'utf8',function)(err,data)&#123; if(err)&#123; deferred.reject(err); &#125;else&#123; deferred.resolve(data); &#125; &#125;);&#125;read('1.txt1').then(function(data)&#123; console.log(data);&#125;,funtcion(error)&#123; console.error(error); &#125;) 13.8.2 q的简单实现12345678910111213141516171819module.exports = &#123; defer()&#123; var _success,_error; return &#123; resolve(data)&#123; _success(data); &#125;, reject(err)&#123; _error(err); &#125;, promise:&#123; then(success,error)&#123; _success = success; _error = error; &#125; &#125; &#125; &#125;&#125; 13.8.3 q的实现123456789101112131415161718192021222324var defer = function () &#123; var pending = [], value; return &#123; resolve: function (_value) &#123; if (pending) &#123; value = _value; for (var i = 0, ii = pending.length; i &lt; ii; i++) &#123; var callback = pending[i]; callback(value); &#125; pending = undefined; &#125; &#125;, promise: &#123; then: function (callback) &#123; if (pending) &#123; pending.push(callback); &#125; else &#123; callback(value); &#125; &#125; &#125; &#125;;&#125;; 13.9 bluebird 实现 promise 标准的库是功能最全，速度最快的一个库 13.9.1 bluebird经典使用123456789101112var Promise = require('./bluebird');var readFile = Promise.promisify(require(\"fs\").readFile);readFile(\"1.txt\", \"utf8\").then(function(contents) &#123; console.log(contents);&#125;)var fs = Promise.promisifyAll(require(\"fs\"));fs.readFileAsync(\"1.txt\", \"utf8\").then(function (contents) &#123; console.log(contents);&#125;) bluebird简单实现123456789101112131415161718192021222324module.exports = &#123; promisify(fn)&#123; return function () &#123; var args = Array.from(arguments); return new Promise(function (resolve, reject) &#123; fn.apply(null, args.concat(function (err) &#123; if (err) &#123; reject(err); &#125; else &#123; resolve(arguments[1]) &#125; &#125;)); &#125;) &#125; &#125;, promisifyAll(obj)&#123; for(var attr in obj)&#123; if(obj.hasOwnProperty(attr) &amp;&amp; typeof obj[attr] =='function')&#123; obj[attr+'Async'] = this.promisify(obj[attr]); &#125; &#125; return obj; &#125;&#125; 13.10 动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;move&lt;/title&gt; &lt;style&gt; .square&#123; width:40px; height:40px; border-radius: 50%; &#125; .square1&#123; background-color: red; &#125; .square2&#123; background-color: yellow; &#125; .square3&#123; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"square square1\" style=\"margin-left: 0\"&gt;&lt;/div&gt;&lt;div class=\"square square2\" style=\"margin-left: 0\"&gt;&lt;/div&gt;&lt;div class=\"square square3\" style=\"margin-left: 0\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var square1 = document.querySelector('.square1'); var square2 = document.querySelector('.square2'); var square3 = document.querySelector('.square3'); /*function move(element,target,resolve)&#123; let timer = setInterval(function()&#123; var marginLeft = parseInt(element.style.marginLeft, 10); if(marginLeft == target)&#123; resolve(); &#125;else&#123; element.style.marginLeft = ++marginLeft+'px'; &#125; &#125;,13); &#125;*/ function move(element,target,resolve)&#123; let current = 0; let timer = setInterval(function()&#123; element.style.transform=`translateX($&#123;++current&#125;px)`; if(current&gt;target)&#123; clearInterval(timer); resolve(); &#125;; &#125;,13); &#125; function animate(element,target)&#123; return new Promise(function(resolve,reject)&#123; move(element,target,resolve); &#125;); &#125; animate(square1,100) .then(function()&#123; return animate(square2,100); &#125;) .then(function()&#123; return animate(square3,100); &#125;);&lt;/script&gt;&lt;/html&gt; 13.11. co 13.11.1 co初体验1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let fs = require('fs');function getNumber()&#123; return new Promise(function (resolve,reject) &#123; setTimeout(function()&#123; let number = Math.random(); if(number &gt;.5)&#123; resolve(number); &#125;else&#123; reject('数字太小'); &#125; &#125;,1000); &#125;);&#125;function *read()&#123; let a = yield getNumber(); console.log(a); let b = yield 'b'; console.log(b); let c = yield getNumber(); console.log(c);&#125;function co(gen)&#123; return new Promise(function(resolve,reject)&#123; let g = gen(); function next(lastValue)&#123; let &#123;done,value&#125; = g.next(lastValue); if(done)&#123; resolve(lastValue); &#125;else&#123; if(value instanceof Promise)&#123; value.then(next,function(val)&#123; reject(val); &#125;); &#125;else&#123; next(value); &#125; &#125; &#125; next(); &#125;);&#125;co(read).then(function(data)&#123; console.log(data);&#125;,function(reason)&#123; console.log(reason);&#125;); 13.11.2 co连续读文件12345678910111213141516171819202122232425262728let fs = require('fs');function readFile(filename)&#123; return new Promise(function (resolve,reject) &#123; fs.readFile(filename,'utf8',function(err,data)&#123; if(err) reject(err); else resolve(data); &#125;) &#125;);&#125;function *read()&#123; let a = yield readFile('./1.txt'); console.log(a); let b = yield readFile('./2.txt'); console.log(b);&#125;function co(gen)&#123; let g = gen(); function next(val)&#123; let &#123;done,value&#125; = g.next(val); if(!done)&#123; value.then(next); &#125; &#125; next();&#125; 13.12 Promise/A+完整实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170function Promise(executor) &#123; let self = this; // 默认状态pending self.status = \"pending\"; // 此变量里放着此promise的结果 self.value = undefined; // 存放所有成功的回调函数 self.onResolvedCallbacks = []; // 存放所有的失败的回调函数 self.onRejectedCallbacks = []; // 调用方法promise 变成成功状态 // resolve的时候你把值传过来 function resolve(value) &#123; if (value instanceof Promise) &#123; return value.then(resolve, reject) &#125; setTimeout(function () &#123; // 异步执行所有的回调函数 if (self.status == 'pending') &#123; self.value = value; self.status = 'resolved'; self.onResolvedCallbacks.forEach(item =&gt; item(value)); &#125; &#125;); &#125; // 调用方法把当前promise变成失败 function reject(value) &#123; setTimeout(function () &#123; if (self.status == 'pending') &#123; self.value = value; self.status = 'rejected'; self.onRejectedCallbacks.forEach(item =&gt; item(value)); &#125; &#125;); &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; return reject(new TypeError('循环引用')); &#125; let then, called; if (x != null &amp;&amp; ((typeof x == 'object' || typeof x == 'function'))) &#123; try &#123; then = x.then; if (typeof then == 'function') &#123; then.call(x, function (y) &#123; if (called)return; called = true; resolvePromise(promise2, y, resolve, reject); &#125;, function (r) &#123; if (called)return; called = true; reject(r); &#125;); &#125; else &#123; resolve(x); &#125; &#125; catch (e) &#123; if (called)return; called = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125;// onFullfilled成功的回调,onReject失败的回调Promise.prototype.then = function (onFulfilled, onRejected) &#123; let self = this; onFulfilled = typeof onFulfilled == 'function' ? onFulfilled : function (value) &#123; return value &#125;; onRejected = typeof onRejected == 'function' ? onRejected : function (value) &#123; throw value &#125;; let promise2; if (self.status == 'resolved') &#123; promise2 = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; try &#123; let x = onFulfilled(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if (self.status == 'rejected') &#123; promise2 = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; try &#123; let x = onRejected(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if (self.status == 'pending') &#123; promise2 = new Promise(function (resolve, reject) &#123; self.onResolvedCallbacks.push(function (value) &#123; try &#123; let x = onFulfilled(value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); self.onRejectedCallbacks.push(function (value) &#123; try &#123; let x = onRejected(value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; return promise2;&#125;Promise.prototype.catch = function (onRejected) &#123; return this.then(null, onRejected);&#125;Promise.all = function (promises) &#123; return new Promise(function (resolve, reject) &#123; let result = []; let count = 0; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(function (data) &#123; result[i] = data; if (++count == promises.length) &#123; resolve(result); &#125; &#125;, function (err) &#123; reject(err); &#125;); &#125; &#125;);&#125;Promise.deferred = Promise.defer = function () &#123; var defer = &#123;&#125;; defer.promise = new Promise(function (resolve, reject) &#123; defer.resolve = resolve; defer.reject = reject; &#125;) return defer;&#125;/** * npm i -g promises-aplus-tests * promises-aplus-tests Promise.js */try &#123; module.exports = Promise&#125; catch (e) &#123;&#125;","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"12. JavaScript(ES6) 中条件语句","slug":"es6/12.JavaScript(ES6) 中条件语句","date":"2019-03-03T07:12:06.000Z","updated":"2019-06-06T14:23:49.000Z","comments":true,"path":"2019/03/03/es6/12.JavaScript(ES6) 中条件语句/","link":"","permalink":"http://yoursite.com/2019/03/03/es6/12.JavaScript(ES6) 中条件语句/","excerpt":"","text":"使用 Array.includes 来处理多个条件12345function test(fruit) &#123; if (fruit == 'apple' || fruit == 'strawberry') &#123; console.log('red'); &#125;&#125; 优化变成 -&gt;&gt; 12345678function test(fruit) &#123; // 条件提取到数组中 const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; if (redFruits.includes(fruit)) &#123; console.log('red'); &#125;&#125; 减少嵌套，提前使用 return 语句1234567891011121314151617181920212223function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1：fruit 必须有值 if (fruit) &#123; // 条件 2：必须为红色 if (redFruits.includes(fruit)) &#123; console.log('red'); // 条件 3：数量必须大于 10 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125; &#125; &#125; else &#123; throw new Error('No fruit!'); &#125;&#125; // 测试结果test(null); // 抛出错误：No fruitstest('apple'); // 打印：redtest('apple', 20); // 打印：red，big quantity 优化 123456789101112131415161718/* 在发现无效条件时提前 return */ function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1：提前抛出错误 if (!fruit) throw new Error('No fruit!'); // 条件2：必须为红色 if (redFruits.includes(fruit)) &#123; console.log('red'); // 条件 3：数量必须大于 10 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125; &#125;&#125; 为了减少一个嵌套层级，优化编码风格 123456789101112131415/* 在发现无效条件时提前 return */ function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; if (!fruit) throw new Error('No fruit!'); // 条件 1：提前抛出错误 if (!redFruits.includes(fruit)) return; // 条件 2：当 fruit 不是红色的时候，提前 return console.log('red'); // 条件 3：必须是大量存在 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125;&#125; 使用函数的默认参数 和 解构12345678910function test(fruit, quantity) &#123; if (!fruit) return; const q = quantity || 1; // 如果没有提供 quantity 参数，则默认为 1 console.log(`We have $&#123;q&#125; $&#123;fruit&#125;!`);&#125; // 测试结果test('banana'); // We have 1 banana!test('apple', 2); // We have 2 apple! 但是q在这边不直观所有优化 12345678function test(fruit, quantity = 1) &#123; // i如果没有提供 quantity 参数，则默认为 1 if (!fruit) return; console.log(`We have $&#123;quantity&#125; $&#123;fruit&#125;!`);&#125; // 测试结果test('banana'); // We have 1 banana!test('apple', 2); // We have 2 apple! 但是这边 也可能是个对象 12345678910// 解构 —— 只获得 name 属性// 参数默认分配空对象 &#123;&#125;function test(&#123;name&#125; = &#123;&#125;) &#123; console.log (name || 'unknown');&#125; //测试结果test(undefined); // unknowntest(&#123; &#125;); // unknowntest(&#123; name: 'apple', color: 'red' &#125;); // apple 选择 Map / Object 字面量，而不是Switch语句1234567891011121314151617function test(color) &#123; // 使用 switch case 语句，根据颜色找出对应的水果 switch (color) &#123; case 'red': return ['apple', 'strawberry']; case 'yellow': return ['banana', 'pineapple']; case 'purple': return ['grape', 'plum']; default: return []; &#125;&#125; //测试结果test(null); // []test('yellow'); // ['banana', 'pineapple'] 这边建议使用对象，更加清晰 12345678910// 使用对象字面量，根据颜色找出对应的水果 const fruitColor = &#123; red: ['apple', 'strawberry'], yellow: ['banana', 'pineapple'], purple: ['grape', 'plum'] &#125;; function test(color) &#123; return fruitColor[color] || [];&#125; 但是这边是很有可能为网络数据，无法判断red这样的变量，那么就用arry.filter 来过滤 1234567891011121314const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'strawberry', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'pineapple', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125;, &#123; name: 'plum', color: 'purple' &#125;]; function test(color) &#123; // 使用 Array filter ，根据颜色找出对应的水果 return fruits.filter(f =&gt; f.color == color);&#125; 使用 Array.every 和 Array.some 来处理全部/部分满足条件我们想检查所有水果是否都是红色的 1234567891011121314151617const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125; ]; function test() &#123; let isAllRed = true; // 条件：所有的水果都必须是红色 for (let f of fruits) &#123; if (!isAllRed) break; isAllRed = (f.color == 'red'); &#125; console.log(isAllRed); // false&#125; 使用 arry.every来过滤 123456789101112const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125; ]; function test() &#123; // 条件：简短方式，所有的水果都必须是红色 const isAllRed = fruits.every(f =&gt; f.color == 'red'); console.log(isAllRed); // false&#125; 如果我们想要检查是否有至少一个水果是红色的，我们可以使用 Array.some 仅用一行代码就实现出来 123456789101112const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125;]; function test() &#123; // 条件：是否存在红色的水果 const isAnyRed = fruits.some(f =&gt; f.color == 'red'); console.log(isAnyRed); // true&#125;","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"10. 集合","slug":"es6/10.集合","date":"2019-03-03T06:12:06.000Z","updated":"2019-06-06T14:16:39.000Z","comments":true,"path":"2019/03/03/es6/10.集合/","link":"","permalink":"http://yoursite.com/2019/03/03/es6/10.集合/","excerpt":"","text":"10.1 Set 一个Set是一堆东西的集合，Set 有点像数组，不过跟数组不一样的是，Set里面不能有重复的内容 1234567891011121314var books = new Set();books.add('js');books.add('js');//添加重复元素的集合元素个数不会变化books.add('html');books.forEach(function(book)&#123; // 循环集合 console.log(book);&#125;)console.log(book.size);//集合中元数的个数console.log(books.has('js'));//判断集合是否有此元素books.delete('js');console.log(books.size);console.log(books.has('js'));books.clear();//清空setconsole.log(books.size); 10.2 Map 可以使用Map来组织这个名值对的数据 1234567891011var books = new Map();books.set('js',&#123;name:'js'&#125;);//向map中添加元素books.set('html',&#123;name:'html'&#125;);console.log(books.size);//查看集合中的元素console.log(books.get('js'));//通过key获取值books.delete('js');//执行key删除元素console.log(books.has('js'));//判断map中有没有keybook.forEach((value,key)=&gt;&#123; console.log(key+'='+value);&#125;)books.clear();//清空map","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"11 模块","slug":"es6/11.模块","date":"2019-03-03T06:12:06.000Z","updated":"2019-06-06T14:17:33.000Z","comments":true,"path":"2019/03/03/es6/11.模块/","link":"","permalink":"http://yoursite.com/2019/03/03/es6/11.模块/","excerpt":"","text":"可以根据应用的需求吧代码分成不同的模块，每个模块里可以导出它需要让其他模块使用的东西，在其他模块里面可以导入这些模块，导出的东西。 在浏览器中使用模块需要借助 导出 12export var name = 'wjh';export var age = 8; 导入 123//import &#123;name,age&#125; from './school.js';import * as school from './school.js';console.log(school.name,school.age); 在页面中引用 1234&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/traceur.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/BrowserSystem.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://google.github.io/traceur-compiler/src/bootstrap.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt; 重命名导出时重命名 1234function say()&#123; console.log('say');&#125;export &#123;say as say2&#125;; 导入时重命名 1import &#123;say2 as say3&#125; from &apos;./school.js&apos; 11.3 默认导出每个模块都可以有一个默认要导出的东西 123export default function say()&#123; console.log('say')&#125; 导入 1import say from './school.js' 11.4 深度克隆123456789101112131415161718192021222324252627282930313233343536373839var parent = &#123; age: 5, hobby: [1, 2, 3], home: &#123;city: '北京'&#125;,&#125;;var child = extendDeep(parent);child.age = 6;child.hobby.push('4');child.home.city = '广东';console.log('child ', child); //[1, 2, 3, 4]console.log('parent ', parent);function extend(parent) &#123; let child; if (Object.prototype.toString.call(parent) == '[object Object]') &#123; child = &#123;&#125;; for (let key in parent) &#123; child[key] = extend(parent[key]) &#125; &#125; else if (Object.prototype.toString.call(parent) == '[object Array]') &#123; child = parent.map(item =&gt; extend(item)); &#125; else &#123; return parent; &#125; return child;&#125;function extendDeep(parent, child) &#123; child = child || &#123;&#125;; for (var key in parent) &#123; if (typeof parent[key] === \"object\") &#123; child[key] = (Object.prototype.toString.call(parent[key]) === \"[object Array]\") ? [] : &#123;&#125;; extendDeep(parent[key], child[key]); &#125; else &#123; child[key] = parent[key]; &#125; &#125; return child;&#125;","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"9. 生成器(Generator)与迭代器(Iterator)","slug":"es6/9.生成器(Generator)与迭代器(Iterator)","date":"2019-03-03T05:12:06.000Z","updated":"2019-06-06T14:16:04.000Z","comments":true,"path":"2019/03/03/es6/9.生成器(Generator)与迭代器(Iterator)/","link":"","permalink":"http://yoursite.com/2019/03/03/es6/9.生成器(Generator)与迭代器(Iterator)/","excerpt":"","text":"Generator 是一个特殊的函数，执行它会返回一个Iterator对象。通过遍历迭代器，Generator函数运行后悔返回遍历器对象，而不是函数的返回值。 Iterators模拟迭代器有一个next方法，每次执行的时候会返回一个对象 对象里面有两个函数，一个是value表示返回的值，还有就是布尔值done，表示是迭代完成 1234567891011121314151617181920function buy(books)&#123; let i = 0; return&#123; next()&#123; let done = i ===books.length; let value = !done ? books[i++]:undefined; return &#123; value:value, done:done &#125; &#125; &#125;&#125;let iterators = buy(['js','html']);var curr;do&#123; curr = iterators.next(); console.log(curr);&#125;while(!curr.done); Generators生成器用于创建迭代器 1234567891011function* buy(boos)&#123; for(var i=0;i&lt;boos.length;i++)&#123; yield books[i]; &#125;&#125;let buying = buy(['js','html]);var curr;do &#123; curr = buying.next(); console.log(curr);&#125;while(!curr.done);","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"8. 类","slug":"es6/8.类","date":"2019-03-03T03:12:06.000Z","updated":"2019-06-06T14:15:30.000Z","comments":true,"path":"2019/03/03/es6/8.类/","link":"","permalink":"http://yoursite.com/2019/03/03/es6/8.类/","excerpt":"","text":"class使用 class 这个关键词定义一个类，基于这个创建实例以后就会创建 constructor 方法，此方法可以用来初始化 12345678910111213class Person&#123; constructor(name)&#123; this.name = name; &#125; getName()&#123; console.log(this.name) &#125;&#125;let person = new Person('wjh');person.getName(); get与setgetter 可以用来获取属性,setter 可以去设置属性 123456789101112131415class Person &#123; constructor()&#123; this.hobbies = []; &#125; set hobby(hobby)&#123; this.hobbies.push(hobby); &#125; get hobby()&#123; return this.hobbies; &#125;&#125;let person = new Person();person.hobby = 'aa';person.hobby = 'bb';console.log(person.hobby) 静态方法-static在类里面添加静态的方法可以使用static 这个关键词，静态方法就是不需要实例化类就能使用的方法 123456class Person&#123; static add(a,b)&#123; return a+b; &#125;&#125;console.log(Person.add(1,x)); 继承extends一个类可以继承其他的类里的东西 123456789101112131415class Person&#123; constructor(name)&#123; this.name = name; &#125;&#125;class Teacher extends Person&#123; constructor(name,age)&#123; super(name); this.age = age; &#125;&#125;var teacher = Teacher('wjh',8);console.log(teacher.name,teacher.age)","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"7. 对象","slug":"es6/7.对象","date":"2019-03-02T10:12:06.000Z","updated":"2019-06-06T14:14:48.000Z","comments":true,"path":"2019/03/02/es6/7.对象/","link":"","permalink":"http://yoursite.com/2019/03/02/es6/7.对象/","excerpt":"","text":"对象字面量如果你想在对象里添加跟变量名一样的属性，并且属性的值就是变量表示的值就可以直接在对象里加上这些属性 1234567891011let name = 'wjh';let age = 8;let getName = function()&#123; console.log(this.name)&#125;let person =&#123; name, age, getName&#125;person.getName(); 7.2 Object.is 对比两个值是否相等 1console.log(Object.is(NaN,NaN)); Object.assign把多个对象的属性复制到一个对象中，第一个参数是复制的对象，从第二个参数开始往后，都是复制的源对象 12345678910var nameObj = &#123;name:'wjh'&#125;var ageObj = &#123;age:8&#125;;var obj = &#123;&#125;;Object.assign(obj,nameObj,ageObj);console.log(obj);//克隆对象function clone(obj)&#123; return Object.assgin(&#123;&#125;,obj);&#125; Object.setPrototypeOf将一个指定的对象原型设置为另一个对象或者null 123456789var obj1 = &#123;name:'wjh1'&#125;;var obj2 = &#123;name:'wjh2'&#125;;var obj = &#123;&#125;;Object.setPrototypeOf(obj,obj1);console.log(obj.name);console.log(Object.getPrototypeOf(obj));Object.setProtoypeOF(obj,obj2);console.log(obj.name);console.log(Object.getPrototypeOf(obj)); proto直接对象表达式中设置prototype 123456var obj1 = &#123;name:&apos;wjh&apos;&#125;;var obj3 = &#123; _proto_:obj1&#125; console.log(obj3.name);console.log(Object.getPrototypeOf(obj3)); super通过super可以调用protype上的属性或方法 123456789101112let person =&#123; eat()&#123; return 'milk'; &#125;&#125;let student = &#123; _proto_:person, eat()&#123; return super.eat()+'bead' &#125;&#125;console.log(student.eat());","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"6. 数组的新方法","slug":"es6/6.数组的新方法","date":"2019-03-02T09:12:06.000Z","updated":"2019-06-06T14:13:24.000Z","comments":true,"path":"2019/03/02/es6/6.数组的新方法/","link":"","permalink":"http://yoursite.com/2019/03/02/es6/6.数组的新方法/","excerpt":"","text":"1234567891011121314151617181920212223// 相同的阵列var people = [ &#123; name : 'Casper' , like : '锅烧意面' , age : 18 &#125;, &#123; name : 'Wang' , like : '炒面' , age : 24 &#125;, &#123; name : 'Bobo' , like : '萝卜泥' , age : 1 &#125;, &#123; name : '卤蛋' , like : '萝卜泥' , age : 3 &#125;]; filter() filter() 会回传一个阵列，其条件是return 后方为true 的物件，很适合用在搜寻符合条件的资料。 12345678var filterEmpty = people.filter( function ( item, index, array ) &#123;&#125;);console .log(filterEmpty); //没有条件，会是一个空阵列var filterAgeThan5 = people.filter( function ( item, index, array ) &#123; return item.age &gt; 5 ; //取得大于五岁的 如果这边符合条件 只要为ture即可&#125;);console .log(filterAgeThan5); // Casper, Wang这两个物件 find() find()与filter()很像，但find() 只会回传一次值，且是第一次为true的值。 12345678910111213var findEmpty = people.find( function ( item, index, array ) &#123;&#125;);console .log(findEmpty); //没有条件，会是undefinedvar findAgeThan5 = people.find( function ( item, index, array ) &#123; return item.age &gt; 5 ; //取得大于五岁的&#125;);console .log(findAgeThan5); //虽然答案有两个，但只会回传Casper这一个物件var findLike = people.find( function ( item, index, array ) &#123; return item.like === '萝卜泥' ; //取得阵列like === '萝卜泥'&#125;);console .log(findLike); //虽然答案有两个，但只会回传第一个Bobo物件 forEach() forEach 是这几个阵列函式最单纯的一个，不会额外回传值，只单纯执行每个阵列内的物件或值。 1234567891011var forEachIt = people.forEach( function ( item, index, array ) &#123; console .log(item, index, array); //物件,索引,全部阵列 return item; // forEach没在return的，所以这边写了也没用&#125;);console .log(forEachIt); // undefinedpeople.forEach( function ( item, index, array ) &#123; item.age = item.age + 1 ; // forEach就如同for，不过写法更容易&#125;);console .log(people); //全部age + 1 map() 使用map() 时他需要回传一个值，他会透过函式内所回传的值组合成一个阵列。如果不回传则是 undefined回传数量等于原始阵列的长度这很适合将原始的变数运算后重新组合一个新的阵列。 12345678910111213141516171819202122232425var mapEmpty = people.map( function ( item, index, array ) &#123;&#125;);console .log(mapEmpty); // [undefined, undefined, undefined, undefined]var mapAgeThan5 = people.map( function ( item, index, array ) &#123; return item.age &gt; 5 ; //比较大于五岁的&#125;);console .log(mapAgeThan5); // [true, true, false, false]var mapAgeThan5_2 = people.map( function ( item, index, array ) &#123; // 错误示范 if (item.age &gt; 5 ) &#123; return item; //回传大于五岁的 &#125; return false ; //别以为空的或是false就不会回传&#125;);console .log(mapAgeThan5_2); // [&#123;name: 'Casper'...&#125;, &#123;name: 'Wang'...&#125;, false, false]var mapEat = people.map( function ( item, index, array ) &#123; if (item.like !== '萝卜泥' ) &#123; return ` $&#123;item.like&#125;好吃` ; &#125; else &#123; return ` $&#123;item.like&#125;不好吃` ; &#125;&#125;);console .log(mapEat); // [\"锅烧意面好吃\", \"炒面好吃\", \"萝卜泥不好吃\", \"萝卜泥不好吃\"] every() every()可以检查所有的阵列是否符合条件，这仅会回传一个值trueor false，可以用来检查阵列中的内容是否符合特定条件。 12345678910var ans = array.every( function ( item, index, array ) &#123; console .log(item, index, array); //物件,索引,全部阵列 return item.age &gt; 10 //当全部age大于10才能回传true&#125;);console .log(ans); // false:只要有部分不符合，则为falsevar ans2 = array.every( function ( item, index, array ) &#123; return item.age &lt; 25&#125;);console .log(ans2); // true:全部age都小于25 some() some() 与every() 非常接近，都是回传true or false，差异仅在every() 需完全符合，some() 仅需要部分符合。 1234567891011121314var ans = people.some( function ( item, index, array ) &#123; return item.age &gt; 10 //当全部age大于10才能回传true&#125;);console .log(ans); // true:只要有部分符合，则为truevar ans2 = people.some( function ( item, index, array ) &#123; return item.age &lt; 25&#125;);console .log(ans2); // true:只要有部分符合，则为true var ans2 = people.some( function ( item, index, array ) &#123; return item.age &gt; 25&#125;);console .log(ans2); // false:全部都不符合则为false reduce() reduce() 和其他几个差异就很大了，他可以与前一个回传的值再次作运算，参数包含以下：accumulator: 前一个参数，如果是第一个阵列的话，值是以另外传入或初始化的值currentValue: 当前变数currentIndex: 当前索引array: 全部阵列 12345678910111213141516var reduceEmpty = people.reduce( function ( accumulator, currentValue, currentIndex, array ) &#123;&#125;);console .log(reduceEmpty); //没有条件，会是undefinedvar reducePlus = people.reduce( function ( accumulator, currentValue, currentIndex, array ) &#123; // 分别为前一个回传值, 目前值, 当前索引值 console .log(accumulator, currentValue, currentIndex); return accumulator + currentValue.age; //与前一个值相加&#125;, 0 ); //传入初始化值为0console .log(reducePlus); //总和为46var reducePlus = people.reduce( function ( accumulator, currentValue, currentIndex, array ) &#123; console .log( 'reduce' , accumulator, currentValue, currentIndex) return Math .max( accumulator, currentValue.age ); //与前一个值比较哪个大&#125;, 0 );console .log(reducePlus); //最大值为24","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"5. 函数","slug":"es6/5.函数","date":"2019-03-02T08:12:06.000Z","updated":"2019-06-06T14:11:39.000Z","comments":true,"path":"2019/03/02/es6/5.函数/","link":"","permalink":"http://yoursite.com/2019/03/02/es6/5.函数/","excerpt":"","text":"默认参数可以给定义的函数接收的参数设置默认的值 在执行这个函数的时候，如果不指定函数的参数的值，就会使用参数的这些默认的值。 12345function ajax(url,method='GET',dataType=\"json\")&#123; console.log(url); console.log(method); console.log(dataType);&#125; 展开操作符把…放在数组前面可以把一个数组进行展开，可以把一个函数而不需要使用apply 1234567891011121314151617181920212223//传入参数let print = function(a,b,c)&#123; console.log(a,b,c);&#125;print([1,2,3]);print(...[1,2,3]);// 可以替代applyvar m1 = Math.max.apply(null, [8, 9, 4, 1]);var m2 = Math.max(...[8, 9, 4, 1]);// 可以替代concatvar arr1 = [1, 3];var arr2 = [3, 5];var arr3 = arr1.concat(arr2);var arr4 = [...arr1, ...arr2];console.log(arr3,arr4);//类数组的转数组function max(a,b,c) &#123; console.log(Math.max(...arguments));&#125;max(1, 3, 4); 剩余操作符剩余操作符可以把其余参数的值放在一个叫做b的数组里 1234let rest = function(a,...rest)&#123; console.log(a,rest);&#125;rest(1,2,3); 解构参数1234let destruct = function(&#123;name,age&#125;)&#123; console.log(name,age);&#125;destruct(&#123;name:'wjh',age:10&#125;) 箭头函数箭头函数简化了函数的定义方式 1[1,2,3].forEach(val=&gt;console.log(val)); 输入参数如果多于一个要用()包含，函数体如果有多条语句需要用{}包起来 箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。 正是因为它没有this，从而避免了this指向的问题。 12345678var person = &#123; name:'wjh', getName:function()&#123;- setTimeout(function()&#123;console.log(this);&#125;,1000); //在浏览器执行的话this指向window+ setTimeout(() =&gt; console.log(this),1000);//在浏览器执行的话this指向person &#125;&#125;person.getName();","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"4. 字符串","slug":"es6/4.字符串","date":"2019-03-02T07:12:06.000Z","updated":"2019-06-06T14:07:26.000Z","comments":true,"path":"2019/03/02/es6/4.字符串/","link":"","permalink":"http://yoursite.com/2019/03/02/es6/4.字符串/","excerpt":"","text":"模板字符串模板字符串用反应号(数字1左边的那个建)包含，用${}括起来 12345678910var name = 'zfpx',age = 8;let desc = `$&#123;name&#125; is $&#123;age&#125; old!`;console.log(desc);//所有模板字符串的空格和换行，都是被保留的var str = `&lt;ul&gt;&lt;li&gt;a&lt;/li&gt;&lt;li&gt;b&lt;/li&gt;&lt;/ul&gt;`;console.log(str); 其中的变量会用变量的值替换掉 12345function replace(desc)&#123; return desc.replace(/\\$\\&#123;([^&#125;]+)\\&#125;/g,function(matched,key)&#123; return eval(key); &#125;);&#125; 带标签的模板字符串可以在模板字符串的前面添加一个标签，这个标签可以去处理模板字符串 标签其实就是一个函数,函数可以接收两个参数,一个是 strings 就是模板字符串里的每个部分的字符 还有一个参数可以使用rest的形式values,这个参数里面是模板字符串里的值。 12345var name = 'wjh',age = 8;function desc(strings,...values)&#123; console.log(strings,values);&#125;desc`$&#123;name&#125; is $&#123;age&#125; old!`; 字符串新方法 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 1234var s = 'wjh';s.startsWith('w') // trues.endsWith('h') // trues.includes('j') // true 第二个参数，表示开始搜索的位置 1234var s = &apos;wjh&apos;;console.log(s.startsWith(&apos;j&apos;,2)); // trueconsole.log(s.endsWith(&apos;j&apos;,2)); // trueconsole.log(s.includes(&apos;j&apos;,2)); // false endsWith的行为与其他其他方法有所不同。它针对前n个字符，而其他方法是从第几位开始到字符串结束 repeatrepeat 方法返回一个新字符串，表示将原字符串重复n次。 12&apos;x&apos;.repeat(3);&apos;x&apos;.repeat(0);","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"3. 解构","slug":"es6/3.解构","date":"2019-03-02T06:21:58.000Z","updated":"2019-06-06T14:05:34.000Z","comments":true,"path":"2019/03/02/es6/3.解构/","link":"","permalink":"http://yoursite.com/2019/03/02/es6/3.解构/","excerpt":"解构意思就是分解一个东西的结构,可以用一种类似数组的方式定义N个变量，可以将一个数组中的值按照规则赋值过去。","text":"解构意思就是分解一个东西的结构,可以用一种类似数组的方式定义N个变量，可以将一个数组中的值按照规则赋值过去。 12var [name,age]=['wjh',8];console.log(name,age); 嵌套赋值12345678910let [x,[y],z]=[1,[2.1]];console.log(x,y,z);let [x,[y,z]] = [1,[2.1,2.2]];console.log(x,y,z);let [json,arr,num] = [&#123;name:'wjw'&#125;,[1,2],3];console.log(json,arr,num);// 1 2.1 undefined 1 2.1 2.2 &#123; name: 'wjw' &#125; [ 1, 2 ] 3 省略赋值12let [,,x]=[1,2,3]console.log(x); 解构对象对象也可以被解构 123456var obj = &#123;name:'zfpx',age:8&#125;;//对象里的name属性的值会交给name这个变量，age的值会交给age这个变量var &#123;name,age&#125; = obj//对象里的name属性的值会交给myname这个变量，age的值会交给myage这个变量let &#123;name: myname, age: myage&#125; = obj;console.log(name,age,myname,myage); 默认值在赋值和传参的时候可以使用默认值 12345678910111213141516let [a='a',b='b',c=new Error('C必须指定')] = [1, , 3];console.log(a,b,c);function ajax(options)&#123; var method = options.method || \"get\"; var data = options.data || &#123;&#125;;&#125;function ajax(method='get',data)&#123; console.log(arguments);&#125;ajax(&#123; method:'post', data:&#123;'name':'wjh'&#125;&#125;)","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"2. 常量","slug":"es6/2.常量","date":"2019-03-02T05:21:58.000Z","updated":"2019-06-06T14:04:13.000Z","comments":true,"path":"2019/03/02/es6/2.常量/","link":"","permalink":"http://yoursite.com/2019/03/02/es6/2.常量/","excerpt":"使用 const 我们可以声明一个常量，一旦声明之后，就不可以更改。","text":"使用 const 我们可以声明一个常量，一旦声明之后，就不可以更改。 使用 const 我们可以声明一个常量，一旦声明之后，就不可以更改。 常量不能重新赋值12const MY_NAME = 'zfpx';MY_NAME = 'zfpx2';//Assignment to constant variable 变量可以改变 注意const限制的是不能给变量重新赋值，而变量的值本身是可以改变的,下面的操作是可以的 123const names = ['zfpx1'];names.push('zfpx2');console.log(names); 不同的块级作用域可以多次定义123456789101112const A = \"0\";&#123; const A = \"A\"; console.log(A)&#125;&#123; const A = \"B\"; console.log(A)&#125;console.log(A)// 结果 A B 0","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]},{"title":"1. 作用域变量","slug":"es6/1.作用域变量","date":"2019-03-01T03:12:06.000Z","updated":"2019-06-06T08:33:09.000Z","comments":true,"path":"2019/03/01/es6/1.作用域变量/","link":"","permalink":"http://yoursite.com/2019/03/01/es6/1.作用域变量/","excerpt":"作用域就是变量的作用范围。也就是你声明一个变量以后，这个变量可以在什么场合下使用。以前的JavaScript只有全局作用域，和函数作用域。","text":"作用域就是变量的作用范围。也就是你声明一个变量以后，这个变量可以在什么场合下使用。以前的JavaScript只有全局作用域，和函数作用域。 作用域就是变量的作用范围。也就是你声明一个变量以后，这个变量可以在什么场合下使用。以前的JavaScript只有全局作用域，和函数作用域。 var的问题1.var 没有块级作用域，定义后在当前包中都都可以访问，如果变量名重复，就会覆盖前面定义的变量，并且很可以被他人修改。 1234if(true)&#123; var a = &quot;a&quot;; //期望a是某一个值&#125;console.log(a); 2.var 在for循环标记变量共享，一般在循环中会使用的i会被共享，其本质也是由于没有块级作用域造成的 123456789101112131415for (var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; alert(i); &#125;, 0); &#125; // 结果就是 弹窗三次 3 for ( i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; alert(i); &#125;, 0); &#125; // 结果就是 弹窗三次 0-2 块级作用域在用var定义变量的时候，变量通过闭包进行隔离的，现在用了let，不仅仅可以通过闭包隔离，还可以增加了一些块级作用域隔离。块级作用用一组大括号定义一个快，使用let定义的变量字啊大括号的外面是访问不到的。 实现会计作用域12345if(ture)&#123; let name = &apos;wjh&apos;&#125;consloe.log(&apos;name&apos;); // ReferenceError: name is not defined 不会污染全局对象 1234if(ture)&#123; let name = &apos;wjh&apos;&#125;console.log(window.name); // undefined for 循环中也可以使用i 123456789// 嵌套循环不会相互影响for (let i = 0; i &lt; 3; i++) &#123; console.log(&quot;out&quot;, i); for (let i = 0; i &lt; 2; i++) &#123; console.log(&quot;in&quot;, i); &#125;&#125;// 结果 out 0 in 0 in 1 out 1 in 0 in 1 out 2 in 0 in 1 重复定义会报错1234if(ture)&#123; let a = 1; let a = 2; //Identifier &apos;a&apos;&#125; 不存在变量的预解释123456for(let i = 0;i&lt;2;i++)&#123; console.log(&apos;inner&apos;,i); let i =100;&#125;// 结果 i is not defined 闭包的新写法123;(function()&#123;&#125;)(); 现在 123&#123;&#125;","categories":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/categories/ECMAScript-6入门/"}],"tags":[{"name":"ECMAScript 6入门","slug":"ECMAScript-6入门","permalink":"http://yoursite.com/tags/ECMAScript-6入门/"}]}]}