<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> 4.JS数据类型 · AsGiant-bolg</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="4.JS数据类型 - Mason Mei"><meta name="keywords"><meta name="author" content="Mason Mei"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="AsGiant-bolg"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/2019/06/05/resume/" target="_self" data-hover="简历" class="nav-list-link">简历</a></li><li class="nav-list-item"><a href="tel:17621515830" target="_self" data-hover="联系我" class="nav-list-link">联系我</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">4.JS数据类型</h1><div class="post-info">2019-04-09<p class="visit"><i data-identity="2019/04/09/JavaScript基础入门/4 JS数据类型/" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型（值类型）"><a href="#基本数据类型（值类型）" class="headerlink" title="基本数据类型（值类型）"></a>基本数据类型（值类型）</h3><ul>
<li>Number  数字</li>
<li>String  字符串<ul>
<li>单引号包裹起来的都是字符串(单双号没有区别)</li>
</ul>
</li>
<li>Boolean  布尔<ul>
<li>true false =&gt; 布尔值只有两个值</li>
</ul>
</li>
<li>null 空对象指针</li>
<li>undefined  未定义</li>
</ul>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><ul>
<li>{}  普通对象</li>
<li>[]  数组</li>
<li>/^$/ 正则</li>
<li>…</li>
</ul>
<h3 id="function数据类型"><a href="#function数据类型" class="headerlink" title="function数据类型"></a>function数据类型</h3><ul>
<li>funciotn fn (){}</li>
</ul>
<h2 id="数据类型检查"><a href="#数据类型检查" class="headerlink" title="数据类型检查"></a>数据类型检查</h2><ul>
<li>typeof<ul>
<li>用来检测数据类型的运算符</li>
</ul>
</li>
<li>instanceod<ul>
<li>检测某个实例是否属于这个类</li>
</ul>
</li>
<li>constructor <ul>
<li>获取当前实例的构造器</li>
</ul>
</li>
<li>Object prototype.toSting.call()<ul>
<li>获取当前实例的所属类信息</li>
</ul>
</li>
</ul>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>操作符<br>typeof 是用来检测给定变量的数据类型的操作符。对一个值使用 typeof 操作符可能返回下列某个字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"undefined"</span></span><br><span class="line"><span class="string">"boolean"</span></span><br><span class="line"><span class="string">"string"</span></span><br><span class="line"><span class="string">"number"</span></span><br><span class="line"><span class="string">"object"</span> <span class="comment">// 如果这个值是对象或者null "function"</span></span><br></pre></td></tr></table></figure>

<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><blockquote>
<p>Boolean()</p>
</blockquote>
<ul>
<li>把其他数据类型的值转化为布尔类型</li>
<li>只有0、Nan、null、undefined这五个数据值转换为布尔类型的false，其余的都会变成true</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/271124/1552208177369-64842834-6cfb-404d-81bf-8aebbb3ccd6a.png#align=left&display=inline&height=305&name=image.png&originHeight=812&originWidth=412&size=151327&status=done&width=155" alt="image.png"></p>
<blockquote>
<p>叹号在JS中海油一个作用：取反，先把值转换为布尔类型，然后再去取反</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/271124/1552208350624-3136c9bb-8da6-4d5a-9f28-79a81a3a0b7d.png#align=left&display=inline&height=109&name=image.png&originHeight=218&originWidth=98&size=14063&status=done&width=49" alt="image.png"></p>
<p><code>!!</code></p>
<blockquote>
<p>在叹号取反的基础上取反，取反两次相当于没有操作，但是却已经其他类型值转化为布尔类型了，和Boolean是相同的效果  </p>
</blockquote>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><blockquote>
<p>在JS中单引号和双引号包起来的都是字符串</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span> - &gt; number</span><br><span class="line"><span class="string">'12'</span> -&gt; string</span><br><span class="line"><span class="string">'[12,23]'</span> -&gt; string</span><br></pre></td></tr></table></figure>

<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>第一种是使用几乎每个值都有的 toString()方法。多数情况下，调用 toString() 方法不必传递参数，但在调用数值的 toString()方法时，可以传递一个参数：输出数值的基数。默认情况下，toString() 方法以十进制格式返回数值的字符串表示。而通过传递基数，toString() 可以输出二进制、八进制、十六进制等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">alert(num.toString());    <span class="comment">// "10"</span></span><br><span class="line">alert(num.toString(<span class="number">2</span>));  <span class="comment">// "1010"</span></span><br><span class="line">alert(num.toString(<span class="number">8</span>));  <span class="comment">// "12"</span></span><br><span class="line">alert(num.toString(<span class="number">10</span>));  <span class="comment">// "10"</span></span><br><span class="line">alert(num.toString(<span class="number">16</span>));  <span class="comment">// "A"</span></span><br></pre></td></tr></table></figure>

<p>常用方法<br><img src="https://cdn.nlark.com/yuque/0/2019/png/271124/1552212096220-2e8a4a63-4ef0-4168-9a4a-466a64dfe772.png#align=left&display=inline&height=189&name=image.png&originHeight=276&originWidth=266&size=51778&status=done&width=182" alt="image.png"></p>
<h3 id="number数字"><a href="#number数字" class="headerlink" title="number数字"></a>number数字</h3><blockquote>
<p>0 12-22 12.5 js中多增加了一个number类型的数据NaN  typeof NaN -&gt; Number</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intNum = <span class="number">55</span>; <span class="comment">// 十进制整数 var octalNum1 = 070; // 八进制的56</span></span><br><span class="line"><span class="keyword">var</span> octalNum1 = <span class="number">079</span>; <span class="comment">// 无效的八进制数值——解析为79 </span></span><br><span class="line"><span class="keyword">var</span> octalNum1 = <span class="number">08</span>; <span class="comment">// 无效的八进制数值——解析为8 </span></span><br><span class="line"><span class="keyword">var</span> hexNum1 = <span class="number">0xA</span>;  <span class="comment">// 十六进制的10</span></span><br><span class="line"><span class="keyword">var</span> hexNum2 = <span class="number">0x1F</span>; <span class="comment">// 十六进制的31</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，八进制字面量在严格模式下是无效的，会导致抛出错误。</p>
</blockquote>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>ECMAScript 能够表示的最小数值保存在 Number.MIN_VALUE 中——在多数浏览器中，这个值是 5e-324；能够 Number.MAX_VALUE 中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果某次计算的结果得到了一个超过JavaScript 数值范围的值，那么这个数值将会自动转换为 Infinity 值，如果这个数值是负数，则会转换成 -Infinity（负无穷），如果这个数值是正数，则会转换成Infinity（正无穷）。要确定一个数值是不是有穷的，可以使用 isFinite() 函数。</p>
<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><ul>
<li>not a numer : 不是一个数，但是属于number类型</li>
<li>NaN == NaN ： false , NaN 和任何其他值都不相等</li>
</ul>
<h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3><ul>
<li>用来检测当前这个值是否是非有效数字，如果不是有效数字，检测的结果是true , 反之是有效数字则为false</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="number">0</span>)   <span class="comment">// -&gt;false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// -&gt;true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当我们使用isNaN检测值的时候，检测的值不是number类型的，浏览器默认的吧值先转换为number类型，任何再去检测</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="string">'12'</span>) <span class="comment">//-&gt;false</span></span><br></pre></td></tr></table></figure>

<h3 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h3><ul>
<li>把其他数据类型值转化成number类型的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'12'</span>) <span class="comment">// -&gt; 12</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'12px'</span>) <span class="comment">// -&gt;NaN</span></span><br><span class="line"><span class="comment">// 在使用Number转换的时候只要字符串中出现任何一个非有效数字字符，最后的结果都是NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">//-&gt; 1 </span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>) <span class="comment">//-&gt; 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">//-&gt;NaN</span></span><br></pre></td></tr></table></figure>

<ul>
<li>把引用数据类型转换成number，首先需要吧引用数据类型转为字符串（toString)，在把字符串转换为number即可</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>([]) <span class="comment">// -&gt; ""</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">12</span>]) <span class="comment">// -&gt; 12</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">12</span>,<span class="number">13</span>]) <span class="comment">// -&gt; 12,13 (,是非有效字符) -&gt; NaN</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;<span class="attr">age</span>:<span class="number">12</span>&#125;) <span class="comment">// -&gt;NaN</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;&#125;) <span class="comment">// -&gt; NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="pareInt"><a href="#pareInt" class="headerlink" title="pareInt"></a>pareInt</h3><ul>
<li>也是吧其他数据类型值转换为number，和Number方法在处理字符串的时候有所区别</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'12px'</span>) <span class="comment">// -&gt; NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12px'</span>) <span class="comment">// -&gt; 12</span></span><br></pre></td></tr></table></figure>

<ul>
<li>提取规则：从左到右依次查找有效数字字符，知道遇到非有效数字字符为止（不管后端是否还有，都不找了）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12px13'</span>) <span class="comment">// -&gt; 12</span></span><br></pre></td></tr></table></figure>

<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p>处理整数最常用的还是 parseInt() ，它会忽略字符前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt() 就会返回 NaN；也就是说，用 parseInt() 转换空字符串会返回 NaN 。如果第一个字符是数字字符， parseInt() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。如果字符以“0x”开头且后面跟数字字符，会被解析为 16 进制整数；<br>以“0”开头且后面跟数字字符，会被解析为 8 进制整数。下面给出一些例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"1234blue"</span>);   <span class="comment">// 1234</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">""</span>);     <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">"0xA"</span>);    <span class="comment">// 10(十六进制)</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>);   <span class="comment">// 22</span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseInt</span>(<span class="string">"70"</span>);     <span class="comment">// 70</span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseInt</span>(<span class="string">"0xf"</span>);    <span class="comment">// 15(十六进制)</span></span><br></pre></td></tr></table></figure>

<h3 id="pareFloat"><a href="#pareFloat" class="headerlink" title="pareFloat"></a>pareFloat</h3><ul>
<li>在pareInt的基础上可以识别小数点</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pareInt(<span class="string">'12.5px'</span>) -&gt; <span class="number">12</span></span><br><span class="line">pareFloat(<span class="string">'12.5px'</span>) -&gt; <span class="number">12.5</span></span><br></pre></td></tr></table></figure>

<h2 id="null-和undefined"><a href="#null-和undefined" class="headerlink" title="null 和undefined"></a>null 和undefined</h2><ul>
<li>null : 空，没有</li>
<li>undefined ：未定义，没有</li>
<li>“” : 空字符串，没有</li>
<li>0: 也可以理解为没有</li>
</ul>
<h3 id="空字符串和null的区别"><a href="#空字符串和null的区别" class="headerlink" title="空字符串和null的区别"></a>空字符串和null的区别</h3><ul>
<li>都是去去种树</li>
<li>空字符串属于去挖了个坑，但是没有种任何东西</li>
<li>null属于连坑都没挖</li>
<li>空字符串相对于null来说开辟了内存地址，消耗了那么一丢丢的性能</li>
</ul>
<h3 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a>null和undefined的区别</h3><ul>
<li>null一般都是暂时没有，预期中以后会有的(可能以后也没有达到预期)，在js中null都是手动先赋值为null，后期我们在给其赋具体值</li>
<li>undefined:完全没有预料之内的</li>
</ul>
<h2 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h2><blockquote>
<p>ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性和（或）方法，就可以创建自定义对象，如下所示：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>

<p>每一个对象都是由零到多组 属性名（key键）：属性值(value值) 组成的,或者说有多组键值对组成的，每一组键值对中间用逗号分隔</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><blockquote>
<p>描述这个对象特点特征的</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =&#123;<span class="attr">name</span>:<span class="string">'wjw'</span>,<span class="attr">age</span>:<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><blockquote>
<p>某个属性名对应的属性值或者数字格式的</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.name</span><br><span class="line">obj[<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure>

<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><blockquote>
<p>属性值可以是任何数据类型</p>
</blockquote>
<ul>
<li>对象名.属性名：忽略属性名的单双引号</li>
<li>对象名[属性名]：不能忽略单双引号</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果属性名是数字如何操作</span></span><br><span class="line">obj<span class="number">.0</span> 语法不支持</span><br><span class="line">obj[<span class="number">0</span>] / obj[<span class="string">'0'</span>] 两种都支持</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果操作的属性名在对象中不存在，获取的结果是undefined</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.sex <span class="comment">// -&gt;undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="设置-修改"><a href="#设置-修改" class="headerlink" title="设置/修改"></a>设置/修改</h3><blockquote>
<p>一个对象的属性名是不能重复的（唯一性），如果之前存在就是修改属性值的操作，反之不存在就是新的设置属性的操作</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.sex = <span class="string">'男'</span>;</span><br><span class="line">obj[<span class="string">'age'</span>] = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="假删除-让其属性赋值为null，但是属性还是对象"><a href="#假删除-让其属性赋值为null，但是属性还是对象" class="headerlink" title="假删除:让其属性赋值为null，但是属性还是对象"></a>假删除:让其属性赋值为null，但是属性还是对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.sex = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="真删除-把整个属性都在对象中暴力移出"><a href="#真删除-把整个属性都在对象中暴力移出" class="headerlink" title="真删除:把整个属性都在对象中暴力移出"></a>真删除:把整个属性都在对象中暴力移出</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj.sex</span><br></pre></td></tr></table></figure>

<h3 id="基本数据类型-和-引用数据类型的区别"><a href="#基本数据类型-和-引用数据类型的区别" class="headerlink" title="基本数据类型 和 引用数据类型的区别"></a>基本数据类型 和 引用数据类型的区别</h3><blockquote>
<p>JS是运行在浏览器中的(内核引擎)，浏览器会为JS提供赖以生存的环境（提供给js代码执行的环境）=&gt; 全局作用域window(global)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">var</span> b = a; <span class="comment">// 把A变量存储的值赋值给B</span></span><br><span class="line">b = <span class="number">13</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n =&#123;<span class="attr">name</span>:<span class="string">'wjh'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> m = n;</span><br><span class="line">m.name = <span class="string">'wjw'</span></span><br><span class="line"><span class="built_in">console</span>.log(n.name)</span><br></pre></td></tr></table></figure>

<ul>
<li>基本数据类型是按值操作的：基本数据类型的赋值的时候，是直接把值赋值给变量即可</li>
<li>引用数据类型是按照空间地址（引用地址）来操作的: var n = {name:’wjw’}<ul>
<li>先创建一个变量n</li>
<li>浏览器首先会吧开辟一个新的存储控件（内存控件），目的是吧对象中需要存储的内容（键值对）分别的存储在这个空间中，为了方便后期找到这个空间，浏览器给空间设定一个地址（16进制）</li>
<li>把空间的地址赋值给了变量</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/271124/1552297184317-5a20e4ac-2ac4-4b41-8388-31856879bd7d.png#align=left&display=inline&height=390&name=image.png&originHeight=780&originWidth=906&size=92890&status=done&width=453" alt="image.png"></p>
<p><a name="08ed45a7"></a></p>
<h3 id="4-9-function数据类型"><a href="#4-9-function数据类型" class="headerlink" title="4.9 function数据类型"></a>4.9 function数据类型</h3><blockquote>
<p>函数数据类型也要按照引用地址来操作的</p>
</blockquote>
<p>函数:具备一定功能的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =&gt; 创建函数:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//=&gt; 函数体:实现某一个功能的具体JS代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; 执行函数:相当于使用洗衣机洗衣服(如果函数只创建了，但是没有去执行，函数没有任何的意义)</span></span><br><span class="line"><span class="comment">// 函数名()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn; <span class="comment">// =&gt; 输出函数本身</span></span><br><span class="line">fn(); <span class="comment">// =&gt; 把函数执行（吧函数体重实现功能的代码执行）</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2019/png/271124/1552306799475-e85f6b5c-ed1a-4793-8c0d-41d1d899d981.png#align=left&display=inline&height=221&name=image.png&originHeight=442&originWidth=876&size=270908&status=done&width=438" alt="image.png"></p>
<p>形参：形式参数(变量)，函数的入口<br>当我们创建一个函数想要实现个功能的时候，发现有一些材料不清楚，只有当函数运行的时候，别人传递给我，我才知道，此时我们就需要设定入口,让用户执行的时候通过入口把值把我们</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(num1+num2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实参:函数执行传递给函数的具体值就是实参</span></span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">fn(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>把其他数据类型转换为number类型<br>-&gt; isNaN、Number、pareInt、parseFloat<br>-&gt; 在进行数据加减乘除数学运算的时候</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// true -&gt; 1 false-&gt;0</span></span><br><span class="line"><span class="comment">// ''-&gt;0  '12'-&gt;12  '12px'-&gt;NaN/12</span></span><br><span class="line"><span class="comment">// '小伙子'-&gt;NaN</span></span><br><span class="line"><span class="comment">// null -&gt; 0 </span></span><br><span class="line"><span class="comment">// undefined-&gt; NaN</span></span><br><span class="line">&#123;&#125; /^$/ <span class="function"><span class="keyword">function</span>(<span class="params"></span>) -&gt;<span class="title">NaN</span></span></span><br><span class="line">[]</span><br><span class="line">[<span class="number">12</span>]-&gt;<span class="string">'12'</span>-&gt;<span class="number">12</span></span><br><span class="line">[<span class="string">'12,13'</span>]-&gt;<span class="string">'12,23'</span>-&gt;<span class="literal">NaN</span></span><br><span class="line"><span class="comment">// =&gt; 引用数据类型转换为数字</span></span><br><span class="line"><span class="comment">// 通过toString方法把数组转换为字符串，然后在调用Number转换为数字</span></span><br></pre></td></tr></table></figure>

<h3 id="JS中的数据运算"><a href="#JS中的数据运算" class="headerlink" title="JS中的数据运算"></a>JS中的数据运算</h3><ul>
<li>+、-、*、/加减乘除</li>
<li>除了加法有特殊性，其余的运算符都是数学运算，也是遇到非数字类型，需要把其转换为number再运算</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1-&apos;1&apos; -&gt; 0</span><br><span class="line">10*null -&gt; 0</span><br><span class="line">10/undefined -&gt; NaN</span><br><span class="line">10*[10]-&gt;100</span><br></pre></td></tr></table></figure>

<h3 id="加法的特殊性"><a href="#加法的特殊性" class="headerlink" title="加法的特殊性:"></a>加法的特殊性:</h3><ul>
<li>在遇到字符串的时候，+不是数学运算，而是字符串拼接，只要不遇到字符串就是数学运算</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1+&apos;1&apos; -&gt; &apos;11&apos;</span><br><span class="line">null+&apos;1&apos; -&gt; ‘null1’</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串拼接:是把其它的值转换为字符串然后再拼接(toString)</li>
<li>其它数据类型的toString是直接的把值用单(双)引号包起来极客，只有对象的特殊性，对象的有特殊性，对象.toStirng===’[Object Object]</li>
</ul>
<h3 id="将其它数据类型转换为布尔类型"><a href="#将其它数据类型转换为布尔类型" class="headerlink" title="将其它数据类型转换为布尔类型"></a>将其它数据类型转换为布尔类型</h3><ul>
<li>Boolean、！、！！</li>
<li>在条件判断的时候、也是转换为布尔类型，然后验证条件的真假</li>
<li>只有0、NaN、空字符串、null、undefined五个转换为false、其余的都是转换为true</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[] -&gt; true</span><br><span class="line">-1 -&gt; true</span><br><span class="line"></span><br><span class="line">if(box)&#123;</span><br><span class="line">		// =&gt; 首先把box变量存储的值获取到，转化为布尔类型，如果为true条件成立，反之不成立</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(3+&apos;3px&apos;)&#123;</span><br><span class="line">	// 条件成立: 3 + &apos;3px&apos; = &apos;33px&apos; </span><br><span class="line">&#125;</span><br><span class="line">if(3-&apos;3px&apos;)&#123;</span><br><span class="line">	// 条件不成立: 3-&apos;3px&apos; = NaN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在使用-进行比较的时候"><a href="#在使用-进行比较的时候" class="headerlink" title="在使用==进行比较的时候"></a>在使用==进行比较的时候</h3><blockquote>
<p>在使用==进行比较的时候，如果左右两边的数据不相同，浏览器默认转换为相同的类型，然后在比较(‘===’不会这样操作)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 对象和对象: 应用数据类型比较的空间地址不一样，不是一个空间</span><br><span class="line">[] == [] -&gt; false</span><br><span class="line">var a =&#123;&#125;</span><br><span class="line">var b = a;</span><br><span class="line">a==b -&gt; true</span><br></pre></td></tr></table></figure>

<h3 id="对象和数字-吧对象转换成数字"><a href="#对象和数字-吧对象转换成数字" class="headerlink" title="对象和数字:吧对象转换成数字"></a>对象和数字:吧对象转换成数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[]== 0 -&gt; true</span><br><span class="line">(&#123;&#125;)=== NaN -&gt; false</span><br><span class="line">NaN和自己不相等和其它任何值都不相等</span><br></pre></td></tr></table></figure>

<h3 id="对象和字符串-把两边都转换为数字比较的"><a href="#对象和字符串-把两边都转换为数字比较的" class="headerlink" title="对象和字符串:把两边都转换为数字比较的"></a>对象和字符串:把两边都转换为数字比较的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]===&apos;&apos; -&gt; true</span><br></pre></td></tr></table></figure>

<h3 id="对象和布尔值-把两边都转换成数字"><a href="#对象和布尔值-把两边都转换成数字" class="headerlink" title="对象和布尔值:把两边都转换成数字"></a>对象和布尔值:把两边都转换成数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[]==true -&gt;  0==1 -&gt;false</span><br><span class="line">[]==false -&gt;  0==0 -&gt;true</span><br><span class="line">![]==false -&gt;  ![]  -&gt;把数组变成为布尔在取反=false</span><br><span class="line">false=false -&gt; true</span><br></pre></td></tr></table></figure>

<p>字符串和数字:字符串转换为数字<br>字符串和布尔:都转为数字<br>布尔和数字:布尔转换为数字</p>
<p>规律:两个等于号比较，左右两边数字值的类型不一样，浏览器会吧两边的类型都转换为数字然后再比较，但是null和undefined除外<br>null==undefined -&gt; true<br>null===undefined -&gt; false<br>null 和 undefined 和其它任何都不相等<br>null==0 -&gt; false null以及undefined和其它任何值都不相等</p>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2019/04/09/JavaScript基础入门/6 JS的DOM获取节点/" title="6.JS的DOM获取节点" class="prev">上一篇</a><a href="/2019/04/09/JavaScript基础入门/5 JS中常见的操作的语句/" title="5.JS中常见的操作的语句" class="next">下一篇</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "etKOnIgADEvkR6CDiOHXF4XL-gzGzoHsz",
    appKey: "wE8SOzh6b33F22PmUwjVNks6",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2017 - 2019 <a target="_blank">Mason Mei</a></p><p> <span style="padding-right: 6px;">沪ICP备17032864号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="/scripts/ar-anchor.js"></script><script src="/scripts/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-141573669-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("etKOnIgADEvkR6CDiOHXF4XL-gzGzoHsz", "wE8SOzh6b33F22PmUwjVNks6");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>