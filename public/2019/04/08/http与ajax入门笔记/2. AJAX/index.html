<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> 2. AJAX · AsGiant-bolg</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="作用域就是变量的作用范围。也就是你声明一个变量以后，这个变量可以在什么场合下使用。以前的JavaScript只有全局作用域，和函数作用域。"><meta name="keywords"><meta name="author" content="Mason Mei"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="AsGiant-bolg"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/2019/06/05/resume/" target="_self" data-hover="简历" class="nav-list-link">简历</a></li><li class="nav-list-item"><a href="tel:17621515830" target="_self" data-hover="联系我" class="nav-list-link">联系我</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">2. AJAX</h1><div class="post-info">2019-04-08<p class="visit"><i data-identity="2019/04/08/http与ajax入门笔记/2. AJAX/" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><h2 id="什么是ajax？"><a href="#什么是ajax？" class="headerlink" title="什么是ajax？"></a>什么是ajax？</h2><p>async javastctip and xml,异步的js和xml</p>
<h2 id="xml-可扩展的标记语言"><a href="#xml-可扩展的标记语言" class="headerlink" title="xml:可扩展的标记语言"></a>xml:可扩展的标记语言</h2><blockquote>
<p>作用是通过存储数据的(通过自己扩展的标记名称清晰的展示出来数据结构)</p>
</blockquote>
<blockquote>
<p>ajax值所以称为异步的js和xml,主要原因是:当初最开始用ajax实现客户端和服务器端数据通信的时候，传输的数据格式一般都是xml格式的数据，我们把他们称为异步js和xml(现在一般都是基于json格式进行数据传输)</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='UTF-8'?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>25<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">score</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">english</span>&gt;</span>90<span class="tag">&lt;/<span class="name">english</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">math</span>&gt;</span>90<span class="tag">&lt;/<span class="name">math</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">chinese</span>&gt;</span>90<span class="tag">&lt;/<span class="name">chinese</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">score</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="异步的js"><a href="#异步的js" class="headerlink" title="异步的js"></a>异步的js</h2><blockquote>
<p>这里的异步不是ajax只能基于异步进行请求(虽然建议都是使用异步变成)，这里的异步特指的是<strong>局部刷新</strong></p>
</blockquote>
<h2 id="局部刷新-vs-全局刷新"><a href="#局部刷新-vs-全局刷新" class="headerlink" title="局部刷新 vs 全局刷新"></a>局部刷新 vs 全局刷新</h2><blockquote>
<p>在非完全前后端分离项目中，前端开发只需要完成页面的制作，并且把一些基础的人机交互效果使用js完成即可，页面中需要动态呈现内容的部分，都是交给后台开发工程师做数据绑定和基于服务器进行渲染的(服务器端渲染)</p>
</blockquote>
<p>[优势]</p>
<ul>
<li>动态展示的数据在页面的原代码中可以看见，有利于seo优化推广(有利于搜索引擎的收录和抓取)</li>
<li>从服务器获取的结构就已经是最后要呈现的结果了，不需要客户端做额外的事情，所以也没加速快(前提是服务器端处理的速度够快，能够处理过来)，所以类似于京东、淘宝这些网站，首屏数据一般都是由服务器渲染的</li>
</ul>
<p>[弊端]</p>
<ul>
<li>实时更新的数据，每一次想要展示最新的数据，页面都要重新的刷新一次，这样肯定不行</li>
<li>都交给服务器端做数据渲染，服务器端的压力太大，如果服务器处理不过来，页面呈现的速度更慢(所以京东、淘宝这类网站,除了首屏是服务器端渲染的，其他屏一般都是客户端做数据渲染绑定)</li>
<li>这种模式不利于开发(开发效率低)</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/271124/1554193153655-396c293f-995c-4246-b4e7-a7c801e3b47f.png#align=left&display=inline&height=282&name=image.png&originHeight=422&originWidth=1050&size=333041&status=done&width=702" alt="image.png"></p>
<blockquote>
<p>目前市场上大部分项目都是前后端完全分离的项目(也有非完全前后端分离的)</p>
</blockquote>
<h2 id="前后端完全分离"><a href="#前后端完全分离" class="headerlink" title="前后端完全分离"></a>前后端完全分离</h2><p>前后端完全分离的项目，页面中需要动态绑定的数据是交给客户端完全渲染的</p>
<ul>
<li>想服务器端发送ajax请求</li>
<li>把从服务器端获取的数据解析处理，拼接成为我们需要展示的html字符串</li>
<li>把拼接好的字符串替换页面中某一部分的内容(局部刷新),页面整体不需要重新加载，局部渲染极客</li>
</ul>
<p>[优势]</p>
<ul>
<li>我们可以根据需求，任意修改页面中某一部分的内容(例如实时刷新),整体页面不刷新，性能好，体验好(所有表单验证，需要实时刷新的等需求都要基于ajax实现)</li>
<li>有利于开发，提高开发的效率<ul>
<li>前后端的完全分离，后台不需要考虑前端如何实现，前端也不需要考虑后台用什么技术，真正意义上实现了技术的划分</li>
<li>可以同时进行开发:项目开发开始，首先制定前后端数据交互的结构文档(文档中包含了，调用哪个接口或者那些数据等协议规范),后台吧接口线写好(目前很多公司也需要前端自己拿node来模拟这些接口)，客户端按照接口调取极客，后端再去实现接口功能极客</li>
</ul>
</li>
</ul>
<p>[弊端]</p>
<ul>
<li>不利于seo优化:第一次从服务器端获取的内容不包含需要动态绑定的数据，所以也没的原代码中没有这些内容，不利于seo收录，后期听过js添加到页面中的内容，并不会写在页面的源代码中(是源代码不是页面结构)</li>
<li>交由客户端渲染，首先需要把页面呈现，然后通过js的异步ajax请求获取数据，然后数据绑定，浏览器在动态增加部分重新渲染，无形中浪费了一些时间，没有服务器端渲染页面呈现速度快</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/271124/1554194196374-285844b7-622d-4fcd-a376-70afdea45846.png#align=left&display=inline&height=356&name=image.png&originHeight=402&originWidth=808&size=173137&status=done&width=716" alt="image.png"></p>
<h2 id="ajax请求"><a href="#ajax请求" class="headerlink" title="ajax请求"></a>ajax请求</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 不兼容ie6以及更低版本的浏览器(ie6 activeXobject)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开请求地址(可以理解为一些基础配置，但是并没有发送请求呢)</span></span><br><span class="line">xhr.open([method],[url],[<span class="keyword">async</span>],[username],[user password]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听ajax改变，获取响应信息(获取响应头信息，获取响应主体信息)</span></span><br><span class="line">xhr.onreadystatechange=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(xhr.readyState===<span class="number">4</span> &amp;&amp; xhr.readyState===<span class="number">200</span>)&#123;</span><br><span class="line">  	<span class="keyword">let</span> result = xhr.responseText;<span class="comment">// 获取响应主体中的内容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送ajax请求(括号中传递的信息内容是请求主体的内容)</span></span><br><span class="line"></span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<p> <br>分析第二部分的细节点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open([method],[url],[<span class="keyword">async</span>],[username],[user password]);</span><br></pre></td></tr></table></figure>

<h3 id="ajax请求方式（method）"><a href="#ajax请求方式（method）" class="headerlink" title="ajax请求方式（method）"></a>ajax请求方式（method）</h3><blockquote>
<p>get系列的请求</p>
</blockquote>
<ul>
<li><p>get</p>
</li>
<li><p>delete</p>
</li>
<li><p>head</p>
</li>
<li><p>…</p>
<blockquote>
<p>post系列的请求(推送)</p>
</blockquote>
</li>
<li><p>post</p>
</li>
<li><p>put:想服务器中增加指定的资源文件</p>
</li>
<li><p>…</p>
</li>
</ul>
<p>不管哪一种请求方式,客户端可以吧信息传递给服务器，服务器也可以吧信息返回给客户端，只要get系列一般以获取为主(给的少)</p>
<ol>
<li>我们想获取一些动态展示的信息，一般使用GET请求，因为只需要向服务器发送请求，告诉服务器端想要什么，服务器端就会把需要的数据返回</li>
<li>在实现注册功的时候，我们需要把客户端输入信息发送给服务器进行存储，服务器一般返回成功是成功等状态，此时我们一般都基于post请求完成</li>
<li>….</li>
</ol>
<p>get系列请求和post系列请求，在项目是在中存在很多的区别</p>
<ol>
<li><p>get请求传递给服务器的内容一般贸易post请求传递给服务器的内容多</p>
<ol>
<li>原因:get请求传递给服务器内容一般都是基于<strong>url地址问号传递参数</strong> 来实现的，而实现的，而post请求一般都是基于<strong>设置请求主体</strong>来实现的。浏览器都已自己的关于url的最大长度限制(谷歌:8kb、火狐:7kb、ie:2kb)超过限制长度的部分，浏览器会自动截取掉，导致传递给服务器的数据缺失</li>
<li>理论上post请求通过主体传递是没有大小限制，真实项目中为了保证传输的速度，我们会限制大小(例如:上传的资料或者图片我们会做大小的限制)</li>
</ol>
</li>
<li><p>get请求容易出现缓存(这个缓存不可控:一般我们都不需要)，而post不会出现缓存(除非自己做特殊处理)</p>
<ol>
<li>原因:get是通过url问号传参传递给服务器信息，二post是设置请求主体</li>
<li>设置请求主体不会出现缓存，但是url传递参数就会了</li>
<li><br>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	$.ajax(&#123;</span><br><span class="line">  	url:<span class="string">'getList?lx=news'</span>,</span><br><span class="line">    success:<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">    	<span class="comment">// 第一次请求数据回来，间隔一分钟后，浏览器又发送一次请求，</span></span><br><span class="line">      <span class="comment">// 但是新发送，不管是地址还是传递的参数都和第一次不一样，</span></span><br><span class="line">      <span class="comment">// 浏览器很有可能会把上一次数据获取，而不是获取新的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,<span class="number">60000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案:每一次重新请求的时候，在URL的末尾追加一个随机数，保证每一次请求的地址不完全一直</span></span><br><span class="line"><span class="comment">// 就可以避免是从缓存中读取的数据</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	url:<span class="string">'getList?lx=news_='</span>+<span class="built_in">Math</span>.random()</span><br><span class="line">	success:<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>GET请求没有post请求安全(post也并不是十分安全，只是相对安全)<br>原因:还是因为get是url传递给服务器有一种比较简单的黑客技术:url劫持，也就是可以客户端传递给服务器劫持掉，导致信息泄露</p>
</li>
</ol>
<h3 id="2-4-2-url"><a href="#2-4-2-url" class="headerlink" title="2.4.2 url"></a>2.4.2 url</h3><blockquote>
<p>请求数据的地址(api地址)，真实项目中，后台开发工程师会编写一个api文档，在api文档中汇总了获取那些数据需要使用哪些地址，我们按照文档操作即可</p>
</blockquote>
<h3 id="2-4-3-async"><a href="#2-4-3-async" class="headerlink" title="2.4.3 async"></a>2.4.3 async</h3><blockquote>
<p>异步(sync同步)，设置当前ajax请求是异步还是同步的，不写默认是异步(true)，如果设置false，则代表当前请求是同步的</p>
</blockquote>
<blockquote>
<p>用户名和密码这两个参数一般不用，如果你请求的url地址所在服务器设定了访问权限，则需要我们提供通行的用户名和密码才可以(一般服务器都可以允许匿名访问的)</p>
</blockquote>
<h2 id="AJAX状态码"><a href="#AJAX状态码" class="headerlink" title="AJAX状态码"></a>AJAX状态码</h2><p>xhr.readyState</p>
<ol>
<li>unsent 未发送，只要创建一个ajax对象，默认值是零</li>
<li>opened 我们已经执行了xhr,open这个操作</li>
<li>headers_resceived 当前ajax的请求已经发送，并且已经接收到服务器端返回的响应头信息了</li>
<li>loading 响应主体内容正在返回的路上</li>
<li>done 响应主体内容已经返回到客户端</li>
</ol>
<h2 id="HTTP网络状态码"><a href="#HTTP网络状态码" class="headerlink" title="HTTP网络状态码"></a>HTTP网络状态码</h2><blockquote>
<p>记录了当前服务器返回信息的状态</p>
</blockquote>
<p>xhr.status</p>
<ul>
<li>200成功，一个完整的http事务完成了(以2开头的状态码一般性都是成功)</li>
<li>3开头一般也是成功，只不过是服务器做了特殊的处理<ul>
<li>301 moved permanently 永久转移(永久重定向)</li>
<li>302 move temporarily 临时转移(临时重定向，新的http版本中任务307是临时重定向) <ul>
<li>一般用于服务器的负载均衡:当前服务器处理不了，我把当前请求临时交给其他的服务器处理(一般图片请求经常出现302,很多公司都有单独的图片服务器)</li>
</ul>
</li>
<li>304 not modified 从浏览器缓存中获取数据 <ul>
<li>把一些不经常更新的文件或者内容缓存到浏览器中，下一次从缓存中获取，减轻服务器压力，也提高页面加载的速度</li>
</ul>
</li>
</ul>
</li>
<li>4开头的，一般性都是失败的，而且客户端的问题偏大<ul>
<li>400:请求参数错误</li>
<li>401:无权限访问</li>
<li>404:访问地址不存在</li>
</ul>
</li>
<li>5开头的，一般都是失败，而且服务器的问题偏大<ul>
<li>500:internal Server Error 未知的服务器错误</li>
<li>503:Service Unavailable 服务器超负债</li>
<li>…</li>
</ul>
</li>
</ul>
<p>面试题 ajax中总共支持几个方法<br>let xhr = new xmlHttpReques();<br>console.dir(xhr);</p>
<p>[属性]<br>readyState:存储的是当前ajax的状态<br>response/responseText/responseXML : 都是用来接收服务器返回的响应主体的内容，只是更具服务器返回内容的格式不一样，我们使用不同的属性接收即可<br>responseText是最常见的，接收到结果是字符串格式的(一般服务器返回的数据都是json格式字符串)<br>responXML:偶尔会用到，如果服务器返回的是xml文档数据，我们需要使用这个属性接收<br>status:记录了服务器返回的http状态码<br>statusText:对返回状态码的描述<br>timeout:设置当前ajax请求的超时时间，假设我们设置时间为3000(MS)，从AJAX请求发送开始，3秒后响应主体内容还没有返回，浏览器会把当前ajax请求强行断开</p>
<p>[方法]<br>abor():强行终端ajax请求<br>getAllResponseHeaders():获取全部的响应头信息(获取的结果是一丢字符串文本)<br>getResponseHeader(key):获取指定属性名的响应头部信息，例如:xhr.getResponseHeader(‘data’)获取响应头中存储的服务的时间<br>open():打开一个url地址<br>overridMimeType():重写数据的MIME类型<br>send():发送ajax请求(括号中书写的内容是客户端请求主体吧信息传递给服务器)<br>setRequestHeader(key,value):设置请求头信息(可以是设置自定义请求信息)</p>
<p>[事件]<br>onabort:当ajax被终端请求触发这个时间<br>onreadstatechange:ajax状态发烧改变，会触发这个事件<br>ontimeout:当AJAX请求超时，会触发这个事件<br>…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest(();</span><br><span class="line">xhr.open(<span class="string">'get'</span>,<span class="string">'temp.json?_='</span>+<span class="built_in">Math</span>.random(),<span class="literal">true</span>);</span><br><span class="line">xhr.setRequesHeader(<span class="string">'cookie'</span>,<span class="string">'xxx'</span>); <span class="comment">// =&gt; 设置请求内容不能出现中文汉字</span></span><br><span class="line">xhr.timeout = <span class="number">10</span>;</span><br><span class="line">xhr.ontimeout=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'当前请求已经超时'</span>);</span><br><span class="line">  xhr.abort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">let</span> &#123;<span class="attr">readyState</span>:state,status&#125; = xhr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 说明请求数据成功了</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="regexp">/^(2|3)\d&#123;2&#125;$/</span>.test(status)) <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在状态为2的时候就获取响应头信息</span></span><br><span class="line">    <span class="keyword">if</span>(state === <span class="number">2</span>)&#123;</span><br><span class="line">    	<span class="keyword">let</span> headerAll = xhr.getAllResponseHeaders(),</span><br><span class="line">      		serverDate = xhr.getResponseHeader(<span class="string">'date'</span>);<span class="comment">// 获取的服务时间是格林尼治时间(相比北京时间差不多差8小时)</span></span><br><span class="line">          <span class="built_in">console</span>.log(headerAll,<span class="keyword">new</span> <span class="built_in">Date</span>(serverDate));</span><br><span class="line">      		<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在状态为4的时候就获取响应头信息已经回来了</span></span><br><span class="line">    <span class="keyword">if</span>(state === <span class="number">4</span>)&#123;</span><br><span class="line">    	<span class="keyword">let</span> valueText = xhr.responseText,<span class="comment">// 获取到的结果一般都是json字符串(可以时间json.parse把其转换成json对象) </span></span><br><span class="line">          valueXML = xhr.responseXML; <span class="comment">// 获取到的结果是xml格式的数据，(可以通过xml的一些常规操作获取存储的指定信息)</span></span><br><span class="line">      <span class="comment">// 如果服务器返回的是xml文档，responseText获取的结果是字符串，而responseXML获取的是标准xml文档</span></span><br><span class="line">      <span class="built_in">console</span>.log(valueText,valueXML);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.send(<span class="string">'name=wjw&amp;age=23&amp;sex=man'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="AJAX中的同步和异步编程"><a href="#AJAX中的同步和异步编程" class="headerlink" title="AJAX中的同步和异步编程"></a>AJAX中的同步和异步编程</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'get'</span>,<span class="string">'temp.json'</span>,<span class="literal">false</span>);</span><br><span class="line">xhr.onredystatechange=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(xhr.readySate);</span><br><span class="line">&#125;</span><br><span class="line">xhr.send();</span><br><span class="line"><span class="comment">// 只输出一次结果4</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2019/png/271124/1554350463659-0b94b605-b1ab-4b9c-adc4-c4b4873acfdf.png#align=left&display=inline&height=264&name=image.png&originHeight=528&originWidth=694&size=230731&status=done&width=347" alt="image.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'get'</span>,<span class="string">'temp.json'</span>,<span class="literal">false</span>);</span><br><span class="line">xhr.send();<span class="comment">// =&gt; 同步开始发送ajax请求，开启ajax任务，在任务没有完成之前，什么事情都做不了</span></span><br><span class="line"><span class="comment">// 下面绑定时间也做不了 =&gt; loading =&gt; 当readyState ===4 的是ajax任务完成，开始执行下面的操作</span></span><br><span class="line">xhr.onreadystatechange=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(xhr.readySate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绑定方法之前状态已经为4了，此时ajax的状态不会再改吧其他值，所以事件永远不会被处罚</span></span><br><span class="line"><span class="comment">// 一次都没有执行方法(使用ajax同步编程，不要把send放在事件监听前</span></span><br><span class="line"><span class="comment">// 这样我们无法在绑定方法中获取响应主体的内容)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2019/png/271124/1554368143539-8939fb33-f95e-4e86-8b85-3de2a9b8eac1.png#align=left&display=inline&height=203&name=image.png&originHeight=406&originWidth=548&size=142518&status=done&width=274" alt="image.png"></p>
<pre><code class="javascript"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();

<span class="comment">// 下面绑定时间也做不了 =&gt; loading =&gt; 当readyState ===4 的是ajax任务完成，开始执行下面的操作</span>
xhr.onreadystatechange=<span class="function"><span class="params">()</span>=&gt;</span>{
    <span class="built_in">console</span>.log(xhr.readySate);
  <span class="keyword">if</span>(xhr.readySate===<span class="number">1</span>) {
      xhr.setRequestHeader(<span class="string">'aaa'</span>,<span class="string">'bbb'</span>);
  }
}

xhr.open(<span class="string">'get'</span>,<span class="string">'temp.json'</span>,<span class="literal">false</span>);
<span class="comment">// xhr.readyState === 1 AJAX特殊处理的一件事:执行OPEN状态变为1,会主动把之前监听的方法执行一次</span>
<span class="comment">// 然后再去执行SEND</span>

xhr.send();
<span class="comment">// xhr.redayState === 4 AJAX任务借宿，主任务队列完成</span>
</code></pre>
<h2 id="AJAX类库的封装"><a href="#AJAX类库的封装" class="headerlink" title="AJAX类库的封装"></a>AJAX类库的封装</h2><blockquote>
<p>JQ中的AJAX</p>
</blockquote>
<h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><blockquote>
<p>请求api地址</p>
</blockquote>
<h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><blockquote>
<p>请求方法get/post..在老板的jq中使用是type，使用type和method相同效果</p>
</blockquote>
<h3 id="dataType"><a href="#dataType" class="headerlink" title="dataType"></a>dataType</h3><blockquote>
<p>dataType只是我们预设获取结果的类型不会影响服务器的返回(服务器端一般给我们返回的都是json格式的字符串),如果我们预设是json,那么类库中将吧服务器返回的字符串转换为json对象，如果我们预设是text(默认值)，我们把服务器获取的结果直接拿过来操作即可，我们预设的值还可以xml等</p>
</blockquote>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><blockquote>
<p>设置是否清楚缓存，只对get系列请求有作用，默认是true不清除缓存，手动设置false，jq类库在请求url的末尾最佳一个随机数来清楚缓存</p>
</blockquote>
<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><blockquote>
<p>我们通过data可以把一些信息传递给服务器，get系列请求会把data中的内容拼接在url的末尾通过问号传参的方式给服务器，post系列请求会把内容请求放在主题传递给服务器;data的值可以设置为两种格式，字符串、对象，如果是字符串，设置的值是传递给服务器的就是什么，如果设置成对象，jq会把对象变为xxx=xxx&amp;xx=xx,这样来数据传递</p>
</blockquote>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><blockquote>
<p>设置同步或者异步，默认是true代表异步，false代表同步</p>
</blockquote>
<h3 id="success"><a href="#success" class="headerlink" title="success"></a>success</h3><blockquote>
<p>dangajax请求成功后redayState===4&amp;&amp;statue是以2或者3开头的<br>请求成功后jq会把传递的回调函数执行，并且获取的结果当做实参传递给回调函数(result就是我们从服务器获取的结果)</p>
</blockquote>
<h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><blockquote>
<p>请求错误触发回调函数</p>
</blockquote>
<h3 id="complate"><a href="#complate" class="headerlink" title="complate"></a>complate</h3><blockquote>
<p>不管请求还是错误的还是正确的都会触发这个回调函数(他就是完成的意思)</p>
</blockquote>
<p>….</p>
<h2 id="封装自己的AJAX库"><a href="#封装自己的AJAX库" class="headerlink" title="封装自己的AJAX库"></a>封装自己的AJAX库</h2><ul>
<li>url</li>
<li>method/type</li>
<li>data</li>
<li>dataType</li>
<li>async</li>
<li>cache</li>
<li>success</li>
</ul>
<pre><code class="javascript">
~funcction(){

    <span class="class"><span class="keyword">class</span> <span class="title">ajaxClass</span> </span>{
        <span class="comment">// send ajax</span>
        init() {
            <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();
            xhr.onreadustatechange = <span class="function"><span class="params">()</span> =&gt;</span> {
                <span class="keyword">if</span> (!<span class="regexp">/^[23]\d{2}$/</span>.test(xhr.status)) <span class="keyword">return</span>;
                <span class="keyword">if</span> (xhr.redayState === <span class="number">4</span>) {
                    <span class="keyword">let</span> result = xhr.responseText;
                    <span class="comment">//    DATA-TYPE</span>
                    <span class="keyword">switch</span> (<span class="keyword">this</span>.dataType.toUpperCase()) {
                        <span class="keyword">case</span> <span class="string">'TEXT'</span>:
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">'JSON'</span>:
                            result = <span class="built_in">JSON</span>.parese(result);
                            <span class="keyword">break</span>;
                        <span class="keyword">case</span> <span class="string">'XML'</span>:
                            result = xhr.responseXML;
                            <span class="keyword">break</span>;
                    }
                    <span class="keyword">this</span>.success(result);
                }
            }
            <span class="comment">// DATA</span>
            <span class="keyword">if</span> (<span class="keyword">this</span>.data !==<span class="literal">null</span>) {
                <span class="keyword">this</span>.formatData();
                <span class="keyword">if</span> (<span class="keyword">this</span>.idGET) {
                    <span class="keyword">this</span>.url +=<span class="keyword">this</span>.querySymbol()+<span class="keyword">this</span>.data;
                    <span class="keyword">this</span>.data = <span class="literal">null</span>;
                }
            }
            <span class="comment">// CACHE</span>
            <span class="keyword">this</span>.isGET ? <span class="keyword">this</span>.cache();
            xhr.open(<span class="keyword">this</span>.method, <span class="keyword">this</span>.url, <span class="keyword">this</span>.async);
            xhr.send();
        }

        cacheFn() {
            <span class="comment">// THIS:EXAMPLE</span>
            !<span class="keyword">this</span>.cache ? <span class="keyword">this</span>.url += <span class="string">`<span class="subst">${<span class="keyword">this</span>.querySymbol()}</span>_=<span class="subst">${<span class="built_in">Math</span>.random()}</span>`</span> : <span class="literal">null</span>;
        }

        querySymbol() {
            <span class="comment">// THIS:EXAMPLE</span>
            <span class="keyword">return</span> <span class="keyword">this</span>.url.indexOf(<span class="string">'?'</span>) &gt; <span class="number">-1</span> ? <span class="string">'&amp;'</span> : <span class="string">'?'</span>;
        }

        formatData(){
             <span class="comment">// THIS:EXAMPLE</span>
             <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">this</span>.data)===<span class="string">'[Object Object]'</span>){
                 <span class="keyword">let</span> obj = <span class="keyword">this</span>.data,
                     str = <span class="string">``</span>;
                     <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) {
                         <span class="keyword">if</span> (object.hasOwnProperty(key)) {
                          str +=<span class="string">`<span class="subst">${key}</span>=<span class="subst">${obj[key]}</span>`</span>; 
                         }
                     }
                str = str.replace(<span class="regexp">/&amp;$/g</span>,<span class="string">''</span>);
                <span class="keyword">this</span>.data = str;
             }
        }
    }
    <span class="keyword">let</span> ajax = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{};
    <span class="comment">// init parameters</span>
    <span class="built_in">window</span>.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">{</span></span>
<span class="function"><span class="params">        url = null,</span></span>
<span class="function"><span class="params">        method = <span class="string">'GET'</span>,</span></span>
<span class="function"><span class="params">        type = <span class="string">'GET'</span>,</span></span>
<span class="function"><span class="params">        data = null,</span></span>
<span class="function"><span class="params">        dataType = <span class="string">'JSON'</span>,</span></span>
<span class="function"><span class="params">        cache = true,</span></span>
<span class="function"><span class="params">        async = ture,</span></span>
<span class="function"><span class="params">        suceess = null</span></span>
<span class="function"><span class="params">    } = {}</span>) </span>{
        <span class="keyword">let</span> _this = <span class="keyword">new</span> ajaxClass(); <span class="comment">// 创建实例</span>
        [<span class="string">'url'</span>, <span class="string">'method'</span>,<span class="string">'data'</span>,<span class="string">'dataType'</span>,<span class="string">'cache'</span>,<span class="string">'async'</span>,<span class="string">'success'</span>].forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>{
            <span class="keyword">if</span> (item === <span class="string">'method'</span>) {
                _this.method = type === <span class="literal">null</span> ? method : type;
                <span class="keyword">return</span>;
            }
            <span class="keyword">if</span> (item===<span class="string">'success'</span>) {
                 _this.suceess = <span class="keyword">typeof</span> success === <span class="string">'function'</span> ? success : <span class="keyword">new</span> <span class="built_in">Function</span>();
            }
            _this[item] = <span class="built_in">eval</span>(item);
        })
        _this.isGET = <span class="regexp">/^(GET|DELETE|HEAD)$/i</span>.test(example.method);
        _this.init();
        <span class="keyword">return</span> _this;
    };
}();
ajax({})</code></pre>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2019/04/08/http与ajax入门笔记/3. 内容编码和加密解密方法/" title="3. 内容编码和加密解密方法" class="prev">上一篇</a><a href="/2019/04/08/http与ajax入门笔记/1. HTPP/" title="1. HTPP" class="next">下一篇</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "etKOnIgADEvkR6CDiOHXF4XL-gzGzoHsz",
    appKey: "wE8SOzh6b33F22PmUwjVNks6",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2017 - 2020 <a target="_blank">Mason Mei</a></p><p> <span style="padding-right: 6px;">沪ICP备17032864号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="/scripts/ar-anchor.js"></script><script src="/scripts/main.js"></script><script src="/scripts/l2dwidget.min.js"></script><script src="/scripts/tencent.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-141573669-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("etKOnIgADEvkR6CDiOHXF4XL-gzGzoHsz", "wE8SOzh6b33F22PmUwjVNks6");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>