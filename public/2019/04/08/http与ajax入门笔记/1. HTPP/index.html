<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> 1. HTPP · AsGiant-bolg</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="作用域就是变量的作用范围。也就是你声明一个变量以后，这个变量可以在什么场合下使用。以前的JavaScript只有全局作用域，和函数作用域。"><meta name="keywords"><meta name="author" content="Mason Mei"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="AsGiant-bolg"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/2019/06/05/resume/" target="_self" data-hover="简历" class="nav-list-link">简历</a></li><li class="nav-list-item"><a href="tel:17621515830" target="_self" data-hover="联系我" class="nav-list-link">联系我</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">1. HTPP</h1><div class="post-info">2019-04-08<p class="visit"><i data-identity="2019/04/08/http与ajax入门笔记/1. HTPP/" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><h2 id="前端和后端如何通讯"><a href="#前端和后端如何通讯" class="headerlink" title="前端和后端如何通讯"></a>前端和后端如何通讯</h2><blockquote>
<p>前端:客户端<br>后端:服务端</p>
</blockquote>
<p>职业规划建议</p>
<blockquote>
<p>培养自己的人脉圈，以及建立自己的影响力</p>
</blockquote>
<ul>
<li>状态自己的总和能力</li>
<li>经常参加一些活动</li>
<li>开放分享(做讲师分享自己的智慧、写组件的个人博客做技术分享)</li>
</ul>
<p>当我们在浏览器地址中输入URL地址，到最后看到页面，中间经历了哪些事情？<br>假设我们访问的是 <a href="https://www.baidu.com这个地址，按下enter建后，我们可以看到百度首页" target="_blank" rel="noopener">https://www.baidu.com这个地址，按下enter建后，我们可以看到百度首页</a></p>
<ul>
<li>百度页面并没有在我们自己的客服端本地，我们是输入地址后，才请求过来的</li>
<li>输入不同的域名可以看到不同的页面</li>
<li>有的网页是https，有的是http(也有的是ftp)</li>
<li>需要客户端联网才能完成这些事情</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/271124/1554171011360-68037c8f-c3bf-4e19-a4e2-ed9a695ce4f6.png#align=left&display=inline&height=237&name=image.png&originHeight=474&originWidth=786&size=228302&status=done&width=393" alt="image.png"></p>
<h3 id="DNS服务器-域名解析服务"><a href="#DNS服务器-域名解析服务" class="headerlink" title="DNS服务器 域名解析服务"></a>DNS服务器 域名解析服务</h3><p>1.<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>  220.163.18.24<br>域名和服务器关联在一起，是通过DNS解析完成，所谓的DNS解析就是在dns服务上生成一条解析记录，标注了域名和对应的外网ip地址</p>
<h3 id="都经历了哪些事情？"><a href="#都经历了哪些事情？" class="headerlink" title="都经历了哪些事情？"></a>都经历了哪些事情？</h3><ul>
<li>首先根据客户端输入的域名，到DNS服务器上进行反解析(通过域名找到对应服务器的外网ip)</li>
<li>通过找到外网的ip，找到对应的服务器</li>
<li>通过地址栏中输入的端口号(没输入是因为不同协议有自己默认的端口号)找到服务器上发布的对应项目</li>
<li>服务器获取请求资源的地址，例如/stu/index.html，把资源文件中的原代码找到<ul>
<li>response 响应阶段</li>
</ul>
</li>
<li>服务器端会把找的原代码返回给客户端(通过http等传输协议返回)</li>
<li>客户端接收到原代码后，会交给浏览器的内核(渲染引擎)进行渲染，最后由浏览器绘制出对应的页面<ul>
<li>服务器自主渲染</li>
</ul>
</li>
</ul>
<h3 id="客户端和服务端交互-通讯-模型"><a href="#客户端和服务端交互-通讯-模型" class="headerlink" title="客户端和服务端交互(通讯)模型"></a>客户端和服务端交互(通讯)模型</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/png/271124/1554171831526-af8fe24c-dbf6-44cc-ae64-4f30506b7a0a.png#align=left&display=inline&height=192&name=image.png&originHeight=328&originWidth=1094&size=230743&status=done&width=642" alt="image.png"></p>
<h2 id="第一部分-传输协议"><a href="#第一部分-传输协议" class="headerlink" title="第一部分 传输协议"></a>第一部分 传输协议</h2><h3 id="URL、URI、URN"><a href="#URL、URI、URN" class="headerlink" title="URL、URI、URN"></a>URL、URI、URN</h3><ul>
<li>URI : 统一资源标识符</li>
<li>URL: 统一资源路径地址</li>
<li>URN：统一资源名称</li>
<li>URI=URL+URN</li>
</ul>
<blockquote>
<p>一个完整的url包含很多部分<br><a href="https://www.yuque.com/as-giant/dz5g6s/eh4kdu/edit" target="_blank" rel="noopener">https://www.yuque.com/as-giant/dz5g6s/eh4kdu/edit</a>?name=wang&amp;age=2</p>
</blockquote>
<blockquote>
<p>传输协议是用来完成客户端和服务端的数据(内存)传输的，类似于快递小哥、负责把客户和商家的物品来回床底</p>
</blockquote>
<ul>
<li>客户端不仅可以向服务器发送请求，而且还可以吧一些内容传递给服务器</li>
<li>服务器端也可以把内容返回给客户端<ul>
<li>客户端和服务端传输的内容总称:<strong>http报文</strong>，这些报文信息都是基于传输协议完成传输的，客户端传递给服务器叫做请求(<strong>Request</strong>),服务器返回给客户端叫做响应(<strong>Response</strong>) , request+response两个阶段统称为一个HTTP事务(事务:一个完整的事情)</li>
</ul>
</li>
</ul>
<h3 id="HTTP事务"><a href="#HTTP事务" class="headerlink" title="HTTP事务"></a>HTTP事务</h3><ul>
<li>当客户端想服务器端发送请求，此时客户端和服务器端会简历一个传输通道(链接通道)，传输协议就是基于这个通道吧信息进行传输的</li>
<li>当服务器端接受到请求信息，把内容返回给客户端后，传输通道会自动销毁关闭</li>
</ul>
<h3 id="传输协议分类"><a href="#传输协议分类" class="headerlink" title="传输协议分类"></a>传输协议分类</h3><ul>
<li>http:超文本传输协议(客户端和服务器端传输的内容除了文本以外)，还可以传输图片，音视频等文件流[二进制编码/base64],以及传输xml格式的数据等，是目前市场上应用最广泛的传输协议</li>
<li>https:http ssl,它比http更加安全，要往数据内容的传输通道是经过ssl加密的(它需要在服务器端惊醒特殊的处理)，所以涉及资金类的网站一般都是https协议的</li>
<li>ftp:资源文件传输协议，一般用客户端把资源文件(不是代码)上传到服务端，或者从服务器端下载一些资源文件（ftp传输的内容会http这类传输协议传输的内容多)</li>
</ul>
<h3 id="http报文"><a href="#http报文" class="headerlink" title="http报文"></a>http报文</h3><p>1、起始行</p>
<ul>
<li>请求起始行</li>
<li>响应起始行</li>
</ul>
<p>2、首部(头)</p>
<ul>
<li>请求头：内置请求头、自定义请求头</li>
<li>响应式：内置响应头、自定义响应头</li>
<li>通用头：请求和响应都有的</li>
</ul>
<p>3、主体</p>
<ul>
<li>请求主体</li>
<li>响应主体</li>
</ul>
<p>请求xxx都是客户端设置的信息，服务器获取这些信息<br>响应xxx都是服务器端设置的信息，客户端用来接受这些信息</p>
<h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>设置域名其实就给不好记忆的服务器外网ip设置了一个好记忆的名字<br>顶级域名(一级域名):qq.com<br>二级域名:<a href="http://www.qq.com、v.qq.com、sports.qq.com" target="_blank" rel="noopener">www.qq.com、v.qq.com、sports.qq.com</a><br>三级域名:kbs.sports.qq.com</p>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>在服务器发布项目的时候，我们可以通过端口号区分当前服务器上不同的项目<br>一台服务器的端口号取值范围:0~65535之间，如果电脑上安装了很多程序，有一些端口号是被占用了</p>
<p>HTTP:默认端口号80<br>HTTP:默认端口号443<br>FTP:默认端口号21</p>
<p>对于上述三个端口号其实是很重要的，如果被其它程序占用的，我们则不能使用了，所以服务器上一般是禁止安装其它程序的</p>
<h2 id="第四部分-请求资源文件的路径名称"><a href="#第四部分-请求资源文件的路径名称" class="headerlink" title="第四部分 请求资源文件的路径名称"></a>第四部分 请求资源文件的路径名称</h2><p>/stu/index.html<br>在服务器中发布项目的时候，我们一般都会配置一些默认文档:用户即使不输入请求文件的名称，服务器也会找到默认文档(一般默认文档都是index/default…)<br>我们通常为了做seo优化，会把一些动态页面的地址(xxx.php、xxx.aspx、xxx.asp、xxx.jsp…)进行伪URL重写(需要服务器处理的)<br><a href="https://item.jd.com/432527.html" target="_blank" rel="noopener">https://item.jd.com/432527.html</a><br>不可能是有一个商品，自己就单独写一个详情页面，肯定是同一个详情页做的不同处理</p>
<h3 id="第一种方案"><a href="#第一种方案" class="headerlink" title="第一种方案"></a>第一种方案</h3><p>由后台语言很久详情页模板动态生成具体的详情页面</p>
<h3 id="第二种方案"><a href="#第二种方案" class="headerlink" title="第二种方案"></a>第二种方案</h3><p>当前页面就是一个页面，例如:detail.html/detail.php…,我们做详情页面的时候，开发是按照detail.html?id=432527 来开发的，但是这种页面不方便做seo优化，此时我们把真实的地址进行重写，重写为了让我们看到的是4325427.html</p>
<h3 id="第五部分-问号传承"><a href="#第五部分-问号传承" class="headerlink" title="第五部分 问号传承"></a>第五部分 问号传承</h3><p>?name=zf&amp;age=9<br>把一些通过xxx=xxx的方式，放在一个url的末尾，通过问号传递</p>
<p>【作用】<br>1.在ajax请求中，我们可以通过问号传递参数的方式，客户端吧一些信息传递给服务器，服务器更具传递信息的不一样，返回不同的数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $.ajax(url,&#123;&#125;);</span></span><br><span class="line"><span class="comment">// $.get(url,function()&#123;&#125;);</span></span><br><span class="line"><span class="comment">// 对于ajax请求的特殊写法，原理还是基于ajax方法实现 $.post $.script</span></span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">'getPersonInfo?id=12'</span></span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前案例，我们传递给服务器的编号是多少，服务器端就会把对应编号人员信息给返回</span></span><br></pre></td></tr></table></figure>

<p>2.消除ajax请求中get方式缓存</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">	url:<span class="string">'xxx?_=0.123456'</span></span><br><span class="line">	method:<span class="string">'get'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 我们会在请求url的末尾最佳一个随机数_=随机数，保证每一次请求的url都是不一样的，以此来消除get请求一流的缓存问题</span></span><br></pre></td></tr></table></figure>

<p>3.通过url传递传输的方式，可以实现页面之间信息的通讯，例如:我们有两个页面A/B,A是列表页面、B是详情页，点击A中的某一条信息，进入到唯一的详情页B，如果展示不同的信息，这种操作就可以基于URL问号传递参数来实现了</p>
<p>例如:<br><a href="http://sports.qq.com/kbsweb/game.htm?mid=10000:1471087" target="_blank" rel="noopener">http://sports.qq.com/kbsweb/game.htm?mid=10000:1471087</a><br><a href="http://sports.qq.com/kbsweb/game.htm?mid=10000:1471086" target="_blank" rel="noopener">http://sports.qq.com/kbsweb/game.htm?mid=10000:1471086</a><br>在进入game.htm页面的时候，我们可以获取URL传递的参数值，更具传递参数值的不一样从服务器端获取不同的数据展示</p>
<p>在列表页面进行页面跳转的时候，我们需要记住的是跳转的同事传递不同的参数值<br><a href="game.html?mid=xxx"></a></p>
<h3 id="第六部分-HASH值"><a href="#第六部分-HASH值" class="headerlink" title="第六部分 HASH值"></a>第六部分 HASH值</h3><p>#xxx<br>URL末尾传递的井号什么，就是HASH值(哈希值)</p>
<p>[作用]<br>1、页面中锚点定位<br>2、前端路由(SPA单页面开发) –&gt;</p>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2019/04/08/http与ajax入门笔记/2. AJAX/" title="2. AJAX" class="prev">上一篇</a><a href="/2019/03/06/html入门/7 HTML 字符的使用/" title="7 HTML 字符的使用" class="next">下一篇</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "etKOnIgADEvkR6CDiOHXF4XL-gzGzoHsz",
    appKey: "wE8SOzh6b33F22PmUwjVNks6",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2017 - 2019 <a target="_blank">Mason Mei</a></p><p> <span style="padding-right: 6px;">沪ICP备17032864号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="/scripts/ar-anchor.js"></script><script src="/scripts/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-141573669-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("etKOnIgADEvkR6CDiOHXF4XL-gzGzoHsz", "wE8SOzh6b33F22PmUwjVNks6");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>